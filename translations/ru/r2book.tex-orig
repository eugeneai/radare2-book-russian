% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  a4paper,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1.5cm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{}

\begin{document}

![cover](cover.png)

{
\setcounter{tocdepth}{5}
\tableofcontents
}
\hypertarget{ux432ux432ux435ux434ux435ux43dux438ux435}{%
\section{Введение}\label{ux432ux432ux435ux434ux435ux43dux438ux435}}

Книга представляет собой обновленную версию оригинальной книги о
radare2, написанной пользователем pancake. Обновление начато
пользователем maijin. Текст книги активно поддерживается и обновляется
многими участниками через Интернет.

На сервере Github опубликованы ее исходники, добавляйте новое содержимое
или исправляйте опечатки:

\begin{itemize}
\tightlist
\item
  Github: \url{https://github.com/radareorg/radare2-book}
\item
  PDF: \href{https://github.com/radareorg/radare2-book/releases}{GHA
  Artifacts}
\item
  EPUB: \href{https://github.com/radareorg/radare2-book/releases}{GHA
  Artifacts}
\item
  Английская версия Online: \url{https://book.rada.re/}
\end{itemize}

\hypertarget{ux438ux441ux442ux43eux440ux438ux44f-ux43fux440ux43eux435ux43aux442ux430}{%
\subsection{История
проекта}\label{ux438ux441ux442ux43eux440ux438ux44f-ux43fux440ux43eux435ux43aux442ux430}}

В 2006 году Серхи Альварес (Sergi Àlvarez, он же pancake) работал
судебным аналитиком. Поскольку не разрешалось использовать программное
обеспечение компании для своих личных нужд, он решил написать небольшой
инструмент - шестнадцатеричный редактор, реализующий следующие
требования:

\begin{itemize}
\tightlist
\item
  быть чрезвычайно переносимым (unix friendly, command line, c, small),
\item
  открывать дисковые устройства, использование 64-битных смещений,
\item
  поиск строк и шестнадцатеричных кодов,
\item
  просмотр и сброс результатов на диск.
\end{itemize}

Редактор изначально разрабатывался для восстановления удаленных файлов
из раздела HFS+.

После этого pancake решил усовершенствовать инструмент: реализовать
подключаемый io, возможность подключаться к процессам. Для этого он
добавил возможности отладчика, поддержку нескольких архитектур и анализ
кода.

С тех пор проект эволюционировал. Теперь он оснащает полную
инфраструктуру для анализа двоичных файлов, используя основные концепции
UNIX. Концепции включают в себя знаменитые парадигмы «все является
файлом», «взаимодействие программ через объединение stdin/stdout» и «не
усложняйте без необходимости».

Потребность в запуске сценариев выявила проблемы в первоначальном
дизайне: монолитный инструмент усложнил использование API, потребовался
глубокий рефакторинг. В 2009 году создан radare2 (r2) как ответвление
radare1. Рефакторинг добавил желанной гибкости и динамические функции.
Это позволило значительно улучшить интеграцию, проложив путь к
использованию r2 \href{https://github.com/radareorg/radare2-bindings}{из
разных языков программирования}. Позже
\href{https://github.com/radareorg/radare2-r2pipe}{API r2pipe} обеспечил
доступ к radare2 при помощи каналов из любого языка.

То, что начиналось как проект одного человека с небольшими
эпизодическими дополнениями, постепенно превратилось в большой открытый
проект в 2014 году. Число пользователей быстро росло, и автору и
главному разработчику приходилось метаться между кодированием и
менеджментом проекта, интегрируя результаты различных разработчиков,
присоединившихся к проекту.

Инструктирование пользователей о необходимости сообщать о своих
проблемах позволило проекту определять новые направления развития.
Исходный код находится в
\href{https://github.com/radareorg/radare2}{GitHub radare2}, а
обсуждение - в Telegram-канале.

Проект остается активным и сейчас, в момент написания этой книги. Есть и
несколько побочных проектов, предоставляющих, среди прочего, графический
пользовательский интерфейс
(\href{https://github.com/radareorg/cutter}{Cutter}), декомпилятор
(\href{https://github.com/wargio/r2dec-js}{r2dec},
\href{https://github.com/radareorg/radeco}{radeco}), интеграцию с Frida
(\href{https://github.com/nowsecure/r2frida}{r2frida}), Yara, Unicorn,
Keystone и многое другое. Проекты доступны в
\href{https://github.com/radareorg/radare2-pm}{r2pm} (менеджер пакетов
radare2).

С 2016 года разработчики собирается раз в год на
\href{https://www.radare.org/con/}{r2con}, конгресс по проблемам
radare2, проводимый в Барселоне.

\hypertarget{ux43fux430ux43aux435ux442-ux43fux440ux43eux433ux440ux430ux43cux43c-radare2}{%
\subsection{Пакет программ
radare2}\label{ux43fux430ux43aux435ux442-ux43fux440ux43eux433ux440ux430ux43cux43c-radare2}}

Программная система Radare2 представляет собой набор небольших утилит
командной строки, используемых вместе или по отдельности. Глава дает
общее представление о том, как они функционируют, в специальных разделах
в конце книги есть информация по каждому инструменту.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radare2}{%
\subsubsection{Программа
radare2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radare2}}

Основной инструмент программной системы. Он основан на ядре, включающем
шестнадцатеричный редактор и отладчик. Программа Radare2 позволяет
загружать и отображать данные, полученные из различных источников данных
(ввода/вывода), включая диски, сетевые подключения, драйверы ядра,
отлаживаемые процессы и т.д., как будто это обычные файлы.

Возможности реализованного в ней интерфейса командной строки позволяют
перемещаться по файлу, проводить анализ данных, дизассемблировать,
вносить исправления в двоичные файлы, сравнивать данные, осуществлять
поиск и замену, а также визуализацию. Также можно управлять этим
интерфейсом из различных языков программирования, включая Python, Ruby,
JavaScript, Lua и Perl.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rabin2}{%
\subsubsection{Программа
rabin2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rabin2}}

Программа для извлечения информации из исполняемых двоичных файлов,
таких как ELF, PE, Java CLASS, Mach-O, а также любого другого формата,
поддерживаемого плагинами r2. Программа rabin2 используется ядром для
получения данных о формате файла, например, перечень экспортированных
символов, импортов, информации о формате файлов, перекрестных ссылках
(xrefs), зависимостей библиотек и разделов (секций загрузчика).

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rasm2}{%
\subsubsection{Программа
rasm2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rasm2}}

Ассемблер и дизассемблер, управляемый из командной строки операционной
системы, поддерживающий огромное множество архитектур, включая Intel x86
и x86-64, MIPS, ARM, PowerPC, Java.

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b}{%
\paragraph{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b}}

\begin{verbatim}
$ rasm2 -a java 'nop'
00
\end{verbatim}

\begin{verbatim}
$ rasm2 -a x86 -d '90'
nop
\end{verbatim}

\begin{verbatim}
$ rasm2 -a x86 -b 32 'mov eax, 33'
b821000000
\end{verbatim}

\begin{verbatim}
$ echo 'push eax;nop;nop' | rasm2 -f -
509090
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rahash2}{%
\subsubsection{Программа
rahash2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rahash2}}

Реализация блочного хеширования. Она позволяет хэшировать текстовые
строки и большие пространства на диске, rahash2 поддерживает много
различных алгоритмов, включая MD4, MD5, CRC16, CRC32, SHA1, SHA256.
Программа rahash2 используется для проверки целостности или отслеживания
изменений больших файлов, дампов памяти или дисков.

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-1}{%
\subsubsection{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-1}}

\begin{verbatim}
$ rahash2 file
file: 0x00000000-0x00000007 sha256: 887cfbd0d44aaff69f7bdbedebd282ec96191cce9d7fa7336298a18efc3c7a5a
\end{verbatim}

\begin{verbatim}
$ rahash2 -a md5 file
file: 0x00000000-0x00000007 md5: d1833805515fc34b46c2b9de553f599d
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radiff2}{%
\subsubsection{Программа
radiff2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radiff2}}

Утилита для сравнения двоичных файлов, реализующая множество алгоритмов.
Она поддерживает побайтовое сравнение или представление выявленных
различий двоичных файлов, а также сравнение результатов анализа кода,
полученных из радара, для поиска изменений в блоках кода.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rafind2}{%
\subsubsection{Программа
rafind2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rafind2}}

Программа для поиска байтов в файлах по заданным шаблонам.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-ragg2}{%
\subsubsection{Программа
ragg2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-ragg2}}

Представляет функции r\_egg в виде утилиты командной строки. Программа
ragg2 компилирует программы, представленные на простом языке высокого
уровня, в крошечные двоичные файлы для архитектур x86, x86-64 и ARM.

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-2}{%
\paragraph{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-2}}

\begin{verbatim}
$ cat hi.r
/* hello world in r_egg */
write@syscall(4); //x64 write@syscall(1);
exit@syscall(1); //x64 exit@syscall(60);

main@global(128) {
 .var0 = "hi!\n";
 write(1,.var0, 4);
 exit(0);
}
$ ragg2 -O -F hi.r
$ ./hi
hi!

$ cat hi.c
main@global(0,6) {
 write(1, "Hello0", 6);
 exit(0);
}
$ ragg2 hi.c
$ ./hi.c.bin
Hello
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rarun2}{%
\subsubsection{Программа
rarun2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rarun2}}

Предназначена для запуска программ в разных средах, с другими
аргументами, разрешениями, в других каталогах и переопределенными
файловыми дескрипторами по умолчанию. Программ rarun2 используется для

\begin{itemize}
\tightlist
\item
  Решения задачек crackme
\item
  Fuzzing
\item
  Организации различного рода тестов
\end{itemize}

\hypertarget{ux43fux440ux438ux43cux435ux440-ux441ux43aux440ux438ux43fux442ux430-rarun2}{%
\paragraph{Пример скрипта
rarun2}\label{ux43fux440ux438ux43cux435ux440-ux441ux43aux440ux438ux43fux442ux430-rarun2}}

\begin{verbatim}
$ cat foo.rr2
#!/usr/bin/rarun2
program=./pp400
arg0=10
stdin=foo.txt
chdir=/tmp
#chroot=.
./foo.rr2
\end{verbatim}

\hypertarget{ux43fux43eux434ux43aux43bux44eux447ux435ux43dux438ux435-ux43fux440ux43eux433ux440ux430ux43cux43cux44b-ux43a-ux441ux43eux43aux435ux442ux443}{%
\paragraph{Подключение программы к
сокету}\label{ux43fux43eux434ux43aux43bux44eux447ux435ux43dux438ux435-ux43fux440ux43eux433ux440ux430ux43cux43cux44b-ux43a-ux441ux43eux43aux435ux442ux443}}

\begin{verbatim}
$ nc -l 9999
$ rarun2 program=/bin/ls connect=localhost:9999
\end{verbatim}

\hypertarget{ux43eux442ux43bux430ux434ux43aux430-ux43fux440ux43eux433ux440ux430ux43cux43cux44b-ux43fux435ux440ux435ux43dux430ux43fux440ux430ux432ux438ux432-stdio-ux432-ux434ux440ux443ux433ux43eux439-ux442ux435ux440ux43cux438ux43dux430ux43b}{%
\paragraph{Отладка программы, перенаправив stdio в другой
терминал}\label{ux43eux442ux43bux430ux434ux43aux430-ux43fux440ux43eux433ux440ux430ux43cux43cux44b-ux43fux435ux440ux435ux43dux430ux43fux440ux430ux432ux438ux432-stdio-ux432-ux434ux440ux443ux433ux43eux439-ux442ux435ux440ux43cux438ux43dux430ux43b}}

1 - Откройте новый терминал и введите `tty', чтобы получить название
терминала:

\begin{verbatim}
$ tty ; clear ; sleep 999999
/dev/ttyS010
\end{verbatim}

2 - Создайте новый файл, содержащий следующий профиль rarun2 с именем
foo.rr2:

\begin{verbatim}
#!/usr/bin/rarun2
program=/bin/ls
stdio=/dev/ttys010
\end{verbatim}

3 - Теперь запустите команду radare2:

\begin{verbatim}
r2 -r foo.rr2 -d /bin/ls
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rax2}{%
\subsubsection{Программа
rax2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rax2}}

Минималистичный вычислитель математических выражений, используемый в
командной строке операционной системы. Он полезен для выполнения базовых
преобразований значений чисел с плавающей запятой в их шестнадцатеричное
представление, шестнадцатеричных строк в ASCII, восьмеричных чисел в
десятичные целые и многое другое. Программа также поддерживает установку
порядка следования байтов в представлении, используется также в качестве
интерактивной оболочки если аргументы не были в командной строке заданы.

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-3}{%
\paragraph{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-3}}

\begin{verbatim}
$ rax2 1337
0x539

$ rax2 0x400000
4194304

$ rax2 -b 01111001
y

$ rax2 -S radare2
72616461726532

$ rax2 -s 617765736f6d65
awesome
\end{verbatim}

\hypertarget{ux437ux430ux433ux440ux443ux437ux43aux430-radare2}{%
\subsection{Загрузка
radare2}\label{ux437ux430ux433ux440ux443ux437ux43aux430-radare2}}

Исходный код программы radare2 находится в GitHub-репозитории:
\url{https://github.com/radareorg/radare2}

Бинарные пакеты доступны для операционных систем Ubuntu, Maemo, Gentoo,
Windows, iPhone и др. Настоятельно рекомендуется именно загружать
исходный код и самостоятельно компилировать его. Это дает лучшее
понимание зависимостей, делает примеры более доступными и, конечно же,
позволяет вам иметь у себя самую последнюю версию программы.

Новый стабильный релиз обычно публикуется в Интернет каждый месяц.
Основная ветка разработки часто более стабильна, чем «стабильные»
релизы. Загрузка последней версии:

\begin{verbatim}
$ git clone https://github.com/radareorg/radare2.git
\end{verbatim}

Загрузка, вероятно, займет некоторое время, поэтому сделайте перерыв на
кофе и продолжайте читать эту книгу.

Можно обновить локальную копию репозитория, используя \texttt{git\ pull}
в любой папке дерева кода radare2:

\begin{verbatim}
$ git pull
\end{verbatim}

Если код вами был локально модифицирован, то эти правки можно отменить
(потерять их!):

\begin{verbatim}
$ git reset --hard HEAD
\end{verbatim}

Или пришлите нам патч ваших исправлений:

\begin{verbatim}
$ git diff > radare-foo.patch
\end{verbatim}

Наиболее удобным способом обновления и установки r2 в масштабах всей
операционной системы является использование:

\begin{verbatim}
$ sys/install.sh
\end{verbatim}

\hypertarget{ux441ux431ux43eux440ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson-ninja}{%
\subsubsection{Сборка при помощи meson +
ninja}\label{ux441ux431ux43eux440ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson-ninja}}

Существует также недоделанная настройка для Meson.

Использование clang и ld.gold ускоряет сборку:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{CC}\OperatorTok{=}\NormalTok{clang }\VariableTok{LDFLAGS}\OperatorTok{=}\NormalTok{{-}fuse{-}ld=gold }\ExtensionTok{meson}\NormalTok{ . release }\AttributeTok{{-}{-}buildtype}\OperatorTok{=}\NormalTok{release }\AttributeTok{{-}{-}prefix}\NormalTok{ \textasciitilde{}/.local/stow/radare2/release}
\ExtensionTok{ninja} \AttributeTok{{-}C}\NormalTok{ release}
\CommentTok{\# ninja {-}C release install}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux432ux441ux43fux43eux43cux43eux433ux430ux442ux435ux43bux44cux43dux44bux435-ux441ux43aux440ux438ux43fux442ux44b}{%
\subsubsection{Вспомогательные
скрипты}\label{ux432ux441ux43fux43eux43cux43eux433ux430ux442ux435ux43bux44cux43dux44bux435-ux441ux43aux440ux438ux43fux442ux44b}}

Ознакомьтесь со скриптами в \texttt{sys/}, они используются для
автоматизации этапов сборки, связанных с синхронизацией, построением и
установкой r2 и его привязок к различным системам программирования.
Наиболее важным из них является \texttt{sys/install.sh}. Он обновит,
очистит, соберет и установит (symstall) r2 в операционную систему.

Symstalling - это процесс установки всех программ, библиотек,
документации и файлов данных с использованием символьных ссылок, вместо
копирования файлов. По умолчанию он будет установлен в
\texttt{/usr/local}, но можно указать другой префикс, используя аргумент
\texttt{-\/-prefix}. Разработчикам так бывает очень удобно поскольку
позволяет просто запускать `make' и тестировать результаты изменения без
необходимости запускать `make install'.

\hypertarget{ux43eux447ux438ux441ux442ux43aux430-ux434ux438ux440ux435ux43aux442ux43eux440ux438ux44f-ux441ux431ux43eux440ux43aux438}{%
\subsubsection{Очистка директория
сборки}\label{ux43eux447ux438ux441ux442ux43aux430-ux434ux438ux440ux435ux43aux442ux43eux440ux438ux44f-ux441ux431ux43eux440ux43aux438}}

Очистка дерева исходного кода позволяет избегать проблем связывания со
старыми файлами объектов, необновления объектов после изменения ABI.

Следующие команды обновляют локальный клон git:

\begin{verbatim}
$ git clean -xdf
$ git reset --hard origin/master
$ git pull
\end{verbatim}

Удаление предыдущих установок из системы выполняется следующими
командами:

\begin{verbatim}
$ ./configure --prefix=/usr/local
$ make purge
\end{verbatim}

\hypertarget{ux43aux43eux43cux43fux438ux43bux44fux446ux438ux44f-ux438-ux43fux435ux440ux435ux43dux43eux441ux438ux43cux43eux441ux442ux44c}{%
\subsection{Компиляция и
переносимость}\label{ux43aux43eux43cux43fux438ux43bux44fux446ux438ux44f-ux438-ux43fux435ux440ux435ux43dux43eux441ux438ux43cux43eux441ux442ux44c}}

В настоящее время ядро radare2 можно скомпилировать для многих
операционных систем и архитектур, но основная разработка ведется на
GNU/Linux с помощью GCC, на MacOS X с помощью clang. Radare также
компилируется на других системах и архитектурах, включая TCC и
SunStudio.

Разработчики часто используют radare в качестве отладчика при обратном
проектировании (реверс-инжениринге). Сейчас подсистему отладчика можно
использовать в Windows, GNU/Linux (Intel x86, x86\_64, MIPS и ARM), OS
X, FreeBSD, NetBSD и OpenBSD (Intel x86 и x86\_64).

По сравнению с ядром функция отладчика является ограниченно-переносимой.
Если отладчик еще не портирован на вашу любимую платформу, можно
отключить модуль отладки при помощи параметра --without-debugger скрипта
\texttt{configure} при компиляции Radare2.

Напомним, что в программной системе есть плагины ввода-вывода, которые
используют функции GDB, WinDbg или Wine, они полагаются на наличие
соответствующих инструментов (в случае удаленной отладки --- только на
целевой машине).

Чтобы собрать программную систему, используя \texttt{acr} и
\texttt{GNU\ Make}, например, в системах *BSD:

\begin{verbatim}
$ ./configure --prefix=/usr
$ gmake
$ sudo gmake install
\end{verbatim}

Существует и простой скрипт, собирающий проект автоматически:

\begin{verbatim}
$ sys/install.sh
\end{verbatim}

\hypertarget{ux441ux442ux430ux442ux438ux447ux435ux441ux43aux430ux44f-ux441ux431ux43eux440ux43aux430}{%
\subsubsection{Статическая
сборка}\label{ux441ux442ux430ux442ux438ux447ux435ux441ux43aux430ux44f-ux441ux431ux43eux440ux43aux430}}

Можно собрать radare2 статически вместе со всеми инструментами с помощью
команды:

\begin{verbatim}
$ sys/static.sh
\end{verbatim}

\hypertarget{ux441ux431ux43eux440ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson}{%
\subsubsection{Сборка при помощи
Meson}\label{ux441ux431ux43eux440ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson}}

Для сборки можно использовать meson + ninja:

\begin{verbatim}
$ sys/meson.py --prefix=/usr --shared --install
\end{verbatim}

Для локальной сборки:

\begin{verbatim}
$ sys/meson.py --prefix=/home/$USER/r2meson --local --shared --install
\end{verbatim}

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-ux432-docker}{%
\subsubsection{Установка в
Docker}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-ux432-docker}}

В репозитории исходного кода radare2 есть
\href{https://github.com/radareorg/radare2/blob/master/Dockerfile}{Dockerfile},
используемый с системой Docker.

Этот dockerfile также используется в дистрибутиве Remnux из SANS, а
также на сайте hub.docker.com,
\href{https://registry.hub.docker.com/u/remnux/radare2/}{registryhub}.

\hypertarget{ux434ux435ux438ux43dux441ux442ux430ux43bux43bux44fux446ux438ux44f-ux441ux442ux430ux440ux44bux445-ux443ux441ux442ux430ux43dux43eux432ux43eux43a-radare2}{%
\subsection{Деинсталляция старых установок
Radare2}\label{ux434ux435ux438ux43dux441ux442ux430ux43bux43bux44fux446ux438ux44f-ux441ux442ux430ux440ux44bux445-ux443ux441ux442ux430ux43dux43eux432ux43eux43a-radare2}}

\begin{verbatim}
./configure --prefix=/old/r2/prefix/installation
make purge
\end{verbatim}

\hypertarget{windows}{%
\subsection{Windows}\label{windows}}

Компилирование \texttt{г2} в Windows требует использования системы
сборки Meson. Вообще существует возможность сборки r2 в Windows с
использованием cygwin, mingw или wsl, используя в качестве системы
сборки acr/make, однако этот подход не является
рекомендуемым/официальным/поддерживаемым и может привести к неожиданным
результатам.

Готовые двоичные сборки загружаются со страницы релизов, кроме того,
можно использовать артефакты GITHUB CI, создаваемые на каждый коммит как
для 32-разрядной, так и 64-разрядной версий Windows.

\begin{itemize}
\tightlist
\item
  https://github.com/radareorg/radare2/releases
\end{itemize}

\hypertarget{ux43dux435ux43eux431ux445ux43eux434ux438ux43cux44bux435-ux440ux435ux441ux443ux440ux441ux44b-ux438-ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}{%
\subsubsection{Необходимые ресурсы и
инструменты}\label{ux43dux435ux43eux431ux445ux43eux434ux438ux43cux44bux435-ux440ux435ux441ux443ux440ux441ux44b-ux438-ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}}

\begin{itemize}
\tightlist
\item
  Требуется 3 ГБ свободного места на диске,
\item
  Visual Studio 2019 (or higher),
\item
  Python 3,
\item
  Meson,
\item
  Ninja,
\item
  Git.
\end{itemize}

\hypertarget{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux43eux441ux442ux44c-ux448ux430ux433ux43eux432}{%
\subsubsection{Последовательность
шагов}\label{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux43eux441ux442ux44c-ux448ux430ux433ux43eux432}}

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-visual-studio-2015-ux438ux43bux438-ux431ux43eux43bux435ux435-ux43fux43eux437ux434ux43dux435ux439-ux432ux435ux440ux441ux438ux438}{%
\paragraph{Установка Visual Studio 2015 или более поздней
версии}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-visual-studio-2015-ux438ux43bux438-ux431ux43eux43bux435ux435-ux43fux43eux437ux434ux43dux435ux439-ux432ux435ux440ux441ux438ux438}}

Visual Studio должна включать компилятор Visual C++, поддерживающий
библиотеки C++, и соответствующий пакет Windows SDK для целевой версии
платформы.

\begin{itemize}
\tightlist
\item
  Убедитесь, что задан
  \texttt{Programming\ Languages\ \textgreater{}\ Visual\ C++}
\end{itemize}

Если у вас не установлена Visual Studio, то грузите какую-нибудь версию
community-edition, эти версии бесплатны и отлично работают.

\begin{itemize}
\tightlist
\item
  \href{https://visualstudio.microsoft.com/downloads/}{Загрузка Visual
  Studio 2019}
\end{itemize}

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-python-3-ux438-meson-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-ux43fux430ux43aux435ux442ux43dux43eux433ux43e-ux43cux435ux43dux435ux434ux436ux435ux440ux430-conda}{%
\paragraph{Установка Python 3 и Meson при помощи пакетного менеджера
Conda}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-python-3-ux438-meson-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-ux43fux430ux43aux435ux442ux43dux43eux433ux43e-ux43cux435ux43dux435ux434ux436ux435ux440ux430-conda}}

Conda - это, вероятно, лучший дистрибутив Python для Windows. Пропустите
следующие шаги, если у вас уже установлен Python

\begin{itemize}
\tightlist
\item
  https://docs.conda.io/en/latest/miniconda.html
\item
  https://repo.anaconda.com/archive/
\end{itemize}

\hypertarget{ux441ux43eux437ux434ux430ux43dux438ux435-ux441ux440ux435ux434ux44b-environment-python-ux434ux43bux44f-radare2}{%
\subparagraph{Создание среды (environment) Python для
Radare2}\label{ux441ux43eux437ux434ux430ux43dux438ux435-ux441ux440ux435ux434ux44b-environment-python-ux434ux43bux44f-radare2}}

Следующие действия создают и активируют среду Conda с именем \emph{r2}.
Все дальнейшие инструкции приводятся в предположении, что имя среды
\texttt{r2}, при желании имя можно изменить.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Пуск \textgreater{} Anaconda Prompt
\item
  \texttt{conda\ create\ -n\ r2\ python=3}
\item
  \texttt{activate\ r2}
\end{enumerate}

Всякий раз, когда вы входите в среду, открыв Anaconda Prompt, надо
запускать \texttt{activate\ r2}. И наоборот, запуск \texttt{deactivate}
отключает от среды.

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-meson}{%
\subparagraph{Установка
Meson}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-meson}}

Убедитесь, что установлен Meson версии 0.48 или выше
(\texttt{meson\ -v})

\begin{verbatim}
pip install meson
\end{verbatim}

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-git-for-windows}{%
\paragraph{Установка Git for
Windows}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-git-for-windows}}

Разработка Radare2 ведется в системе управления версиями Git, исходный
код \href{https://github.com/radareorg}{опубликован на GitHub}.

Установка Git для Windows требует выполнения следующих действий.

Загрузка Windows-версии Git

\begin{itemize}
\tightlist
\item
  https://git-scm.com/download/win
\end{itemize}

Во время установки проверьте следующие параметры.

\begin{itemize}
\tightlist
\item
  Использовать шрифт TrueType во всех окнах консоли,
\item
  Использовать Git из командной строки Windows,
\item
  Использовать библиотеку Windows Secure Channel, вместо OpenSSL,
\item
  Установить флаг Windows-style, коммит - Unix-style для кодирования
  концов строк(core.autocrlf=true),
\item
  Использовать окно консоли Windows по умолчанию, вместо Mintty,
\item
  Убедитесь, что \texttt{git\ -\/-version} срабатывает после
  инсталляции.
\end{itemize}

\hypertarget{ux437ux430ux433ux440ux443ux437ux43aux430-ux438ux441ux445ux43eux434ux43dux43eux433ux43e-ux43aux43eux434ux430-radare2}{%
\paragraph{Загрузка исходного кода
Radare2}\label{ux437ux430ux433ux440ux443ux437ux43aux430-ux438ux441ux445ux43eux434ux43dux43eux433ux43e-ux43aux43eux434ux430-radare2}}

Следующие действия приводят к клонированию git-репозитория Radare2.

\begin{verbatim}
git clone https://github.com/radareorg/radare2
\end{verbatim}

\hypertarget{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-radare2-code}{%
\paragraph{Компилирование Radare2
Code}\label{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-radare2-code}}

Следующие действия - компиляция кода Radare2.

\begin{itemize}
\item
  \textbf{Visual Studio 2017:}

  Замечание 1: Замените \texttt{Community} на \texttt{Professional} или
  \texttt{Enterprise} в следующем примере командной строки в зависимости
  от используемой вами версии.

  Замечание 2: Замените \texttt{vcvars32.bat} на \texttt{vcvars64.bat} в
  этой строке для сборки 64-битовой версии.

  \texttt{"\%ProgramFiles(x86)\%\textbackslash{}Microsoft\ Visual\ Studio\textbackslash{}2017\textbackslash{}Community\textbackslash{}VC\textbackslash{}Auxiliary\textbackslash{}Build\textbackslash{}vcvars32.bat"}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Создание системы сборки с помощью Meson:
\end{enumerate}

В командной строке Meson можно задавать аргументы для настройки типа
сборки. Однако, r2 должен собраться без дополнительных флагов meson-а.
При использовании Visual Studio. Замечание: Замените \texttt{Debug} на
\texttt{Release} в следующей строке в зависимости от намерения собрать
версию для отладки или релиз.

\begin{verbatim}
meson b --buildtype debug --backend vs2019 --prefix %cd%\dest
msbuild build\radare2.sln /p:Configuration=Debug /m
\end{verbatim}

При использовании Ninja интерфейс Visual Studio не требуется, достаточно
установить инструменты компилятора msvc:

\begin{verbatim}
meson b
ninja -C b
\end{verbatim}

Наконец, надо запустить следующую строку для установки r2 в заданный
каталог (абсолютный префикс):

\begin{verbatim}
meson install -C build --no-rebuild
\end{verbatim}

\hypertarget{ux437ux430ux43cux435ux442ux43aux438-ux43e-ux43fux430ux440ux430ux43cux435ux442ux440ux430ux445-ux441ux431ux43eux440ux43aux438}{%
\paragraph{Заметки о параметрах
сборки}\label{ux437ux430ux43cux435ux442ux43aux438-ux43e-ux43fux430ux440ux430ux43cux435ux442ux440ux430ux445-ux441ux431ux43eux440ux43aux438}}

Параметр \texttt{/m{[}axcpucount{]}} создает один рабочий процесс
MSBuild для каждого процессорного ядра компьютера. Указание числового
значения (например, \texttt{/m:2}) ограничивает количество рабочих
процессов. (Не следует путать с параметром компилятора Visual C++
\texttt{/MP}.)

Иногда при попытке 32-разрядной установки можно получить сообщение
такого вида:
\texttt{error\ MSB4126:\ The\ specified\ solution\ configuration\ "Debug\textbar{}x86"\ is\ invalid.}
Проблема решается добавлением следующего аргумента:
\texttt{/p:Platform=Win32}.

Проверить версию собранного Radare2:
\texttt{dest\textbackslash{}bin\textbackslash{}radare2.exe\ -v}

\hypertarget{ux43aux430ux43a-ux443ux431ux435ux434ux438ux442ux441ux44f-ux447ux442ux43e-radare2-ux437ux430ux43fux443ux441ux43aux430ux435ux442ux441ux44f-ux438ux437-ux43bux44eux431ux43eux439-ux43fux430ux43fux43aux438}{%
\paragraph{Как убедится, что Radare2 запускается из любой
папки}\label{ux43aux430ux43a-ux443ux431ux435ux434ux438ux442ux441ux44f-ux447ux442ux43e-radare2-ux437ux430ux43fux443ux441ux43aux430ux435ux442ux441ux44f-ux438ux437-ux43bux44eux431ux43eux439-ux43fux430ux43fux43aux438}}

В системах UNIX \texttt{r2} --- это просто символьная ссылка на
исполняемый файл \texttt{radare2}. В Windows если вы хотите, чтобы у вас
был именно \texttt{r2}, то надо просто скопировать в него
\texttt{radare2.exe}: \texttt{copy\ radare2.exe\ r2.exe}. Также надо
добавить каталог с этими файлами в переменную PATH в настройках
\textbf{Проводника} Windows.

Откройте консоль \texttt{cmd.exe} и наберите \texttt{r2\ -v}. Если не
получите ошибку, то весь процесс сборки и установки прошел успешно.

\hypertarget{ux43fux440ux438ux43cux435ux447ux430ux43dux438ux44f-ux43fux43e-ux43dux430ux441ux442ux440ux43eux439ux43aux435-ux43eux431ux449ux435ux441ux438ux441ux442ux435ux43cux43dux44bux445-system-wide-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux445-ux441ux440ux435ux434ux44b}{%
\paragraph{Примечания по настройке общесистемных (system-wide)
переменных
среды}\label{ux43fux440ux438ux43cux435ux447ux430ux43dux438ux44f-ux43fux43e-ux43dux430ux441ux442ux440ux43eux439ux43aux435-ux43eux431ux449ux435ux441ux438ux441ux442ux435ux43cux43dux44bux445-system-wide-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux445-ux441ux440ux435ux434ux44b}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  В проводнике windows перейдите в папку Radare2, т.е., в которую только
  что мы устанавливали пакет.
\item
  Из этой папки перейдите в \texttt{dest} \textgreater{} \texttt{bin} и
  оставьте окно открытым.
\item
  Перейдите в раздел ``Свойства системы'' (System Properties): в строке
  поиска Windows введите \texttt{sysdm.cpl}.
\item
  Перейдите в \texttt{Дополнительно\ \textgreater{}\ Переменные\ среды}
  (\texttt{Advanced\ \textgreater{}\ Environment\ Variables}).
\item
  Щелкните на переменной PATH, затем нажмите кнопку edit. Если PATH
  присутствует в настройках и для пользователя, и среди перечня
  системных переменных, то лучше править пользовательскую.
\item
  Проверьте наличие в переменной PATH пути к папке в оставленном ранее
  окне. Если это не так, добавьте эту папку и нажмите \texttt{OK}.
\item
  Выйдите из сеанса Windows.
\item
  Откройте командную строку Windows: введите \texttt{cmd} в строке
  поиска. Убедитесь, что текущая папка не папка Radare2.
\item
  Проверьте работоспособность Radare2 в командной строке:
  \texttt{radare2\ -v}.
\end{enumerate}

\hypertarget{android}{%
\subsection{Android}\label{android}}

Программа Radare2 также может быть кросс-компилирована для других
архитектур и операционных систем, например в Android.

\hypertarget{ux43dux435ux43eux431ux445ux43eux434ux438ux43cux44bux435-ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}{%
\subsubsection{Необходимые
инструменты}\label{ux43dux435ux43eux431ux445ux43eux434ux438ux43cux44bux435-ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}}

\begin{itemize}
\tightlist
\item
  Python 3,
\item
  Meson,
\item
  Ninja,
\item
  Git,
\item
  Android NDK.
\end{itemize}

\hypertarget{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux43eux441ux442ux44c-ux448ux430ux433ux43eux432-1}{%
\subsubsection{Последовательность
шагов}\label{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux43eux441ux442ux44c-ux448ux430ux433ux43eux432-1}}

\hypertarget{ux437ux430ux433ux440ux443ux437ux43aux430-ux438-ux440ux430ux441ux43fux430ux43aux43eux432ux43aux430-android-ndk}{%
\paragraph{Загрузка и распаковка Android
NDK}\label{ux437ux430ux433ux440ux443ux437ux43aux430-ux438-ux440ux430ux441ux43fux430ux43aux43eux432ux43aux430-android-ndk}}

Загрузите Android NDK с
\href{https://developer.android.com/ndk}{официального сайта} и
распакуйте его где-нибудь у вас в системе, например в директории
\texttt{/tmp/android-ndk}.

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-make}{%
\paragraph{Использование
Make}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-make}}

\hypertarget{ux443ux43aux430ux437ux430ux43dux438ux435-ux43cux435ux441ux442ux43eux440ux430ux441ux43fux43eux43bux43eux436ux435ux43dux438ux435-ndk}{%
\subparagraph{Указание месторасположение
NDK}\label{ux443ux43aux430ux437ux430ux43dux438ux435-ux43cux435ux441ux442ux43eux440ux430ux441ux43fux43eux43bux43eux436ux435ux43dux438ux435-ndk}}

\begin{verbatim}
$ echo NDK=/tmp/android-ndk  > ~/.r2androidrc
\end{verbatim}

\hypertarget{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-ux438-ux441ux43eux437ux434ux430ux43dux438ux435-ux430ux440ux445ux438ux432ux430-tar.gz-ux437ux430ux433ux440ux443ux437ux43aux430-ux432-ux43fux43eux434ux43aux43bux44eux447ux435ux43dux43dux43eux435-ux443ux441ux442ux440ux43eux439ux441ux442ux432ux43e-android}{%
\subparagraph{Компилирование и создание архива tar.gz, загрузка в
подключенное устройство
android}\label{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-ux438-ux441ux43eux437ux434ux430ux43dux438ux435-ux430ux440ux445ux438ux432ux430-tar.gz-ux437ux430ux433ux440ux443ux437ux43aux430-ux432-ux43fux43eux434ux43aux43bux44eux447ux435ux43dux43dux43eux435-ux443ux441ux442ux440ux43eux439ux441ux442ux432ux43e-android}}

\begin{verbatim}
./sys/android-build.sh arm64-static
\end{verbatim}

Можно собрать пакет для какой-либо другой архитектуры, изменив аргумент
на \texttt{./sys/android-build.sh}. Запустить скрипт без аргументов, он
покажет использованные значения.

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-meson}{%
\paragraph{Использование
Meson}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-meson}}

\hypertarget{ux441ux43eux437ux434ux430ux43dux438ux435-ux43aux440ux43eux441ux441-ux444ux430ux439ux43b-ux434ux43bux44f-ux43cux435ux437ux43eux43dux430}{%
\subparagraph{Создание кросс-файл для
мезона}\label{ux441ux43eux437ux434ux430ux43dux438ux435-ux43aux440ux43eux441ux441-ux444ux430ux439ux43b-ux434ux43bux44f-ux43cux435ux437ux43eux43dux430}}

Meson-у нужен конфигурационный файл, описывающий среду кросс-компиляции,
например, \texttt{meson-android.ini}. Его можно донастроить при
необходимости. Следующий пример - хорошая отправная точка:

\begin{verbatim}
[binaries]
c       = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang'
cpp     = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android28-clang++'
ar      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ar'
as      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-as'
ranlib  = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ranlib'
ld      = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-ld'
strip   = '/tmp/android-ndk/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-strip'
pkgconfig = 'false'

[properties]
sys_root = '/tmp/android-ndk/sysroot'

[host_machine]
system = 'android'
cpu_family = 'arm'
cpu = 'aarch64'
endian = 'little'
\end{verbatim}

\hypertarget{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson-ninja}{%
\subparagraph{Компилирование при помощи meson +
ninja}\label{ux43aux43eux43cux43fux438ux43bux438ux440ux43eux432ux430ux43dux438ux435-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-meson-ninja}}

Настроить каталог сборки с meson-ом, как обычно:

\begin{verbatim}
$ CFLAGS="-static" LDFLAGS="-static" meson --default-library static --prefix=/tmp/android-dir -Dblob=true build --cross-file ./meson-android.ini
\end{verbatim}

Поясним значения всех перечисленных выше переменных: *
\texttt{CFLAGS="-static"}, \texttt{LDFLAGS="-static"},
\texttt{-\/-default-library\ static} обеспечивает компилирование
библиотек и запускаемых файлов в статическом режиме, теперь нет
необходимости указывать значения переменных LD\_* в вашей среде
Android-а. Переменные указывают, где находятся подходящие библиотеки. В
статическом режиме они не нужны. У двоичных (запускаемых) файлов есть
все, что им нужно внутри. * \texttt{-Dblob=true} указывает meson-у
компилировать только один единый запускаемый файл со всем требуемым
кодом для всех программ \texttt{radare2}, \texttt{rabin2},
\texttt{rasm2}, и т.д. В результате для каждой программы будет создана
символьная ссылка на этот единый файл. Это позволяет избежать создания
множества больших статически скомпилированных двоичных файлов, а просто
создается один единый, включающий все функции. Мы получим наши
\texttt{rabin2}, \texttt{rasm2}, \texttt{rax2}, и др., но они будут
только ссылками на \texttt{radare2}. *
\texttt{-\/-cross-file\ ./meson-android.ini} описывает процесс
компилирования radare2 для ОС Android

Затем, надо скомпилировать проект, и установить его на устройство:

\begin{verbatim}
$ ninja -C build
$ ninja -C build install
\end{verbatim}

\hypertarget{ux43aux43eux43fux438ux440ux43eux432ux430ux43dux438ux435-ux444ux430ux439ux43bux43eux432-ux43dux430-ux441ux432ux43eux435-ux443ux441ux442ux440ux43eux439ux441ux442ux432ux43e-android-ux437ux430ux43fux443ux441ux43a-ux43fux440ux438ux43bux43eux436ux435ux43dux438ux44f}{%
\subparagraph{Копирование файлов на свое устройство Android, запуск
приложения}\label{ux43aux43eux43fux438ux440ux43eux432ux430ux43dux438ux435-ux444ux430ux439ux43bux43eux432-ux43dux430-ux441ux432ux43eux435-ux443ux441ux442ux440ux43eux439ux441ux442ux432ux43e-android-ux437ux430ux43fux443ux441ux43a-ux43fux440ux438ux43bux43eux436ux435ux43dux438ux44f}}

Последний этап - копирование сгенерированных файлов в /tmp/android-dir
на ваше Android-устройство, запуск на нем radare2:

\begin{verbatim}
$ cd /tmp && tar -cvf radare2-android.tar.gz android-dir
$ adb push radare2-android.tar.gz /data/local/tmp
$ adb shell
DEVICE:/ $ cd /data/local/tmp
DEVICE:/data/local/tmp $ tar xvf radare2-android.tar.gz
DEVICE:/data/local/tmp $ ./android-dir/bin/radare2
Usage: r2 [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
\end{verbatim}

\hypertarget{ux438ux43dux442ux435ux440ux444ux435ux439ux441ux44b-ux43fux43eux43bux44cux437ux43eux432ux430ux442ux435ux43bux44f}{%
\section{Интерфейсы
пользователя}\label{ux438ux43dux442ux435ux440ux444ux435ux439ux441ux44b-ux43fux43eux43bux44cux437ux43eux432ux430ux442ux435ux43bux44f}}

Для Radare2 на протяжении многих лет разработано много различных
пользовательских интерфейсов.

Идея графического интерфейса далеко от использованной идеологии
основного механизма инструментария обратного проектирования:
предпочтительно иметь отдельный проект и сообщество, позволяющее обоим
проектам сотрудничать и совершенствоваться вместе, вместо того, чтобы
заставлять разработчиков интерфейса командной строки думать о проблемах
графического интерфейса и прыгать взад-вперед между графическим аспектом
и низкоуровневой логикой реализаций.

В прошлом было, по крайней мере, пять различных пользовательских
интерфейсов (ragui, r2gui, gradare, r2net, bokken), но ни один из них не
получил достаточной поддержки, чтобы набрать достаточную популярность, в
результате и все они ``сложили ласты''.

Программа r2 снабжена встроенным веб-сервером и предоставляет несколько
простых пользовательских интерфейсов, реализованных при помощи HTML/JS.
Данный режим запускается следующим образом:

\begin{verbatim}
$ r2 -c=H /bin/ls
\end{verbatim}

После трех лет самостоятельной разработки Уго Тесо, автор проекта Bokken
(python-gtk-итерфейс для r2), выпустил для общественности еще один
интерфейс для r2, но на этот раз написанный на c++ и qt, что очень
понравилось сообществу.

Разработанный графический интерфейс назван Iaito, однако Уго несколько
лениво поддерживал проект, что привело и созданию на основе Iaito нового
проекта под именем Cutter (так проголосовало сообщество), возглавил
проект пользователь Xarkes. Вот как он выглядит:

\begin{itemize}
\tightlist
\item
  \url{https://github.com/radareorg/cutter}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{Cutter.png}
\caption{Cutter}
\end{figure}

\hypertarget{ux431ux430ux437ux43eux432ux43eux435-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-radare2}{%
\subsection{Базовое использование
Radare2}\label{ux431ux430ux437ux43eux432ux43eux435-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-radare2}}

Кривая обучения обычно пологая только в самом начале. После часа
использования уже можно легко понять, как работает большинство функций,
и как можно комбинировать различные инструменты радара. Вам предлагается
прочитать оставшуюся часть этой книги, чтобы понять, как работают
некоторые нетривиальные вещи, и в конечном итоге улучшить свои навыки.

\begin{figure}
\centering
\includegraphics{learning_curve.png}
\caption{learning\_curve}
\end{figure}

Перемещение по адресам, исследование и правка загруженного двоичного
файла выполняются при помощи трех простых действий: перемещение по
адресному пространству (в некоторый адрес), отображение (буфера) и
внесение изменений (запись, добавление).

Команда «seek» обозначается аббревиатурой \texttt{s}, она принимает
выражение в качестве аргумента. Выражение может быть следующего вида -
\texttt{10}, \texttt{+0x25}, или даже \texttt{{[}0x100+ptr\_table{]}}.
Если вы хотите работать с блочными файлами, вы можете зафиксировать
размер блока с помощью команды \texttt{b} и осуществлять перемещение по
памяти вперед или назад по адресам байтов. Использование \texttt{s++} и
\texttt{s-\/-} аналогично позволяет перемещаться по памяти.

Если в radare2 открыть исполняемый файл, то по умолчанию он откроется в
режиме виртуальной адресации (VA), и секции файла будут отображены в их
виртуальные адреса. В режиме VA основа перемещения по адресам - этот
виртуальный адрес, а начальная позиция устанавливается в точку входа
исполняемого файла. Использование ключа \texttt{-n} позволяет отменить
загрузку в данном режиме, при этом radare2 откроет файл в не-VA режиме.
В режиме не-VA перемещение по адресам осуществляется относительно начала
файла.

Команда `print' также имеет сокращенный вариант \texttt{p} и включает
несколько вариантов функционирования, вторая буква указывает как раз
требуемый режим отображения. Наиболее часто встречаются \texttt{px},
отображающий данные в виде шестнадцатеричного дампа, \texttt{pd} -
дизассемблирование кода.

Чтобы radare2 мог сохранять изменения в исследуемых файлах, надо указать
флаг \texttt{-w} в командной строке при открытии файла. Команда
\texttt{w} используется для записи строк в исходный файл,
шестнадцатеричных кодов (режим \texttt{x}) или даже ассемблерные коды
операций (режим \texttt{a}). Примеры:

\begin{verbatim}
> w hello world         ; строка
> wx 90 90 90 90        ; шеснадцатеричные данные
> wa jmp 0x8048140      ; ассемблирование
> wf inline.bin         ; запись содержимого из файла
\end{verbatim}

Добавление символа \texttt{?} к любой команде показывает подсказку,
например, \texttt{p?}. Если написать \texttt{?*}, то получим список
команд, начинающихся с заданной строки, например, \texttt{p?*}.

Визуальный режим запускается вводом
\texttt{V\textless{}enter\textgreater{}}. По клавише \texttt{q} можно
выйти из этого режима и вернуться в привычный режим командной строки.

В визуальном режиме для перемещений используются клавиши HJKL (влево,
вниз, вверх и вправо, соответственно). Также можно использовать эти
клавиши в режиме курсора, режим переключается клавшей \texttt{c}. Чтобы
выбрать диапазон байтов в режиме курсора, одновременно нажмите
\texttt{Shift} и клавиши навигации HJKL, в результате radare2 выделит
область.

В визуальном режиме также можно переписывать байты, нажав \texttt{i}.
Нажатием клавиши \texttt{TAB} осуществляется перемещение между панелями
шестнадцатеричных кодов (посередине) и строчным представлением (справа).
Нажатие \texttt{q} в панели шестнадцатеричного представления приводит к
возвращению в визуальный режим. Нажатием \texttt{p} или \texttt{P}
приводит к циклическому переключению различных режимов визуального
представления. Существует второй по важности визуальный режим ---
интерфейс панелей, похожий на curses, доступный при помощи комбинации
\texttt{V!}.

\hypertarget{ux430ux440ux433ux443ux43cux435ux43dux442ux44b-ux43aux43eux43cux430ux43dux434ux43dux43eux439-ux441ux442ux440ux43eux43aux438}{%
\subsection{Аргументы командной
строки}\label{ux430ux440ux433ux443ux43cux435ux43dux442ux44b-ux43aux43eux43cux430ux43dux434ux43dux43eux439-ux441ux442ux440ux43eux43aux438}}

Ядро Radare управляется множеством флагов, аргументов командной строки.

Вот кусочек сообщения справки по использованию флагов:

\begin{verbatim}
$ radare2 -h
Usage: r2 [-ACdfLMnNqStuvwzX] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]
          [-s addr] [-B baddr] [-m maddr] [-c cmd] [-e k=v] file|pid|-|--|=
 --           запустить radare2 без открытия файла
 -            тоже, что 'r2 malloc://512'
 =            читать файл со стандартного ввода (используйте -i и -c для выполнения команд)
 -=           флаг !=! позволяет удаленно запускать команды
 -0           напечатать \x00 перед первой и после каждой команды
 -2           закрыть файловый дескриптор stderr (тихий режим без вывода сообщений)
 -a [arch]    установить asm.arch
 -A           запуск команды 'aaa' анализа ссылок в коде
 -b [bits]    задать asm.bits
 -B [baddr]   задать базовый адрес для PIE-бинариков
 -c 'cmd..'   запуск команды radare
 -C           отобразить в файл host:port (alias for -c+=http://%s/cmd/)
 -d           отлаживать запускаемый 'file' или процесс по 'pid'
 -D [backend] установить режим отладки (e cfg.debug=true)
 -e k=v       вычислить переменную конфигурации
 -f           размер блока приравнять к размеру файла
 -F [binplug] использовать известный всем плагин rbin насильно
 -h, -hh      показать сообщение о флагах и их предназначении, -hh - подробнее
 -H ([var])   напечатать переменную
 -i [file]    запустить файл-сценарий
 -I [file]    запустить файл-сценарий ПЕРЕД открытием основного файла
 -k [OS/kern] задать asm.os (linux, macos, w32, netbsd, ...)
 -l [lib]     загрузить плагин из файла
 -L           перечислить поддерживаемые плагины ввода-вывода
\end{verbatim}

\begin{verbatim}
 -m [addr]    отобразить файл по указанному адресу (loadaddr)
 -M           не чудить с именами символов
 -n, -nn      не загружать информацию RBin (-nn загружает только двоичные структуры)
 -N           не загружать установки и сценарии пользователя
 -q           тихий режим без командной строки, выйти после исполнения -i
 -Q           тихий режим без командной строки, быстро затем выйти (quickLeak=true)
 -p [prj]     использовать проект, список, если не задан аргумент, загрузить, если не указан основной файл
 -P [file]    применить rapatch-файл и выйти
 -r [rarun2]  указать профиль rarun2 для загрузки (то же самое, что -e dbg.profile=X)
 -R [rr2rule] указать дополнительную директиву rarun2
 -s [addr]    начальный адрес смещения (seek)
 -S           запуск r2 в режиме "песочницы"
 -t           загрузить информацию rabin2 в "thread"
 -u           задать bin.filter=false для получения "грубых" имен sym/sec/cls
 -v, -V       показать версию radare2 (-V показывает версии библиотек)
 -w           открыть файл в режиме перезаписи
 -x           открыть без флага exec (asm.emu не будет работать), смотри io.exec
 -X           то же самое, что -e bin.usextr=false (используется в dyldcache)
 -z, -zz      не загружать строки, или загружать их в грубом формате
\end{verbatim}

\hypertarget{ux447ux430ux441ux442ux44bux435-ux432ux430ux440ux438ux430ux43dux442ux44b-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f}{%
\subsubsection{Частые варианты
использования}\label{ux447ux430ux441ux442ux44bux435-ux432ux430ux440ux438ux430ux43dux442ux44b-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f}}

Открыть файл в режиме записи без анализа формата его заголовков.

\begin{verbatim}
$ r2 -nw file
\end{verbatim}

Войти в оболочку r2, не открывая ни одного файла.

\begin{verbatim}
$ r2 -
\end{verbatim}

Указать конкретный суббинарный файл в открываемом fatbin-файле:

\begin{verbatim}
$ r2 -a ppc -b 32 ls.fat
\end{verbatim}

Запустить сценарий перед переходом в основную командную строку:

\begin{verbatim}
$ r2 -i patch.r2 target.bin
\end{verbatim}

Выполнить команду и выйти, не входя в интерактивный режим:

\begin{verbatim}
$ r2 -qc ij hi.bin > imports.json
\end{verbatim}

Установка значения переменной конфигурации:

\begin{verbatim}
$ r2 -e scr.color=0 blah.bin
\end{verbatim}

Отладить программу:

\begin{verbatim}
$ r2 -d ls
\end{verbatim}

Использовать существующий файл проекта:

\begin{verbatim}
$ r2 -p test
\end{verbatim}

\hypertarget{ux444ux43eux440ux43cux430ux442-ux43aux43eux43cux430ux43dux434ux44b}{%
\subsection{Формат
команды}\label{ux444ux43eux440ux43cux430ux442-ux43aux43eux43cux430ux43dux434ux44b}}

Общий формат команд radiuse2 выглядит следующим образом:

\begin{verbatim}
[.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ;
\end{verbatim}

Программисты, часто использующие Vim и знакомые с его командами,
чувствуют теперь себя как дома. Этот формат используется на протяжении
всей книги. Команды обозначаются одним символом {[}a-zA-Z{]}, регистр
учитывается.

Чтобы выполнить команду несколько раз, надо добавить к ней префикс с
номером:

\begin{verbatim}
px    # выполнить px
3px   # выполнить px три раза
\end{verbatim}

Префикс \texttt{!} используется для выполнения команды в оболочке
операционной системы. If you want to use the cmd callback from the I/O
plugin you must prefix with \texttt{=!}.

Обратите внимание, что один восклицательный знак запускает команду и
распечатывает вывод через API RCons. Выполнение будет с блокировкой
radare, интерактивный режим не будет работать. Двойные восклицательные
знаки \texttt{!!} служат для запуска стандартных системных вызовов.

Все сокетные, файловые и исполнительные API можно контролировать
(ограничивать) с помощью переменной конфигурации \texttt{cfg.sandbox}.

Примеры:

\begin{verbatim}
ds                    ; вызоа команды отладчика 'step'
px 200 @ esp          ; показать 200 байт по адресу в регистре esp
pc > file.c           ; выдать в файл file.c буфер в виде массива байтов на языке C
wx 90 @@ sym.*        ; записать инструкцию nop по адресу каждого символа
pd 2000 | grep eax    ; отфильтровать grep-ом коды инструкций, использующие регистр 'eax'
px 20 ; pd 3 ; px 40  ; несколько команд в одной строке
\end{verbatim}

Стандартный канал UNIX \texttt{\textbar{}} также доступен в программе
radare2. Он используется для фильтрации вывода команд r2 внешней
программой, способной считывать со стандартного ввода, например,
\texttt{grep}, \texttt{less}, \texttt{wc}. Если нет необходимости
создавать лишние процессы, или это по какой-то причине невозможно, или
же в оперативной системе нет необходимых вам инструментов UNIX
(например, вы в Windows или используете встроенное приложение), вам
доступен встроенный grep (\texttt{\textasciitilde{}}).

Используйте \texttt{\textasciitilde{}?} для детальной документации
команды.

Команда-фильтр \texttt{\textasciitilde{}} подобно grep используется для
фильтрации вывода любой другой команды:

\begin{verbatim}
pd 20~call            ; дизассемблировать 20 инструкций, и отфильтровать grep-ом строки с 'call'
\end{verbatim}

Кроме того, можно получать grep-ом строки и столбцы по номерам:

\begin{verbatim}
pd 20~call:0          ; первая строка
pd 20~call:1          ; вторая строка
pd 20~call[0]         ; первая колонка
pd 20~call[1]         ; вторая колонка
\end{verbatim}

Или даже комбинировать такие запросы:

\begin{verbatim}
pd 20~call:0[0]       ; отфильтровать grep-ом первую колонку первой строки, где встречается 'call'
\end{verbatim}

Внутренняя функция grep является ключевой при создании сценариев
radare2, она может использоваться для организации перебора списка
смещений или данных, сгенерированных дизассемблером, диапазонов, или
вывода других команд. Узнать об этом больше можно, изучив раздел
\href{../scripting/loops.md}{Итераторы}.

Символ \texttt{@} используется для указания параметра - адреса смещения
для команды, которая записана в строке слева от него. После исполнения
команды в такой форме, исходный адрес восстанавливается.

Например, \texttt{pd\ 5\ @\ 0x100000fce} дизассемблирует пять инструкций
по адресу 0x100000fce.

Большинство команд поддерживают автодополнение по клавише
\texttt{\textless{}TAB\textgreater{}}, например, \texttt{s}eek или
\texttt{f}lags. Автодополнение позволяет просмотреть все возможные
варианты, в данном случае, имена флагов. Можно просмотреть историю
команд с помощью команды \texttt{!\textasciitilde{}...}, она в
визуальном режиме прокручивает список выполненных ранее команд radare2.

Также можно расширить объем предлагаемых в автодополнении вариантов до
обработки большего из количества, а также включить автодополнение для
ваших собственных команд, определенных в ядре, плагинах ввода-вывода.
Вот эта команда - \texttt{!!!}.

\hypertarget{ux432ux44bux440ux430ux436ux435ux43dux438ux44f}{%
\subsection{Выражения}\label{ux432ux44bux440ux430ux436ux435ux43dux438ux44f}}

Выражение --- это математическое представление 64-битных числовых
значений. Результаты выражений отображаются в разных форматах,
сравниваются и могут быть использованы со всеми командами, принимающими
числовые аргументы. Выражения используют традиционные арифметические
операции, а также двоичные и логические значения. Чтобы вычислить
математическое выражение в команде, надо добавить к ней \texttt{?}:

\begin{verbatim}
[0xb7f9d810]> ?vi 0x8048000
134512640
[0xv7f9d810]> ?vi 0x8048000+34
134512674
[0xb7f9d810]> ?vi 0x8048000+0x34
134512692
[0xb7f9d810]> ? 1+2+3-4*3
hex     0xfffffffffffffffa
octal   01777777777777777777772
unit    17179869184.0G
segment fffff000:0ffa
int64   -6
string  "\xfa\xff\xff\xff\xff\xff\xff\xff"
binary  0b1111111111111111111111111111111111111111111111111111111111111010
fvalue: -6.0
float:  nanf
double: nan
trits   0t11112220022122120101211020120210210211201
\end{verbatim}

Поддерживаемые арифметические операции:

\begin{itemize}
\tightlist
\item
  + : сумма
\item
  - : вычитание
\item
  * : умножение
\item
  / : деление
\item
  \% : остаток от деления по модулю
\item
  \textgreater\textgreater{} : сдвиг вправо
\item
  \textless\textless{} : сдвиг влево
\end{itemize}

\begin{verbatim}
[0x00000000]> ?vi 1+2+3
6
\end{verbatim}

При использовании двоичного ИЛИ, всю команду следует заключать в
кавычки, иначе выполнится связывание потоков \texttt{\textbar{}}:

\begin{verbatim}
[0x00000000]> "? 1 | 2"
hex     0x3
octal   03
unit    3
segment 0000:0003
int32   3
string  "\x03"
binary  0b00000011
fvalue: 2.0
float:  0.000000f
double: 0.000000
trits   0t10
\end{verbatim}

Числа могут отображаться в одном из следующих форматов:

\begin{verbatim}
0x033   : шеснадцатеричное число просто отображается
3334    : десятичное
sym.fo  : преобразуется в смещение флага
10K     : килобайты (KBytes) 10*1024
10M     : мегабайты (MBytes) 10*1024*1024
\end{verbatim}

Также можно использовать переменные и адреса, включая текущее смещение,
при построении сложных выражений.

Последовательность символов \texttt{?\$?} выдает список всех доступных
команд. Можно также ознакомиться с кратким перечнем команд в конце
книги.

\begin{verbatim}
$$    here (текущий виртуальный адрес, смещение)
$l    длина кода инструкции (opcode length)
$s    размер файла
$j    адрес перехода (например, jmp 0x10, jz 0x10 => 0x10)
$f    адрес перехода, если ложь (например, jz 0x10 => адрес следующей инструкции)
$m    ссылка на адрес памяти, выраженна кодом инструкции (opcode) (например, mov eax,[0x10] => 0x10)
$b    размер блока
\end{verbatim}

Еще несколько примеров:

\begin{verbatim}
[0x4A13B8C0]> ? $m + $l
140293837812900 0x7f98b45df4a4 03771426427372244 130658.0G 8b45d000:04a4 140293837812900 10100100 140293837812900.0 -0.000000
\end{verbatim}

\begin{verbatim}
[0x4A13B8C0]> pd 1 @ +$l
0x4A13B8C2   call 0x4a13c000
\end{verbatim}

\hypertarget{ux43eux441ux43dux43eux432ux43dux44bux435-ux43aux43eux43cux430ux43dux434ux44b-ux43eux442ux43bux430ux434ux447ux438ux43aux430}{%
\section{Основные команды
отладчика}\label{ux43eux441ux43dux43eux432ux43dux44bux435-ux43aux43eux43cux430ux43dux434ux44b-ux43eux442ux43bux430ux434ux447ux438ux43aux430}}

Запуск радара в режиме отладки осуществляется при помощи флага
\texttt{-d} в командной строке операционной системы. Обычно производится
запуск новой программы, указывая ее имя и параметры, можно также и
присоединиться к выполняющемуся процессу, указав его PID.

\begin{verbatim}
$ pidof mc
32220
$ r2 -d 32220
$ r2 -d /bin/ls
$ r2 -a arm -b 16 -d gdb://192.168.1.43:9090
...
\end{verbatim}

Во втором случае отладчик создаст дочерний процесс и загрузит в него
программу \texttt{ls} для отладки.

Программа остановится в момент загрузки \texttt{ld.so} динамическим
компоновщиком. В этот момент точка входа еще не будет видна и
разделяемые библиотеки тоже.

Переопределить такое функционирование можно, задав другой адрес для
останова - адрес точки входа по ее имени. Делается это добавлением
команды радара \texttt{e\ dbg.bep=entry} или \texttt{e\ dbg.bep=main} в
ваш startup-сценарий, обычно он находится в файле
\texttt{\textasciitilde{}/.config/radare2/radare2rc}.

Другой способ - запустить продолжения исполнения до определенного адреса
- команда \texttt{dcu}. Команда означает «отладку продолжать до тех пор,
пока» (debug continue until) не будет достигнут адрес, где нужно
остановить исполнение. Например:

\begin{verbatim}
dcu main
\end{verbatim}

Имейте в виду, что определенные вредоносные или другие замороченные
программы могут выполнять некоторый код до запуска \texttt{main()}, что
не даст возможности контролировать вам исполнение этого кода. (Также и
конструкторы программ и TLS-инициализации)

Ниже приведен список наиболее распространенных команд, используемых с
отладчиком:

\begin{verbatim}
> d?            ; показать подсказку по командам отладчика
> ds 3          ; сделать три шага (step)
> db 0x8048920  ; установить точку останова (set breakpoint)
> db -0x8048920 ; удаление точки останова
> dc            ; продолжить исполнение процесса (continue)
> dcs           ; продолжить исполнение до запуска системного вызова (continue until syscall)
> dd            ; проводить манипуляции с файловыми дескрипторами
> dm            ; показать карты процесса (show process maps)
> dmp A S rwx   ; поменять ограничения для страницы по адресу A размером S
> dr eax=33     ; присвоить значение регистру (set register value). eax = 33
\end{verbatim}

Есть еще один вариант отладки в радаре, который проще - использование
визуального режима.

При его использовании не нужно ни запоминать команды, ни держать в уме
состояние программы.

Чтобы перейти в режим визуального отладчика, используйте \texttt{Vpp}:

\begin{verbatim}
[0xb7f0c8c0]> Vpp
\end{verbatim}

Начальное вид экрана в визуальном режиме представляет собой
шестнадцатеричный вид текущего счетчика отлаживаемой программы
(например, EIP для архитектуры x86). Нажатие \texttt{p} переключает
между разными представлениями в визуальном режиме. Можно нажимать
\texttt{p} и \texttt{P} для смены режимов различных вариантов
визуализации. Используйте F7 или \texttt{s}, чтобы войти внутрь функции
и F8 или \texttt{S} для перешагивания через текущую инструкцию. Ключ
\texttt{c} позволяет переключаться в режим курсора. В этом режиме можно
выделять диапазоны байтов, например, чтобы потом перезаписать их
nop-пами. Установка точки останова - клавиша \texttt{F2}.

В визуальном режиме можно вводить обычные команды радара, добавляя к ним
префикс \texttt{:}. Например, чтобы сбросить один блок содержимого
памяти по адресу в регистре ESI:

\begin{verbatim}
<Нажать ':'>
x @ esi
\end{verbatim}

Получение справки по визуальному режиму - клавиша \texttt{?}. Для
прокрутки экрана справки используются стрелки. Если надо выйти из режима
справки, используйте клавишу \texttt{q}.

Часто используемая команда - \texttt{dr}, она используется для чтения
или установки значений регистров общего назначения. Еще есть более
компактное представления значения регистра - команда \texttt{dr=}. Можно
манипулировать также аппаратными регистрами, расширенными регистрами,
регистрами для чисел с плавающей запятой.

\hypertarget{ux443ux43bux443ux447ux448ux435ux43dux438ux435-ux43aux43dux438ux433ux438-radare2}{%
\subsection{Улучшение книги
Radare2}\label{ux443ux43bux443ux447ux448ux435ux43dux438ux435-ux43aux43dux438ux433ux438-radare2}}

\hypertarget{ux43aux43dux438ux433ux430-radare2}{%
\subsubsection{Книга Radare2}\label{ux43aux43dux438ux433ux430-radare2}}

Если есть желание внести свой вклад в книгу Radare2, можно сделать это
на сайте \href{https://github.com/radareorg/radare2-book}{Github}.
Предлагаемые варианты развития:

\begin{itemize}
\tightlist
\item
  Обзоры упражнений Crackme,
\item
  Обзоры CTF,
\item
  Документация по использованию Radare2,
\item
  Документация по разработке для Radare2,
\item
  Презентации на конференциях и семинарах о Radare2,
\item
  Портирование отсутствующего контента из книги Radare1 в Radare2.
\end{itemize}

Не забудьте получить разрешение на перенос контента, которым вы не
владеете лично и лично не создавали, прежде чем помещать его в книгу
Radare2.

Ознакомьтесь с общей инструкцией
\url{https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md} о
развитие проекта Radare2.

\hypertarget{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f}{%
\section{Конфигурация}\label{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f}}

Конфигурация radare2 выполняется с помощью команд установки
\texttt{переменных\ среды}. Ядро считывает и интерпретирует
\texttt{\textasciitilde{}/.config/radare2/radare2rc} во время запуска.
Можно добавлять \texttt{е}-команды в этот файл для настройки
конфигурацию Radare2 по своему вкусу. Для предотвращения загрузки этого
файла при запуске, установите флаг командной строки \texttt{-N}.
Типичный файл конфигурации запуска выглядит так:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ cat \textasciitilde{}/.radare2rc}
\ExtensionTok{e}\NormalTok{ scr.color = 1}
\ExtensionTok{e}\NormalTok{ dbg.bep   = loader}
\end{Highlighting}
\end{Shaded}

Конфигурацию также можно изменять с помощью флагов формата \texttt{-е}
\textless config=value\textgreater{} в строке параметров при запуске.
Таким образом, можно подправить конфигурацию из командной строки,
сохранив файл \texttt{.radare2rc} не тронутым. Например, чтобы начать с
пустой конфигурации, а затем настроить \texttt{scr.color} а также
\texttt{asm.syntax} можно использовать следующую строку:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ radare2 }\AttributeTok{{-}N} \AttributeTok{{-}e}\NormalTok{ scr.color=1 }\AttributeTok{{-}e}\NormalTok{ asm.syntax=intel }\AttributeTok{{-}d}\NormalTok{ /bin/ls}
\end{Highlighting}
\end{Shaded}

Внутри r2 конфигурация хранится в хеш-таблице. Переменные сгруппированы
в пространства имен: \texttt{cfg.}, \texttt{file.}, \texttt{dbg.},
\texttt{scr.} и так далее.

Чтобы получить список всех переменных конфигурации, просто введите
\texttt{е} в командной строке r2. Чтобы ограничить вывод выбранным
пространством имен, передайте его с точкой в конце
\texttt{е\ \textless{}имя\ пространства\textgreater{}.} Например,
\texttt{е\ file.} отобразит все переменные, определенные внутри
пространства имен «file».

Чтобы получить инструкции о команде \texttt{e} - \texttt{e?}:

\begin{verbatim}
Usage: e [var[=value]]  # Переменные
| e?asm.bytes     показать описание
| e??             перечислить конфигурационные переменные с описаниями
| e a             получить значение переменной 'a'
| e a=b           установить значение переменной 'a' равным 'b'
| e var=?         показать все возможные значения переменной
| e var=??        показать все возможные значения переменной с описаниями
| e.a=b           аналогично 'e a=b', но без использования пробела
| e,k=v,k=v,k=v   разделение запятой k[=v]
| e-              сбросить значения к начальным
| e*              сделать дамп переменных конфигурации в виде команд r
| e!a             инвертировать логическое значение переменной 'a'
| ec [k] [color]  установить цвет для заданного ключа (prompt, offset, ...)
| eevar           открыть редактор для изменения переменных
| ed              открыть редактор для изменения ~/.radare2rc
| ej              перечислить конфигурационные переменные в формате JSON
| env [k[=v]]     получить/установить значение переменной среды
| er [key]        установить режим доступа к конфигурационному ключу "только для чтения", и ... нет пути назад
| es [space]      показать все пространства конфигурационных переменных (не ключей)
| et [key]        показать тип заданной конфигурационной переменной
| ev [key]        перечислить конфигурационные переменные в подробном виде
| evj [key]       перечислить конфигурационные переменные в подробном виде в формате JSON
\end{verbatim}

Более простая альтернатива команде \texttt{e} доступна из визуального
режима. Наберите \texttt{Ve} для входа в этот режим, используйте стрелки
(вверх, вниз, влево, вправо) для навигации по конфигурации и \texttt{q}
- выход из этого режима. В начале экран визуального редактирования
конфигурации выглядит так:

\begin{verbatim}
[EvalSpace]

    >  anal
       asm
       scr
       asm
       bin
       cfg
       diff
       dir
       dbg
       cmd
       fs
       hex
       http
       graph
       hud
       scr
       search
       io
\end{verbatim}

Для значений конфигурации, которые могут принимать одно из нескольких
значений, вы можете использовать \texttt{=?}, оператор для получения
списка допустимых значений:

\begin{verbatim}
[0x00000000]> e scr.nkey = ?
scr.nkey = fun, hit, flag
\end{verbatim}

\hypertarget{ux446ux432ux435ux442ux43eux432ux430ux44f-ux440ux430ux441ux43aux440ux430ux441ux43aux430-ux432-ux438ux43dux442ux435ux440ux444ux435ux439ux441ux435}{%
\subsection{Цветовая раскраска в
интерфейсе}\label{ux446ux432ux435ux442ux43eux432ux430ux44f-ux440ux430ux441ux43aux440ux430ux441ux43aux430-ux432-ux438ux43dux442ux435ux440ux444ux435ux439ux441ux435}}

Консольный доступ заключен в API, позволяющий отображать выходные данные
любой команды при помощи ANSI, W32 Console или HTML. Это позволяет ядру
радара работать в средах с ограниченными возможностями отображения,
таких как командная строка и встроенные устройства. С них по-прежнему
можно получать данные в предпочитаемом формате.

Чтобы включить поддержку цветов по умолчанию, добавьте соответствующий
параметр конфигурации в конфигурационный файл \texttt{.radare2}:

\begin{verbatim}
$ echo 'e scr.color=1' >> ~/.radare2rc
\end{verbatim}

Обратите внимание, что включение цветов не является логическим
параметром, а числом, обозначающим разные уровни глубины цвета,
\emph{режимы}:

\begin{itemize}
\tightlist
\item
  0: Черно-белый,
\item
  1: 16 основных цветов ANSI,
\item
  2: 256 цветов в виде шкалы,
\item
  3: 24-битный truecolor.
\end{itemize}

Причина наличия таких настроек заключается в том, что нет стандартного
или портативного способа для терминальных программ запрашивать консоль
для определения наилучшей конфигурации, то же самое касается кодировок
наборов символов, поэтому r2 позволяет выбрать это вручную.

Обычно последовательные консоли работают с режимами 0 или 1, в то время
как xterms могут поддерживать до уровня 3. RCons попытается найти
наиболее близкую цветовую схему для вашей темы, когда вы выбираете новую
тему с помощью команды \texttt{eco}.

Есть возможность настроить цвет практически любого элемента вывода
дизассемблера. Для терминалов *NIX r2 принимает спецификацию цвета в
формате RGB. Для изменения цветовой палитры консоли используйте команду
\texttt{ec}. Команда \texttt{ecs} отображает цветовую палитру,
помогающую с выбором цветов:

\begin{figure}
\centering
\includegraphics{r2pal.png}
\caption{img}
\end{figure}

\hypertarget{ux442ux435ux43cux44b}{%
\subsection{Темы}\label{ux442ux435ux43cux44b}}

Можно создать свою собственную цветовую тему, хотя у radare2 итак есть
уже предопределенные. Используйте команду \texttt{eco}, чтобы
перечислить и выбрать одну из их. После выбора одной можно сравнить ее
цветовую схему с текущей темой, нажав клавиши CTRL+SHIFT, а затем
клавишу со стрелкой вправо для переключателя. В визуальном режиме
используйте клавишу \texttt{R} для генерирования случайной палитры
цветов или выбора следующей темы в списке.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438}{%
\subsection{Переменные
конфигурации}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438}}

Ниже приведен список наиболее часто используемых конфигурационных
переменных. Полный список получается, выполнив команду \texttt{e} без
аргументов. Например, чтобы посмотреть все переменные, определенные в
пространстве имен ``cfg'', задайте \texttt{e\ cfg.} (обратите внимание
на конечную точку). Получить инструкцию по любой переменной конфигурации
- \texttt{e?\ cfg.}. Команда \texttt{e??} показывает описание всех
ценных переменных конфигурации radare2. Количество выдаваемых данных
этой команды довольно велико, можно фильтровать их внутренним grep-ом
\texttt{\textasciitilde{}}:

\begin{figure}
\centering
\includegraphics{e--color.png}
\caption{e??\textasciitilde color}
\end{figure}

Визуальный интерфейс включает браузер переменных среды, доступный с
помощью команды \texttt{Vbe}.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.arch}{%
\subsubsection{Переменная
asm.arch}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.arch}}

Эта переменная задает архитектуру целевого процессора для
дизассемблирования (\texttt{pd}, \texttt{pD}) и анализа кода
(\texttt{a}). Список возможных значений для конкретной переменной
показывается при помощи \texttt{e\ asm.arch=?} или \texttt{rasm2\ -L}.

Добавить новые архитектуры для разборки и анализа кода довольно просто.
Для этого есть специальный интерфейс. Для x86 он используется для
присоединения ряда сторонних дизассемблерных механизмов, включая GNU
binutils, Udis86 и несколько реализованных вручную.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.bits}{%
\subsubsection{Переменная
asm.bits}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.bits}}

Определяет размер регистров в битах для текущей архитектуры.
Поддерживаемые значения: 8, 16, 32, 64. Обратите внимание, что не все
целевые архитектуры поддерживают все комбинации asm.bits.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.syntax}{%
\subsubsection{Переменная
asm.syntax}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.syntax}}

Выбирает синтаксический диалект дизассемблера между Intel и AT\&T. На
данный момент этот параметр влияет на дизассемблер Udis86 только для
архитектур Intel 32/Intel 64. Поддерживаются значения \texttt{intel} и
\texttt{att}.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.pseudo}{%
\subsubsection{Переменная
asm.pseudo}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.pseudo}}

Это логическое значение для задания псевдо-синтаксиса при
дизассемблировании. Значение «false» указывает на ``родной'',
определенный текущей архитектурой, «true» активирует формат строк
псевдокода. Например, переменная ``преобразует'':

\begin{verbatim}
│           0x080483ff      e832000000     call 0x8048436
│           0x08048404      31c0           xor eax, eax
│           0x08048406      0205849a0408   add al, byte [0x8049a84]
│           0x0804840c      83f800         cmp eax, 0
│           0x0804840f      7405           je 0x8048416
\end{verbatim}

в

\begin{verbatim}
│           0x080483ff      e832000000     0x8048436 ()
│           0x08048404      31c0           eax = 0
│           0x08048406      0205849a0408   al += byte [0x8049a84]
│           0x0804840c      83f800         var = eax - 0
│           0x0804840f      7405           if (!var) goto 0x8048416
\end{verbatim}

Переменная полезна при дизассемблировании малоизвестных архитектур.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.os}{%
\subsubsection{Переменная
asm.os}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.os}}

Задает целевую операционную систему загруженного в данный момент
двоичного файла. Обычно ОС автоматически определяется
\texttt{rabin\ -rI}. Изменение значение \texttt{asm.os} используется для
переключения на таблицу системных вызовов конкретной операционной
системы.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.flags}{%
\subsubsection{Переменная
asm.flags}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.flags}}

Если задано значение ``true'', представление дизассемблера будет
включать столбец флагов.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.lines.call}{%
\subsubsection{Переменная
asm.lines.call}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.lines.call}}

Если задано значение ``true'', рисует линии слева от вывода
дизассемблирования (\texttt{pd}, \texttt{pD}), чтобы графически
представить поток управления (переходы и вызовы), которые входят внутрь
текущего блока. Кроме того, смотрите инструкцию в
\texttt{asm.lines.out}.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.lines.out}{%
\subsubsection{Переменная
asm.lines.out}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.lines.out}}

Если она равна «true», представление дизассемблера также будет рисовать
потоки, выходящие за пределы блока.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.linestyle}{%
\subsubsection{Переменная
asm.linestyle}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.linestyle}}

Логическое значение, изменяющее направление анализа потока управления.
Если задано значение ``false'', производится сверху вниз блока; в
противном случае он идет снизу вверх. Настройка «false», по-видимому,
является лучшим выбором для улучшения читаемости и является настройкой
по умолчанию.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.offset}{%
\subsubsection{Переменная
asm.offset}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.offset}}

Логическое значение, которое управляет видимостью адресов смещений для
отдельно дизассемблированных инструкций.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.trace}{%
\subsubsection{Переменная
asm.trace}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.trace}}

Логическое значение, управляющее отображением информации трассировки
(порядковый номер и счетчик) слева от каждого оп-кода. Используется в
анализе трассировки программ.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.bytes}{%
\subsubsection{Переменная
asm.bytes}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.bytes}}

Логическое значение, используемое для отображения или скрытия raw-байтов
инструкций.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.reg}{%
\subsubsection{Переменная
asm.sub.reg}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.reg}}

Логическое значение, используемое для замены имен регистров аргументами
или связанной с его псевдонимом роли.

Например, если у вас есть что-то вроде этого:

\begin{verbatim}
│           0x080483ea      83c404         add esp, 4
│           0x080483ed      68989a0408     push 0x8049a98
│           0x080483f7      e870060000     call sym.imp.scanf
│           0x080483fc      83c408         add esp, 8
│           0x08048404      31c0           xor eax, eax
\end{verbatim}

Переменная изменяет представление на:

\begin{verbatim}
│           0x080483ea      83c404         add SP, 4
│           0x080483ed      68989a0408     push 0x8049a98
│           0x080483f7      e870060000     call sym.imp.scanf
│           0x080483fc      83c408         add SP, 8
│           0x08048404      31c0           xor A0, A0
\end{verbatim}

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.jmp}{%
\subsubsection{Переменная
asm.sub.jmp}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.jmp}}

Логическое значение, используемое для замены целевых объектов перехода,
вызова и ветвления при дизассемблировании. Например, во включенном
режиме он будет отображать \texttt{jal\ 0x80001a40} как
\texttt{jal\ fcn.80001a40} в дизассемблировании.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.rel}{%
\subsubsection{Переменная
asm.sub.rel}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.rel}}

Логическое значение, которое заменяет относительные выражения pc при
дизассемблировании. Если этот параметр включен, ссылки отображаются как
строковые ссылки, например:

\begin{verbatim}
0x5563844a0181      488d3d7c0e00.  lea rdi, [rip + 0xe7c]    ; str.argv__2d_:__s
\end{verbatim}

Если эта переменная включена, она позволяет отобразить приведенную выше
инструкцию следующим образом:

\begin{verbatim}
0x5563844a0181      488d3d7c0e00.  lea rdi, str.argv__2d_:__s    ; 0x5563844a1004 ; "argv[%2d]: %s\n"
\end{verbatim}

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.section}{%
\subsubsection{Переменная
asm.sub.section}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.section}}

Логическое значение, показывающее смещение в дизассемблировании с
префиксом названия раздела или карты. Это означает что-то вроде:

\begin{verbatim}
0x000067ea      488d0def0c01.  lea rcx, [0x000174e0]
\end{verbatim}

то же самое, но со включенным режимом.

\begin{verbatim}
0x000067ea      488d0def0c01.  lea rcx, [fmap.LOAD1.0x000174e0]
\end{verbatim}

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.varonly}{%
\subsubsection{Переменная
asm.sub.varonly}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-asm.sub.varonly}}

Заменять ли выражение переменной именем локальной переменной. Например,
\texttt{var\_14h} как \texttt{rbp\ -\ var\_14h} в дизассемблировании.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.bigendian}{%
\subsubsection{Переменная
cfg.bigendian}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.bigendian}}

Изменение порядка байтов: «true» означает биг-эндиан, «false» -
литл-эндиан, причем ``file.id'' и ``file.flag'' должны быть ``true''.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.newtab}{%
\subsubsection{Переменная
cfg.newtab}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.newtab}}

Если эта переменная включена, сообщения справки будут отображаться
вместе с именами команд в автодополнении.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.color}{%
\subsubsection{Переменная
scr.color}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.color}}

Эта переменная задает режим вывода ``в цвете'' или нет: «false» (или 0)
означает отсутствие цветов, «true» (или 1) означает 16-цветной режим, 2
означает 256-цветовой режим, 3 означает режим ``о 16-ти миллионов
цветов''. Если вами предпочитаемая тема выглядит странно, попробуйте
увеличить число.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.seek}{%
\subsubsection{Переменная
scr.seek}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.seek}}

Переменная принимает выражение или указатель/флаг (например, eip). Если
установлено, radare установит начальное смещение в это значение при
запуске.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.scrollbar}{%
\subsubsection{Переменная
scr.scrollbar}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.scrollbar}}

Если настроены какие-либо \href{../basic_commands/flags.md}{зоны флагов}
(\texttt{fz?}), эта переменная позволит вам отобразить полосу прокрутки
с флаг-зонами в визуальном режиме. Установите значение в \texttt{1},
чтобы отобразить полосу прокрутки справа, \texttt{2} для верхней части
экрана и \texttt{3} - снизу.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.utf8}{%
\subsubsection{Переменная
scr.utf8}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-scr.utf8}}

Логическая переменная для отображения символов UTF-8 вместо ANSI.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.fortunes}{%
\subsubsection{Переменная
cfg.fortunes}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.fortunes}}

Включает или отключает сообщения «высказываний Фортуны», отображаемые
при каждом запуске радара.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.fortunes.type}{%
\subsubsection{Переменная
cfg.fortunes.type}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-cfg.fortunes.type}}

Высказывания Фортуны классифицируются по типу. Эта переменная
определяет, какие типы разрешены для отображения, когда
\texttt{cfg.fortunes} \texttt{true}, их можно настроить на целевую
аудиторию. Текущие типы - \texttt{это\ советы} (tips), \texttt{веселье}
(fun), \texttt{nsfw}, \texttt{жуткие} (creepy).

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-stack.size}{%
\subsubsection{Переменная
stack.size}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux430ux44f-stack.size}}

Эта переменная позволяет задать размер стека в байтах.

\hypertarget{ux444ux430ux439ux43bux44b-radare2}{%
\subsection{Файлы radare2}\label{ux444ux430ux439ux43bux44b-radare2}}

Используйте \texttt{r2\ -H} для перечисления всех переменных среды,
управляющих поиском файлов на диске. Путь поиска зависит от настроек
вашей сборки r2 и операционной системы.

\begin{verbatim}
R2_PREFIX=/usr
MAGICPATH=/usr/share/radare2/2.8.0-git/magic
PREFIX=/usr
INCDIR=/usr/include/libr
LIBDIR=/usr/lib64
LIBEXT=so
RCONFIGHOME=/home/user/.config/radare2
RDATAHOME=/home/user/.local/share/radare2
RCACHEHOME=/home/user/.cache/radare2
LIBR_PLUGINS=/usr/lib/radare2/2.8.0-git
USER_PLUGINS=/home/user/.local/share/radare2/plugins
USER_ZIGNS=/home/user/.local/share/radare2/zigns
\end{verbatim}

\hypertarget{ux444ux430ux439ux43bux44b-rc}{%
\subsection{Файлы RC}\label{ux444ux430ux439ux43bux44b-rc}}

RC-файлы --- это сценарии r2, которые загружаются во время запуска. Эти
файлы должны находиться в трех разных местах:

\begin{itemize}
\tightlist
\item
  Системная, radare2 сначала попытается загрузить
  /usr/share/radare2/radare2rc,
\item
  В домашнем директории.
\end{itemize}

Каждый пользователь в системе может настраивать свои собственные
сценарии r2 для запуска, например, выбор цветовой схемы, а также другие
параметры, задаваемые там командами r2.

\begin{itemize}
\tightlist
\item
  \textasciitilde/.radare2rc,
\item
  \textasciitilde/.config/radare2/radare2rc,
\item
  \textasciitilde/.config/radare2/radare2rc.d/.
\end{itemize}

\hypertarget{ux446ux435ux43bux435ux432ux43eux439-ux444ux430ux439ux43b}{%
\subsubsection{Целевой
файл}\label{ux446ux435ux43bux435ux432ux43eux439-ux444ux430ux439ux43b}}

Если надо запускать сценарий каждый раз при открытии файла, просто
создайте файл с тем же именем, что и бинарный файл, но добавив к нему
\texttt{.r2}.

\hypertarget{ux43eux441ux43dux43eux432ux43dux44bux435-ux43aux43eux43cux430ux43dux434ux44b}{%
\section{Основные
команды}\label{ux43eux441ux43dux43eux432ux43dux44bux435-ux43aux43eux43cux430ux43dux434ux44b}}

Большинство названий команд в radare являются производными от названий
действий. Их легко запомнить, так как они короткие. На самом деле, все
команды являются одиночными буквами. Подкоманды или связанные команды
задаются с помощью второго символа в названии. Например, \texttt{/\ foo}
--- это команда для поиска строки, а \texttt{/x\ 90\ 90} используется
для поиска шестнадцатеричных пар.

Общий формат команды как описано в главе
\href{../first_steps/command_format.md}{Формат команды} выглядит
следующим образом:

\begin{verbatim}
[.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...
\end{verbatim}

Например,

\begin{verbatim}
> 3s +1024    ; ищет три раза 1024 из текущего смещения
\end{verbatim}

Если команда начинается с \texttt{=!}, остальная часть строки передается
загруженному в данный момент подключаемому модулю (например, отладчику).
Большинство плагинов предоставляют инструкции при помощи \texttt{=!?}
или \texttt{=!help}.

\begin{verbatim}
$ r2 -d /bin/ls
> =!help      ; обрабатывается плагином ввода-вывода
\end{verbatim}

Если команда начинается с \texttt{!}, вызывается
\texttt{posix\_system()} для передачи команды в оболочку. Для получения
дополнительных вариантов и примеров использования есть команда
\texttt{!?}.

\begin{verbatim}
> !ls         ; запустить `ls` в операционной системе
\end{verbatim}

Значение аргументов iter, addr, size зависит от конкретной команды. Как
правило, большинство команд принимают число в качестве аргумента, чтобы
указать количество байтов для работы, а не текущий размер блока.
Некоторые команды принимают математические выражения или строки.

\begin{verbatim}
> px 0x17     ; показать 0x17 байт в шестнадцатеричном виде по текущему адресу,
> s base+0x33 ; установить смещение на флаг 'base' плюс 0x33 байта,
> / lib       ; искать строку 'lib'.
\end{verbatim}

Знак \texttt{@} используется для указания временного адреса или
смещения, в котором выполняется команда, вместо текущего смещения. Очень
удобно, так как вам не нужно всякий раз переустанавливать смещение.

\begin{verbatim}
> p8 10 @ 0x4010  ; показать 10 байт по смещению 0x4010
> f patata @ 0x10 ; ассоциировать флаг 'patata' со смещением 0x10
\end{verbatim}

Используя \texttt{@@}, можно выполнить одну команду над каждым элементом
списка флагов, подобно glob. Можете воспринимать это как foreach:

\begin{verbatim}
> s 0
> / lib             ; поиск строки 'lib'
> p8 20 @@ hit0_*   ; показать 20 байт в шестнадцатеричном виде по каждому найденному адресу
\end{verbatim}

Операция \texttt{\textgreater{}} используется для перенаправления
выходных данных команды в файл (его перезаписи, если он уже существует).

\begin{verbatim}
> pr > dump.bin   ; сделать дамп 'raw'-байтов текущего блока в файл с именем 'dump.bin'
> f  > flags.txt  ; сделать дамп списка флагов в 'flags.txt'
\end{verbatim}

Операция \texttt{\textbar{}} (канал) аналогична тому, что в операционной
системе *NIX: перенаправить вывод одной команды на вход для другой.

\begin{verbatim}
[0x4A13B8C0]> f | grep section | grep text
0x0805f3b0 512 section._text
0x080d24b0 512 section._text_end
\end{verbatim}

Можно выполнить несколько команд в одной строке, разделив их точкой с
запятой \texttt{;}:

\begin{verbatim}
> px ; dr
\end{verbatim}

При помощи \texttt{\_} можно распечатать результат, полученный последней
командой.

\begin{verbatim}
[0x00001060]> axt 0x00002004
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
[0x00001060]> _
main 0x1181 [DATA] lea rdi, str.argv__2d_:__s
\end{verbatim}

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-ux431ux430ux437ux43eux432ux43eux433ux43e-ux441ux43cux435ux449ux435ux43dux438ux44f}{%
\subsection{Установка базового
смещения}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-ux431ux430ux437ux43eux432ux43eux433ux43e-ux441ux43cux435ux449ux435ux43dux438ux44f}}

Чтобы перемещаться по проверяемому файлу, т.е. \emph{менять адрес
смещения}, требуется изменять смещение при помощи команды \texttt{s}.
Аргумент представляет собой математическое выражение, которое может
содержать имена флагов, скобки, сложение, вычитание, умножение
непосредственных значений содержимого памяти с помощью скобок.

Несколько примеров использования команд:

\begin{verbatim}
[0x00000000]> s 0x10
[0x00000010]> s+4
[0x00000014]> s-
[0x00000010]> s+
[0x00000014]>
\end{verbatim}

Посмотрите, как изменяется смещение (seek) в левой части командной
строке. Первая строка устанавливает текущее смещение по адресу 0x10.
Вторая смещает адрес на четыре байта вперед (переместиться относительно
предыдущего смещения). И, наконец, последние две команды отменяют (undo)
и заново выполняют (redo) последние операции установки адреса (seek).
Вместо использования исключительно числовых значений, можно использовать
сложные выражения и обычные арифметические операции для вычисления
адреса. Ознакомьтесь с инструкцией, предоставляемой командой ?\$?, там
описаны переменные, которые можно использовать в адресных выражениях.
Например, следующие выражение делает то же самое что и \texttt{s+4}.

\begin{verbatim}
[0x00000000]> s $$+4
\end{verbatim}

В отладчике (или в режиме эмуляции ESIL) можно использовать имена
регистров в качестве адресов. Имена регистров --- это флаги, их перечень
доступен при помощи \texttt{.dr*}.

\begin{verbatim}
[0x00000000]> s rsp+0x40
\end{verbatim}

Приведем справку по командам группы \texttt{s}. Более детально они будут
рассмотрены на примерах далее.

\begin{verbatim}
[0x00000000]> s?
Usage: s    # Инструкция по командам смены смещения. Смотрите ?$? - перечень всех переменных
| s                 Показать текущее смещение (адрес)
| s.hexoff          Задать смещение, используя систему счисления из core->offset
| s:pad             Показать текущее смещение в поле N символов (по умолчанию 8), заполняя пустое место нулями
| s addr            Усановить смещение по заданному адресу
| s-                Отменить предыдущую операцию установки смещение
| s-*               Вернуть ранее отмененную операцию смещения
| s- n              Переместиться на n в обратном направлении
| s--[n]            Переместиться на blocksize байт в обратном направлении (/=n)
| s+                Вернуть ранее отмененную операцию смещения
| s+ n              Переместиться на n дальше
| s++[n]            Переместиться на blocksize байт вперед (/=n)
| s[j*=!]           Показать историю отмен операций смещения (JSON, =list, *r2, !=names, s==)
| s/ DATA           Поиск следующего вхождения 'DATA'
| s/x 9091          Поиск следующего вхождения \x90\x91
| sa [[+-]a] [asz]  Установить смещение asz (или bsize), выровненный на адрес
| sb                Установить смещение выровненным на начало базового блока
| sC[?] string      Установить смещение на комментарий, соответствующий заданной строке
| sf                Установить смещение на следующую функцию (f->addr+f->size)
| sf function       Установить смещение на адрес заданной функции
| sf.               Установить адрес смещения на начало текущей функции
| sg/sG             Установить смещение на начало (sg) или конец (sG) секции или файла
| sl[?] [+-]line    Установить смещение на строку
| sn/sp ([nkey])    Установить смещение следующее/предыдущее место, в соответствии с scr.nkey
| so [N]            Установить смещение на N-ый следующий по-код
| sr pc             Установить смещение на адрес в регистре
| ss                Установить смещение без добавления записи в историю адресов смещений

> 3s++        ; выполнить три раза операцию установки смещения к следующему блоку
> s 10+0x80   ; установить смещение на 0x80+10
\end{verbatim}

Результат математического выражения можно посмотреть при помощи команды
\texttt{?}. Выражение передается в качестве аргумента. Результат
отображается в шестнадцатеричном, десятичном, восьмеричном и двоичном
форматах.

\begin{verbatim}
> ? 0x100+200
0x1C8 ; 456d ; 710o ; 1100 1000
\end{verbatim}

Существуют также подкоманды \texttt{?}, отображающие результаты в одном
конкретном формате (по базе 10, 16, \ldots). Смотрите \texttt{?v} и
\texttt{?vi}.

В визуальном режиме можно нажать \texttt{u} (undo) или \texttt{U} (redo)
внутри истории адресов смещений --- перемещение в обоих направлениях по
адресам смещений.

\hypertarget{ux43eux442ux43aux440ux44bux442ux44c-ux444ux430ux439ux43b}{%
\subsection{Открыть
файл}\label{ux43eux442ux43aux440ux44bux442ux44c-ux444ux430ux439ux43b}}

Рассмотрим работу команд на простом примере \texttt{hello\_world.c},
скомпилированном в Linux ELF. После сборки компилятором, откроем его
radare2-ом:

\begin{verbatim}
$ r2 hello_world
\end{verbatim}

Теперь у нас есть командная строка:

\begin{verbatim}
[0x00400410]>
\end{verbatim}

\hypertarget{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-ux441ux43cux435ux449ux435ux43dux438ux44f-ux43dux430-ux43bux44eux431ux44bux435-ux430ux434ux440ux435ux441ux430}{%
\subsection{Перемещение смещения на любые
адреса}\label{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-ux441ux43cux435ux449ux435ux43dux438ux44f-ux43dux430-ux43bux44eux431ux44bux435-ux430ux434ux440ux435ux441ux430}}

Все команды перемещения (seek), принимающие адрес в качестве параметра,
могут использовать любую систему счисления, например, шестнадцатеричную,
восьмеричную, двоичную или десятичную.

Установка адреса 0x0. Альтернативный вариант --- просто \texttt{0x0}:

\begin{verbatim}
[0x00400410]> s 0x0
[0x00000000]>
\end{verbatim}

Показать текущий адрес:

\begin{verbatim}
[0x00000000]> s
0x0
[0x00000000]>
\end{verbatim}

Существует альтернативный способ печати текущей позиции -
\texttt{?v\ \$\$}.

Перемещение на N позиций вперед, пробел необязателен:

\begin{verbatim}
[0x00000000]> s+ 128
[0x00000080]>
\end{verbatim}

Отмена последних двух смещений, возврат к исходному адресу:

\begin{verbatim}
[0x00000080]> s-
[0x00000000]> s-
[0x00400410]>
\end{verbatim}

Мы вернулись к \emph{0x00400410}.

Теперь можно показать историю адресов смещений:

\begin{verbatim}
[0x00400410]> s*
f undo_3 @ 0x400410
f undo_2 @ 0x40041a
f undo_1 @ 0x400410
f undo_0 @ 0x400411
# Current undo/redo position. # Текущеее положение 
f redo_0 @ 0x4005b4
\end{verbatim}

\hypertarget{ux440ux430ux437ux43cux435ux440-ux431ux43bux43eux43aux430}{%
\subsection{Размер
блока}\label{ux440ux430ux437ux43cux435ux440-ux431ux43bux43eux43aux430}}

Размер блока определяет, сколько байт будут обрабатывать команды
radare2, если не задан явный аргумент размера. Можно временно изменять
размер блока, указав числовой аргумент для команд печати. Например,
\texttt{px\ 20}.

\begin{verbatim}
[0x00000000]> b?
Usage: b[f] [arg]  # Узнать/установить размер блока
| b 33     установить размер блока 33
| b eip+4  числовой аргумент может быть выражением
| b        показать текущий размер блока
| b+3      увеличить размер блока на 3
| b-16     уменьшить размер блока на 16
| b*       показать текущий размер блока в r2
| bf foo   установить размер блока равным размеру флага
| bj       представить информацию о размере блока в виде JSON
| bm 1M    установить максимальный размер блока
\end{verbatim}

Команда \texttt{b} используется для изменения размера блока:

\begin{verbatim}
[0x00000000]> b 0x100   # размер блока = 0x100
[0x00000000]> b+16      #  ... = 0x110
[0x00000000]> b-32      #  ... = 0xf0
\end{verbatim}

Команда \texttt{bf} используется для изменения размера блока на
определенное значение, связанное с флагом. Например, в символах размер
блока флага представляет размер функции. Чтобы это работало, нужно
запустить анализ функций \texttt{af}, входящий в \texttt{aa}, или
вручную найти и определить функции при помощи \texttt{Vd}.

\begin{verbatim}
[0x00000000]> bf sym.main    # размер блока = sizeof(sym.main)
[0x00000000]> pD @ sym.main  # дизассемблировать sym.main
\end{verbatim}

Совместить две операции в одной --- команда \texttt{pdf}. Кроме
\texttt{pdf} никакие другие команды не влияют на размер глобального
блока.

\begin{verbatim}
[0x00000000]> pdf @ sym.main  # дизассемблировать sym.main
\end{verbatim}

Другой способ --- использовать специальные переменные \texttt{\$FB} и
\texttt{\$FS}, обозначающие начало и размер функции при выполнении seek.
Подробнее ищите в
\href{../refcard/intro.md\#usable-variables-in-expression}{Используемые
переменные}.

\begin{verbatim}
[0x00000000]> s sym.main + 0x04
[0x00001ec9]> pD @ $FB !$FS  # дизассемблировать текущую функцию
╭ 211: int main (int argc, char **argv, char **envp);
│           0x00001ec5      55                 push rbp
│           0x00001ec6      4889e5             mov rbp, rsp
│           0x00001ec9      4881ecc0000000     sub rsp, 0xc0
...
╰           0x00001f97      c3                 ret
\end{verbatim}

Примечание: не ставьте пробел после \texttt{!}. Смотрите также
\href{../first_steps/command_format.md}{Формат команды}.

\hypertarget{ux441ux435ux43aux446ux438ux438}{%
\subsection{Секции}\label{ux441ux435ux43aux446ux438ux438}}

Понятие секций (разделов) привязано к информации, извлекаемой из
двоичного файла. Наиболее часто --- это исполняемый файл. Двоичными
файлами в этой книге также обозначаются скомпилированные объектные файлы
и им подобные. Информация о секциях отображается с помощью команды
\texttt{i}.

Отображение информации о секциях:

\begin{verbatim}
[0x00005310]> iS
[Sections]
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
...
\end{verbatim}

Как вы, возможно, знаете, двоичные файлы состоят из секций и карт
памяти. Секции определяют содержимое части файла, отображаемое в память
(или нет). То, что отображается, определяется сегментами.

До рефакторинга ввода-вывода, выполненного condret, команда \texttt{S}
использовалась для управления так называемыми картами. В настоящее время
команда \texttt{S} устарела, поскольку \texttt{iS} и \texttt{om} теперь
достаточно.

Загрузчики прошивки микроконтроллеров, загрузчики двоичных файлов
операционной системы обычно размещают секции по разным адресам в памяти.
Radare интерпретирует работу загрузчика --- команды группы \texttt{iS}.
Инструкции представлены в \texttt{iS?}. Для перечисления всех созданных
секций используйте \texttt{iS} (или \texttt{iSj} для получения
результата в формате json). Команда \texttt{iS=} покажет карту разделов
в ascii-art.

С помощью подкоманды \texttt{om} можно создать новое отображение
следующим образом:

\begin{verbatim}
om fd vaddr [size] [paddr] [rwx] [name]
\end{verbatim}

Пример:

\begin{verbatim}
[0x0040100]> om 4 0x00000100 0x00400000 0x0001ae08 rwx test
\end{verbatim}

Также можно использовать команду \texttt{om} для просмотра сведений об
отображаемых разделах:

\begin{verbatim}
[0x00401000]> om
 6 fd: 4 +0x0001ae08 0x00000100 - 0x004000ff rwx test
 5 fd: 3 +0x00000000 0x00000000 - 0x0000055f r-- fmap.LOAD0
 4 fd: 3 +0x00001000 0x00001000 - 0x000011e4 r-x fmap.LOAD1
 3 fd: 3 +0x00002000 0x00002000 - 0x0000211f r-- fmap.LOAD2
 2 fd: 3 +0x00002de8 0x00003de8 - 0x0000402f r-- fmap.LOAD3
 1 fd: 4 +0x00000000 0x00004030 - 0x00004037 rw- mmap.LOAD3
\end{verbatim}

В результате выполнения \texttt{om?} будет выведен перечень всех
подкоманд. Чтобы перечислить все ранее определенные карты памяти,
используйте \texttt{om} (или \texttt{omj} для получения результата в
формате json, \texttt{om*} --- формат команд r2). Чтобы получить
представление в ascii-art, используйте \texttt{om=}. Также можно удалить
сопоставленный участок с помощью команды \texttt{om-mapid}.

Пример:

\begin{verbatim}
[0x00401000]> om-6
\end{verbatim}

\hypertarget{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux444ux430ux439ux43bux43eux432}{%
\subsection{Отображение
файлов}\label{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux444ux430ux439ux43bux43eux432}}

Подсистема ввода-вывода Radare позволяет сопоставлять содержимое файлов
в пространство ввода-вывода, используемое для хранения загруженного
двоичного файла. Программа radare2 способна открывать файлы и отображать
их части в любые места памяти, указывая такие атрибуты, как разрешения и
имя. Это идеальный подход к воспроизведению среды, такой как core dump,
сеанс отладки, а также загрузки и отображения в память всех библиотек,
от которых зависит двоичный файл.

Команда \texttt{o} позволяет пользователю открыть файл, он отображается
на смещение 0, если у него нет стандартного двоичного заголовка, карты
памяти создаются в виртуальных адресах. Иногда надо перебазировать
двоичный файл, или, загрузить и отобразить файл по другому адресу. При
запуске r2 базовый адрес можно изменить флагом \texttt{-B}. Есть разница
при открытии файлов с неизвестными заголовками, такими как booloader-ы,
их нужно отображать при помощи флага \texttt{-m}, или указав его в
качестве аргумента команде \texttt{o}. Посмотрим инструкцию для команды:

\begin{verbatim}
[0x00000000]> o?
|Usage: o [com- ] [file] ([offset])
| o                         перечень открытых файлов
| o-1                       закрыть файловый дескриптор 1
| o-!*                      закрыть все открытые файлы
| o--                       закрыть все файлы, анализы, двоичные файлы, флаги, тоже, что и !r2 --
| o [file]                  открыть файл [file] в режиме "только для чтения"
| o+ [file]                 открыть файл в режиме "чтение-запись"
| o [file] 0x4000 rwx       отобразить файл по адресу 0x4000
| oa[-] [A] [B] [filename]  указать архитектуру и размер регистров для заданного файла
| oq                        перечислить все открытые файлы
| o*                        перечислить открытые файлы в виде команд r2
| o. [len]                  открыть malloc://[len], копируя байты из текущего смещения
| o=                        перечислить открытые файлы (ascii-art bars)
| ob[?] [lbdos] [...]       перечислить открытые файлы "backed by" fd
| oc [file]                 открыть файл core-дампа, аналогично перезапуску r2
| of [file]                 открыть файл и отобразить его по адресу 0 в режиме "только для чтения"
| oi[-|idx]                 синоним для o, но используя индекс вместо fd
| oj[?]                     перечислить открытые файлы в формате JSON
| oL                        перечислить все зарегистрированные плагины ввода-вывода
| om[?]                     создать, перечислить, удалить карты ввода-вывода
| on [file] 0x4000          отобразить raw-файл по смащению 0x4000 (при этом r_bin не используется)
| oo[?]                     переоткрыть текущий файл (kill+fork в отладчике)
| oo+                       переоткрыть текущий файл в режиме "только для чтения"
| ood[r] [args]             переоткрыть в режиме отладки (с аргументами)
| oo[bnm] [...]             смотри инструкцию при помощи oo?
| op [fd]                   приоритизировать заданый fd (смотри также ob)
| ox fd fdx                 поменять местами fd-descs и fdx и сохранить отображение
\end{verbatim}

Покажем простой пример:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ rabin2 }\AttributeTok{{-}l}\NormalTok{ /bin/ls}
\ExtensionTok{[Linked}\NormalTok{ libraries]}
\ExtensionTok{libselinux.so.1}
\ExtensionTok{librt.so.1}
\ExtensionTok{libacl.so.1}
\ExtensionTok{libc.so.6}

\ExtensionTok{4}\NormalTok{ libraries}
\end{Highlighting}
\end{Shaded}

Сопоставление файла:

\begin{verbatim}
[0x00001190]> o /bin/zsh 0x499999
\end{verbatim}

Список отображенных файлов:

\begin{verbatim}
[0x00000000]> o
- 6 /bin/ls @ 0x0 ; r
- 10 /lib/ld-linux.so.2 @ 0x100000000 ; r
- 14 /bin/zsh @ 0x499999 ; r
\end{verbatim}

Показать шестнадцатеричные значения из /bin/zsh:

\begin{verbatim}
[0x00000000]> px @ 0x499999
\end{verbatim}

Отмена отображения файлов с помощью команды \texttt{o-}. Укажите
дескриптор файла в качестве аргумента:

\begin{verbatim}
[0x00000000]> o-14
\end{verbatim}

Также можно просмотреть таблицу ascii со списком открытых файлов:

\begin{verbatim}
[0x00000000]> ob=
\end{verbatim}

\hypertarget{ux440ux435ux436ux438ux43cux44b-ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux44f-ux434ux430ux43dux43dux44bux445}{%
\section{Режимы отображения
данных}\label{ux440ux435ux436ux438ux43cux44b-ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux44f-ux434ux430ux43dux43dux44bux445}}

Одной из ключевых особенностей radare2 является отображение информации,
представляя ее в разных форматах. Цель состоит в том, чтобы предложить
выбор вариантов отображения для наилучшей интерпретации двоичных данных.
Двоичные данные представляют целые числа (int), shorts, longs, floats,
timestamps, шестнадцатеричных строк или более сложных форматов, таких
как структуры C, дизассемблированием, декомпиляцией, результатами
внешних обработок и др.

Ниже приведен список доступных режимов отображения, перечисленных в
\texttt{p?} (print):

\begin{verbatim}
[0x00005310]> p?
|Usage: p[=68abcdDfiImrstuxz] [arg|len] [@addr]
| p[b|B|xb] [len] ([S])   вывести двоичный дамп N-бит, пропустив S байт
| p[iI][df] [len]         вывести N оп-кодов/байт (f=func) (смотрите pi? и pdi)
| p[kK] [len]             распечатать ключ в виде random-art (K - использовать мозайку)
| p-[?][jh] [mode]        bar|json|гистограммные-блоки (режим: e?search.in)
| p2 [len]                представить плитками 8x8, 2bpp (2 бита на пиксель)
| p3 [file]               Напечатать стереограмму (3D)
| p6[de] [len]            кодирование/декодирование base64
| p8[?][j] [len]          список 8bit-овых шестнадцатеричных байтов
| p=[?][bep] [N] [L] [b]  построить диаграмму энтропии/печатных символов/символов
| pa[edD] [arg]           pa:ассоциирование pa[dD]:дизассемблирование или pae: ESIL-инструкции из шестнадцатеричных байтов
| pA[n_ops]               показать n_ops-адресс и тип
| pb[?] [n]               вывести в битовом представлении N бит
| pB[?] [n]               вывести в битовом представлении N байт
| pc[?][p] [len]          представить в формате C (или python)
| pC[aAcdDxw] [rows]      показать дизассемблирование в виде колонок (смотрите hex.cols и pdi)
| pd[?] [sz] [a] [b]      дизассемблировать N оп-кодов (pd) или N байт (pD)
| pf[?][.nam] [fmt]       распечатать отформатированные данные (pf.name, pf.name $<expr>)
| pF[?][apx]              распечатать asn1, pkcs7 или x509
| pg[?][x y w h] [cmd]    создать новый визуальный гаджет или распечатать его (смотри инструкцию в pg?)
| ph[?][=|hash] ([len])   вычислить хэш для блока
| pj[?] [len]             распечатать в виде JSON с отступами
| pm[?] [magic]           распечатать данные libmagic (смотрите pm? и /m?)
| po[?] hex               распечатать операцию, применяемую к блоку (смотрите po?)
| pp[?][sz] [len]         распечатать шаблоны, инструкция в pp?
| pq[?][is] [len]         распечатать QR-код для первых N байт
| pr[?][glx] [len]        распечатать N байт в raw-формате (в виде строк или шестнадцатеричных кодов, 'g'unzip)
| ps[?][pwz] [len]        распечатать строкии в форматах pascal/wide/zero-terminated
| pt[?][dn] [len]         распечатать различные timestamp-ы
| pu[?][w] [len]          распечатать N байт в кодировке url (w=wide)
| pv[?][jh] [mode]        показать переменную/указатель/значение в памяти
| pwd                     показать текущий рабочий директорий
| px[?][owq] [len]        вывести дамп N шестнадцатеричных байт (o=octal, w=32bit, q=64bit)
| pz[?] [len]             распечатать вид zoom (инструкция в pz?)
[0x00005310]>
\end{verbatim}

Совет: при использовании вывода json можно добавлять
\texttt{\textasciitilde{}\{\}} к команде, которая оформит красивые
отступы:

\begin{verbatim}
[0x00000000]> oj
[{"raised":false,"fd":563280,"uri":"malloc://512","from":0,"writable":true,"size":512,"overlaps":false}]
[0x00000000]> oj~{}
[
    {
        "raised": false,
        "fd": 563280,
        "uri": "malloc://512",
        "from": 0,
        "writable": true,
        "size": 512,
        "overlaps": false
    }
]
\end{verbatim}

Для получения дополнительной информации о функциональных возможностях
\texttt{\textasciitilde{}} смотрите инструкцию в \texttt{?@?}, а также
главу \href{../first_steps/command_format.md}{Формат команды} в этой
книге.

\hypertarget{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux432ux438ux434}{%
\subsubsection{Шестнадцатеричный
вид}\label{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux432ux438ux434}}

\texttt{px} дает удобный вывод, показывающий 16 пар чисел в строке со
смещениями и raw-представлении:

\begin{figure}
\centering
\includegraphics{print_modes_px.png}
\caption{hexprint}
\end{figure}

\hypertarget{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux434ux430ux43cux43f-ux441ux43bux43eux432-32-ux431ux438ux442ux430}{%
\paragraph{Шестнадцатеричный дамп слов (32
бита)}\label{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux434ux430ux43cux43f-ux441ux43bux43eux432-32-ux431ux438ux442ux430}}

\begin{figure}
\centering
\includegraphics{print_modes_pxw.png}
\caption{wordprint}
\end{figure}

\hypertarget{ux431ux438ux442ux43eux432ux44bux439-ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux43dux430ux431ux43eux440-ux431ux430ux439ux442ux43eux432}{%
\paragraph{8-битовый шестнадцатеричный набор
байтов}\label{ux431ux438ux442ux43eux432ux44bux439-ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux43dux430ux431ux43eux440-ux431ux430ux439ux442ux43eux432}}

\begin{verbatim}
[0x00404888]> p8 16
31ed4989d15e4889e24883e4f0505449
\end{verbatim}

\hypertarget{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux434ux430ux43cux43f-ux438ux437-quad-ux441ux43bux43eux432-64-ux431ux438ux442ux430}{%
\paragraph{Шестнадцатеричный дамп из Quad-слов (64
бита)}\label{ux448ux435ux441ux442ux43dux430ux434ux446ux430ux442ux435ux440ux438ux447ux43dux44bux439-ux434ux430ux43cux43f-ux438ux437-quad-ux441ux43bux43eux432-64-ux431ux438ux442ux430}}

\begin{figure}
\centering
\includegraphics{print_modes_pxq.png}
\caption{pxq}
\end{figure}

\hypertarget{ux444ux43eux440ux43cux430ux442ux44b-ux434ux430ux442ux44bux432ux440ux435ux43cux435ux43dux438}{%
\subsubsection{Форматы
даты/времени}\label{ux444ux43eux440ux43cux430ux442ux44b-ux434ux430ux442ux44bux432ux440ux435ux43cux435ux43dux438}}

В настоящее время поддерживаются следующие режимы вывода timestamp-ов:

\begin{verbatim}
[0x00404888]> pt?
|Usage: pt [dn]  print timestamps
| pt.  распечатать текущее время
| pt   распечатать время UNIX (32 бит `cfg.bigendian`) с 1 января 1970
| ptd  распечатать время DOS (32 бит `cfg.bigendian`) с 1 января 1980
| pth  распечатать время HFS (32 бит `cfg.bigendian`) с 1 января 1904
| ptn  распечатать время NTFS (64 бит `cfg.bigendian`) с 1 января 1601
\end{verbatim}

Например, можно представить текущий буфер в виде временных меток во
времени NTFS:

\begin{verbatim}
[0x08048000]> e cfg.bigendian = false
[0x08048000]> pt 4
29:04:32948 23:12:36 +0000
[0x08048000]> e cfg.bigendian = true
[0x08048000]> pt 4
20:05:13001 09:29:21 +0000
\end{verbatim}

Как видите, порядок байтов влияет на результат. После того, timestamp
напечатан, можно профильтровать grep-ом выходные данные, например, по
номеру года:

\begin{verbatim}
[0x08048000]> pt ~1974 | wc -l
15
[0x08048000]> pt ~2022
27:04:2022 16:15:43 +0000
\end{verbatim}

Формат даты по умолчанию можно настроить с помощью переменной
\texttt{cfg.datefmt}. Правила форматирования следуют хорошо известному
формату strftime(3). Покажем справочную страницу, вот наиболее важное:

\begin{verbatim}
%a  Сокращенное название дня недели в соответствии с текущим языковым стандартом.
%A  Полное название дня недели в соответствии с текущим языковым стандартом.
%d  День месяца в виде десятичного числа (диапазон от 01 до 31).
%D  Эквивалентно %m/%d/%y.  (Yecch — только для американцев).
%H  Час в виде десятичного числа с использованием 24-часового формата (диапазон от 00 до 23).
%I  Час в виде десятичного числа с использованием 12-часового формата (диапазон от 01 до 12).
%m  Месяц в виде десятичного числа (диапазон от 01 до 12).
%M  Минута в виде десятичного числа (диапазон от 00 до 59).
%p  Либо "AM", либо "PM" в соответствии с заданным значением времени.
%s  Количество секунд со времен Эпохи, 1970-01-01 00:00:00 +0000 (UTC). (ТЗ)
%S  Секунда в виде десятичного числа (диапазон от 00 до 60).  (Диапазон составляет до 60 секунд, что позволяет время от времени использовать високосные секунды.)
%T  Время в 24-часовой нотации (%H:%M:%S).  (SU)
%y  Год в виде десятичного числа без века (диапазон от 00 до 99).
%Y  Год в виде десятичного числа, включая век.
%z  Числовой часовой пояс +hhmm или -hhmm (то есть часовое и минутное смещение от UTC). (SU)
%Z  Название или аббревиатура часового пояса.
\end{verbatim}

\hypertarget{ux43eux441ux43dux43eux432ux43dux44bux435-ux442ux438ux43fux44b}{%
\subsubsection{Основные
типы}\label{ux43eux441ux43dux43eux432ux43dux44bux435-ux442ux438ux43fux44b}}

Существуют режимы печати, доступные для всех базовых типов. Если вас
интересует более сложная структура, введите \texttt{pf??} для символов
формата и \texttt{pf???} для примеров:

\begin{verbatim}
[0x00499999]> pf??
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Format:
|  b       байт (unsigned)
|  B       интерпретировать битовое enum-поле (смотрите t?)
|  c       char (байт со знаком)
|  C       байт в десятичном виде
|  d       значение 0xHEX (4 байта) (смотрите 'i' и 'x')
|  D       дизассемблирование одного оп-кода
|  e       временно сменить порядок байтов
|  E       представить в виде имени из enum (смотрите t?)
|  f       значение float (4 байта)
|  F       значение double (8 байт)
|  i       целове значение со знаком (4 байта) (смотрите 'd' и 'x')
|  n       следующий символ задает размер значения со знаком (1, 2, 4 или 8 байт)
|  N       следующий символ задает размер значения без знака (1, 2, 4 или 8 байт)
|  o       восьмеричное значение (4 байта)
|  p       указатель (2, 4 или 8 байт)
|  q       quadword (8 байт)
|  r       регистр CPU `pf r (eax)plop`
|  s       32-битовый указатель на строку (4 байта)
|  S       64-битовый указатель на строку (8 байт)
|  t       UNIX timestamp (4 байта)
|  T       показать первых десять (Ten) байт буфера
|  u       uleb128 (variable length)
|  w       слово (2 байта, unsigned short в шестнадцатеричном виде)
|  x       значение в 0xHEX и флаг (fd @ addr) (смотрите 'd' и 'i')
|  X       отформатированный шестнадцатеричный дамп
|  z       строка, заканчивающаяся 0
|  Z       wide-строка, заканчивающаяся 0
|  ?       структура данных 'pf ? (имя_структуры)иня_экземпляра`
|  *       следующий символ - указатель (учитывает asm.bits)
|  +       включить/выключить вывод флага для каждого смещения
|  :       пропустить 4 байта
|  .       пропустить 1 байт
|  ;       отступить назад на 4 байтов
|  ,       отступить назад на 1 байт
\end{verbatim}

Используйте тройной вопросительный знак \texttt{pf???} для просмотра
примеров с использованием формата печати строк (printf).

\begin{verbatim}
[0x00499999]> pf???
|pf: pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]
| Примеры:
| pf 3xi foo bar                               массив из трех структур, в каждой три поля: 'foo' в шестнадцатеричном виде и 'bar' в виде целого числа
| pf B (BitFldType)arg_name`                   тип битовых полей
| pf E (EnumType)arg_name`                     тип enum
| pf.obj xxdz prev next size name              определить формат obj как xxdz
| pf obj=xxdz prev next size name              то же, что и выше
| pf *z*i*w nb name blob                       распечатать указатели с заданными именами
| pf iwq foo bar troll                         распечатать в формате iwq, foo, bar, troll - соответствующие поля структуры
| pf 0iwq foo bar troll                        то же, что выше, но представляющих юнион (все поля на смещении 0)
| pf.plop ? (troll)mystruct                    использовать структуру troll, определенную ранее
| pfj.plop @ 0x14                              применить формат к заданному смещению
| pf 10xiz pointer length string               распечатать 10 ячеек массива структур формата xiz с соответствующими полями
| pf 5sqw string quad word                     распечатать массив элементов формата sqw с соответствующими полями
| pf {integer}? (bifc)                         распечатать integer раз формат (bifc)
| pf [4]w[7]i                                  распечатать массив из четырех слов и за ним массив из семи целых чисел
| pf ic...?i foo bar "(pf xw yo foo)troll" yo  распечатать вложенные непоименнованные структуры
| pf ;..x                                      распечатать значение, расположенное через шесть байт от текущего смещения
| pf [10]z[3]i[10]Zb                           распечатать строку фиксированного размера, widechar и переменную
| pfj +F @ 0x14                                распечатать содержимое по заданному смещению с флагом
| pf n2                                        распечатать знаковое короткое целое (2 байта) значение. Используйте N вместо n для печати беззнаковых значений
| pf [2]? (plop)structname @ 0                 Песатает массив структур
| pf eqew bigWord beef                         переключить порядок байтов, печать с использованием полей
| pf.foo rr (eax)reg1 (eip)reg2                создать объект ссылающийся на значение в регистре
| pf tt troll plop                             распечатать timestamp-ы, используя поля troll и plop
\end{verbatim}

Ниже приведены примеры:

\begin{verbatim}
[0x4A13B8C0]> pf i
0x00404888 = 837634441
\end{verbatim}

\begin{verbatim}
[0x4A13B8C0]> pf
0x00404888 = 837634432.000000
\end{verbatim}

\hypertarget{ux432ux44bux441ux43eux43aux43eux443ux440ux43eux432ux43dux435ux432ux44bux435-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux44f-ux432-ux441ux438ux43dux442ux430ux43aux441ux438ux441ux435-ux44fux437ux44bux43aux43eux432-ux43fux440ux43eux433ux440ux430ux43cux43cux438ux440ux43eux432ux430ux43dux438ux44f}{%
\subsubsection{Высокоуровневые представления в синтаксисе языков
программирования}\label{ux432ux44bux441ux43eux43aux43eux443ux440ux43eux432ux43dux435ux432ux44bux435-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux44f-ux432-ux441ux438ux43dux442ux430ux43aux441ux438ux441ux435-ux44fux437ux44bux43aux43eux432-ux43fux440ux43eux433ux440ux430ux43cux43cux438ux440ux43eux432ux430ux43dux438ux44f}}

Допустимые форматы печати, использующие высокоуровневый синтаксис:

\begin{itemize}
\tightlist
\item
  \texttt{pc} C
\item
  \texttt{pc*} печать команд `wx' r2
\item
  \texttt{pch} C half-words (2 байта)
\item
  \texttt{pcw} слова C (4 байта)
\item
  \texttt{pcd} C dwords (8 байт)
\item
  \texttt{pci} массив байт C с инструкциями
\item
  \texttt{pca} GAS .byte blob
\item
  \texttt{pcA} .bytes с инструкциями в комментариях
\item
  \texttt{pcs} строка
\item
  \texttt{pcS} скрипт оболочки операционной системы, воссоздающий
  бинарные данные
\item
  \texttt{pcj} json
\item
  \texttt{pcJ} javascript
\item
  \texttt{pco} Objective-C
\item
  \texttt{pcp} python
\item
  \texttt{pck} kotlin
\item
  \texttt{pcr} rust
\item
  \texttt{pcv} JaVa
\item
  \texttt{pcV} V (vlang.io)
\item
  \texttt{pcy} yara
\item
  \texttt{pcz} Swift
\end{itemize}

Если нужно создать файл .c, содержащий BLOB, используйте команду
\texttt{pc}. Размер по умолчанию такой же, как и в многих других
командах: размер блока можно изменить с помощью команды \texttt{b}.
Также можно просто временно переопределить этот размер блока, выразив
его в качестве аргумента.

\begin{verbatim}
[0xB7F8E810]> pc 32
#define _BUFFER_SIZE 32
unsigned char buffer[_BUFFER_SIZE] = {
0x89, 0xe0, 0xe8, 0x49, 0x02, 0x00, 0x00, 0x89, 0xc7, 0xe8, 0xe2, 0xff, 0xff, 0xff, 0x81, 0xc3, 0xd6, 0xa7, 0x01, 0x00, 0x8b, 0x83, 0x00, 0xff, 0xff, 0xff, 0x5a, 0x8d, 0x24, 0x84, 0x29, 0xc2 };
\end{verbatim}

Структура cstring может использоваться во многих языках
программирования, а не только в C.

\begin{verbatim}
[0x7fcd6a891630]> pcs
"\x48\x89\xe7\xe8\x68\x39\x00\x00\x49\x89\xc4\x8b\x05\xef\x16\x22\x00\x5a\x48\x8d\x24\xc4\x29\xc2\x52\x48\x89\xd6\x49\x89\xe5\x48\x83\xe4\xf0\x48\x8b\x3d\x06\x1a
\end{verbatim}

\hypertarget{ux441ux442ux440ux43eux43aux438}{%
\subsubsection{Строки}\label{ux441ux442ux440ux43eux43aux438}}

С анализа строк, вероятно, начинается каждый реверс-инжениринг
программы, поскольку на них обычно ссылается код тела функции:
конкретные операторы, отладочная информация и другие сообщения. Поэтому
radare поддерживает различные строковые форматы:

\begin{verbatim}
[0x00000000]> ps?
|Usage: ps[bijqpsuwWxz+] [N]  Печать строки
| ps       печать строки
| ps+[j]   печать строки libc++ std::string (same-endian, ascii, zero-terminated)
| psb      печать строк, найденных в текущем блоке
| psi      печать строки внутри ткущего смещения
| psj      печать строки в формате JSON
| psp[j]   печать pascal-строки
| psq      синоним для pqs
| pss      печать строки на экран, вставляя переносы
| psu[zj]  печать utf16-юникода (json)
| psw[j]   печать wide-строку 16-бит
| psW[j]   печать wide-строку 32-бит
| psx      показать строку при помощи escape-последовательностей
| psz[j]   печать строки, заканчивающихся нулем
\end{verbatim}

Большинство строк заканчиваются нулем. Ниже приведен пример
использования отладчика для продолжения выполнения программы до тех пор,
пока не выполнится системный вызов `open'. Как только процессом
приостановлен, получаем аргументы, переданные в системный вызов, на
нужный нам указывает \%ebx. В случае вызова `open' это строка с нулевым
окончанием, проверим с помощью \texttt{psz}.

\begin{verbatim}
[0x4A13B8C0]> dcs open
0x4a14fc24 syscall(5) open ( 0x4a151c91 0x00000000 0x00000000 ) = 0xffffffda
[0x4A13B8C0]> dr
  eax  0xffffffda    esi  0xffffffff    eip    0x4a14fc24
  ebx  0x4a151c91    edi  0x4a151be1    oeax   0x00000005
  ecx  0x00000000    esp  0xbfbedb1c    eflags 0x200246
  edx  0x00000000    ebp  0xbfbedbb0    cPaZstIdor0 (PZI)
[0x4A13B8C0]>
[0x4A13B8C0]> psz @ 0x4a151c91
/etc/ld.so.cache
\end{verbatim}

\hypertarget{ux43fux435ux447ux430ux442ux44c-ux441ux43eux434ux435ux440ux436ux438ux43cux43eux433ux43e-ux43fux430ux43cux44fux442ux438}{%
\subsubsection{Печать содержимого
памяти}\label{ux43fux435ux447ux430ux442ux44c-ux441ux43eux434ux435ux440ux436ux438ux43cux43eux433ux43e-ux43fux430ux43cux44fux442ux438}}

Печать различных упакованных типов данных делается с помощью команды
\texttt{pf}:

\begin{verbatim}
[0xB7F08810]> pf xxS @ rsp
0x7fff0d29da30 = 0x00000001
0x7fff0d29da34 = 0x00000000
0x7fff0d29da38 = 0x7fff0d29da38 -> 0x0d29f7ee /bin/ls
\end{verbatim}

Форматы можно использовать для просмотра аргументов, передаваемых
функции. Передайте строку, описывающую формат в аргумент \texttt{pf} и
задайте смещение при помощи \texttt{@}. Также можно определять массивы
структур. Для этого добавьте к строке форматирования префикс с числовым
значением. Можно также определять имена для каждого поля структуры,
добавив их в виде списка аргументов, разделенных пробелами.

\begin{verbatim}
[0x4A13B8C0]> pf 2*xw pointer type @ esp
0x00404888 [0] {
   pointer :
(*0xffffffff8949ed31)      type : 0x00404888 = 0x8949ed31
   0x00404890 = 0x48e2
}
0x00404892 [1] {
(*0x50f0e483)    pointer : 0x00404892 = 0x50f0e483
     type : 0x0040489a = 0x2440
}
\end{verbatim}

Практический пример использования \texttt{pf} в двоичном файле плагина
GStreamer:

\begin{verbatim}
$ radare2 /usr/lib/gstreamer-1.0/libgstflv.so
[0x00006020]> aa; pdf @ sym.gst_plugin_flv_get_desc
[x] Analyze all flags starting with sym. and entry0 (aa)
sym.gst_plugin_flv_get_desc ();
[...]
      0x00013830      488d0549db0000  lea rax, section..data.rel.ro ; 0x21380
      0x00013837      c3              ret
[0x00006020]> s section..data.rel.ro
[0x00021380]> pf ii*z*zp*z*z*z*z*z*z major minor name desc init version license source package origin release_datetime
            major : 0x00021380 = 1
            minor : 0x00021384 = 18
             name : (*0x19cf2)0x00021388 = "flv"
             desc : (*0x1b358)0x00021390 = "FLV muxing and demuxing plugin"
             init : 0x00021398 = (qword)0x0000000000013460
          version : (*0x19cae)0x000213a0 = "1.18.2"
          license : (*0x19ce1)0x000213a8 = "LGPL"
           source : (*0x19cd0)0x000213b0 = "gst-plugins-good"
          package : (*0x1b378)0x000213b8 = "GStreamer Good Plugins (Arch Linux)"
           origin : (*0x19cb5)0x000213c0 = "https://www.archlinux.org/"
 release_datetime : (*0x19cf6)0x000213c8 = "2020-12-06"
\end{verbatim}

\hypertarget{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435}{%
\subsubsection{Дизассемблирование}\label{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435}}

Команда \texttt{pd} используется для дизассемблирования кода. Она
принимает числовое значение, указывающее, сколько инструкций должно быть
разобрано. Команда \texttt{pD} аналогична, но вместо нескольких
инструкций она декомпилирует заданное количество байтов.

\begin{itemize}
\tightlist
\item
  \texttt{d} : дизассемблирование N оп-кодов, количество оп-кодов,
\item
  \texttt{D} : дизассемблировать N байт, учитывая asm.arch
\end{itemize}

\begin{verbatim}
[0x00404888]> pd 1
;-- entry0:
0x00404888    31ed         xor ebp, ebp
\end{verbatim}

\hypertarget{ux432ux44bux431ux43eux440-ux446ux435ux43bux435ux432ux43eux439-ux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b}{%
\subsubsection{Выбор целевой
архитектуры}\label{ux432ux44bux431ux43eux440-ux446ux435ux43bux435ux432ux43eux439-ux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b}}

Целевая архитектура дизассемблера определяется переменной
\texttt{asm.arch}. Можно использовать \texttt{e\ asm.arch=??} для
перечисления всех доступных архитектур.

\begin{verbatim}
[0x00005310]> e asm.arch=??
_dAe  _8_16      6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  _8         8051        PD      8051 Intel CPU
_dA_  _16_32     arc         GPL3    Argonaut RISC Core
a___  _16_32_64  arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  _16_32_64  arm         BSD     Capstone ARM disassembler
_dA_  _16_32_64  arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  _16_32     arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  _8_16      avr         GPL     AVR Atmel
adAe  _16_32_64  bf          LGPL3   Brainfuck
_dA_  _32        chip8       LGPL3   Chip8 disassembler
_dA_  _16        cr16        LGPL3   cr16 disassembly plugin
_dA_  _32        cris        GPL3    Axis Communications 32-bit embedded processor
adA_  _32_64     dalvik      LGPL3   AndroidVM Dalvik
ad__  _16        dcpu16      PD      Mojang's DCPU-16
_dA_  _32_64     ebc         LGPL3   EFI Bytecode
adAe  _16        gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  _16        h8300       LGPL3   H8/300 disassembly plugin
_dAe  _32        hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  _32        hppa        GPL3    HP PA-RISC
_dAe  _0         i4004       LGPL3   Intel 4004 microprocessor
_dA_  _8         i8080       BSD     Intel 8080 CPU
adA_  _32        java        Apache  Java bytecode
_d__  _32        lanai       GPL3    LANAI
...
\end{verbatim}

\hypertarget{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}{%
\subsubsection{Настройка
дизассемблера}\label{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}}

Существует несколько вариантов настроек вывода дизассемблера. Все
настройки описаны в \texttt{e?} asm.`

\begin{verbatim}
[0x00005310]> e? asm.
asm.anal:        Анализировать код и ссылки при дизассемблировании (смотрите anal.strings)
asm.arch:        Задать архитектуру, используемую при ассемблировании
asm.assembler:   Установить имя плагина для использования во время ассемблирования
asm.bbline:      Добавить пустую строку между базовыми блоками
asm.bits:        Размер слова в битах при ассемблировании
asm.bytes:       Показать байтовое представление для каждой инструкции
asm.bytespace:   Разделять шестнадцатеричное представление пробелами
asm.calls:       Показать информацию, релевантную вызываемой функции в виде комментариев в дизассемблировании
asm.capitalize:  Использовать CamelCase при дизассемблировании
asm.cmt.col:     Колонка выравнивания коментариев
asm.cmt.flgrefs: Показать флаг-комментарий, ассоциированный с ветвлением
asm.cmt.fold:    Скрыть комментарии, переключается при помощи Vz
...
\end{verbatim}

В настоящее время существует 136 переменных конфигурации \texttt{asm.},
не будем перечислять их все.

\hypertarget{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}{%
\subsubsection{Синтаксис
дизассемблера}\label{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}}

Переменная \texttt{asm.syntax} используется для изменения диалекта
ассемблера, используемого механизмом дизассемблера. Чтобы переключиться
между представлениями Intel и AT\&T:

\begin{verbatim}
e asm.syntax = intel
e asm.syntax = att
\end{verbatim}

Также можно попробовать \texttt{asm.pseudo}, являющийся
экспериментальным представлением псевдокода, и \texttt{asm.esil},
выводящий \href{../disassembling/esil.md}{ESIL} (`Evaluable Strings
Intermediate Language'). Цель ESIL состоит в том, чтобы иметь удобное
представление семантики оп-кодов. Такие варианты представления данных
полезны для интерпретации отдельных инструкций.

\hypertarget{ux444ux43bux430ux433ux438}{%
\subsection{Флаги}\label{ux444ux43bux430ux433ux438}}

Флаги концептуально похожи на закладки. Они связывают имя с заданным
смещением в файле. Флаги группируются в «пространства флагов».
Пространство флагов --- это пространство имен для флагов, объединяющее
флаги со схожими характеристиками или типом. Примеры флаговых
пространств: секции (sections), регистры (registers), символы (symbols).

Создание флага:

\begin{verbatim}
[0x4A13B8C0]> f flag_name @ offset
\end{verbatim}

Удаление флага --- добавление символа \texttt{-} к команде. Большинство
команд принимают префиксный аргумент \texttt{-} как указание на удаление
чего-либо.

\begin{verbatim}
[0x4A13B8C0]> f-flag_name
\end{verbatim}

Для переключения между пространствами флагов или созданием новых
используйте команду \texttt{fs}:

\begin{verbatim}
[0x00005310]> fs?
|Usage: fs [*] [+-][flagspace|addr] # Управление пространствами флагов
| fs            перечислить пространства флагов
| fs*           перечислить пространства флагов в виде команд r2
| fsj           перечислить пространства флагов в виде JSON-а
| fs *          выбрать все пространства флагов
| fs flagspace  выбрать пространство флагов или создать его, если не существует
| fs-flagspace  удалить пространство флагов
| fs-*          удалить все пространства флагов
| fs+foo        запомнить в стек предыдущее пространсто флагов и установить новое
| fs-           установить предыдущее пространство флагов из стека
| fs-.          удаление текущего пространства флагов
| fsq           перечислить пространства флагов в "тихом" режиме
| fsm [addr]    переместить флаги на заданном адресе в текущее пространство флагов
| fss           показать стек пространств флагов
| fss*          показать стек пространств флагов в виде команд r2
| fssj          показать стек пространств флагов в виде JSON-а
| fsr newname   удалить выбранное пространство флагов
[0x00005310]> fs
0  439 * strings
1   17 * symbols
2   54 * sections
3   20 * segments
4  115 * relocs
5  109 * imports
[0x00005310]>
\end{verbatim}

Вот несколько примеров команд:

\begin{verbatim}
[0x4A13B8C0]> fs symbols ; выбрать флагов в пространстве флагов "symbols"
[0x4A13B8C0]> f          ; перечислить только флаги в пространстве "symbols"
[0x4A13B8C0]> fs *       ; выбрать все пространства имен
[0x4A13B8C0]> f myflag   ; создать новый флаг с именем 'myflag'
[0x4A13B8C0]> f-myflag   ; удалить флаг, называющийся 'myflag'
\end{verbatim}

Переименовывание флагов с помощью \texttt{fr}.

\hypertarget{ux43bux43eux43aux430ux43bux44cux43dux44bux435-ux444ux43bux430ux433ux438}{%
\subsubsection{Локальные
флаги}\label{ux43bux43eux43aux430ux43bux44cux43dux44bux435-ux444ux43bux430ux433ux438}}

Каждое имя флага должно быть уникальным по понятным причинам. Часто надо
задавать флаги, например внутри функций, с простыми и обычными именами,
такими как \texttt{loop} или \texttt{return}. Здесь можно использовать
так называемые «локальные» флаги, которые привязаны к конкретным
функциям. Их можно добавить с помощью команды \texttt{f.}:

\begin{verbatim}
[0x00003a04]> pd 10
│      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
│      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
│      0x00003a16      83f802         cmp eax, 2
│  .─< 0x00003a19      0f84880d0000   je 0x47a7
│  │   0x00003a1f      83f803         cmp eax, 3
│ .──< 0x00003a22      740e           je 0x3a32
│ ││   0x00003a24      83e801         sub eax, 1
│.───< 0x00003a27      0f84ed080000   je 0x431a
││││   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
││││   ; CODE XREF from main (0x3a22)
││╰──> 0x00003a32      be07000000     mov esi, 7
[0x00003a04]> f. localflag @ 0x3a32
[0x00003a04]> f.
0x00003a32 localflag   [main + 210]
[0x00003a04]> pd 10
│      0x00003a04      48c705c9cc21.  mov qword [0x002206d8], 0xffffffffffffffff ;
[0x2206d8:8]=0
│      0x00003a0f      c60522cc2100.  mov byte [0x00220638], 0     ; [0x220638:1]=0
│      0x00003a16      83f802         cmp eax, 2
│  .─< 0x00003a19      0f84880d0000   je 0x47a7
│  │   0x00003a1f      83f803         cmp eax, 3
│ .──< 0x00003a22      740e           je 0x3a32                    ; main.localflag
│ ││   0x00003a24      83e801         sub eax, 1
│.───< 0x00003a27      0f84ed080000   je 0x431a
││││   0x00003a2d      e8fef8ffff     call sym.imp.abort           ; void abort(void)
││││   ; CODE XREF from main (0x3a22)
││`──>  .localflag:
││││   ; CODE XREF from main (0x3a22)
││`──> 0x00003a32      be07000000     mov esi, 7
[0x00003a04]>
\end{verbatim}

\hypertarget{ux437ux43eux43dux44b-ux444ux43bux430ux433ux43eux432}{%
\subsubsection{Зоны
флагов}\label{ux437ux43eux43dux44b-ux444ux43bux430ux433ux43eux432}}

Radare2 реализует механизм зоны флагов (flagzone), позволяющий помечать
различные смещения на полосе прокрутки, чтобы упростить навигацию по
большим двоичным файлам. Установка зона флага по текущему смещению:

\begin{verbatim}
[0x00003a04]> fz flag-zone-name
\end{verbatim}

Установите \texttt{scr.scrollbar=1} и перейдите в визуальный режим, зона
флага появится на полосе прокрутки с правой стороны окна.

Посмотрите инструкцию - \texttt{fz?}.

\hypertarget{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux434ux430ux43dux43dux44bux445}{%
\subsection{Сохранение
данных}\label{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux434ux430ux43dux43dux44bux445}}

Radare может манипулировать загруженным двоичным файлом. Можно изменять
размер файла, перемещать и копировать/вставлять байты, вставлять новые
байты (перемещая данные в конец блока или файла) или просто
перезаписывать байты. Новые данные могут быть предоставлены в виде
строки специального вида, инструкций ассемблера, или они могут быть
считаны из другого файла.

Изменения размера файла --- команды \texttt{r}. Она принимает числовой
аргумент. Положительное значение задает новый размер файла.
Отрицательное значение приведет к усечению файла до текущей позиции
поиска за вычетом N байтов.

\begin{verbatim}
r 1024      ; установить размер файла равным 1024 байт
r -10 @ 33  ; вырезать десять байт по смещению 33
\end{verbatim}

Сохранение (запись в файл) байтов --- команда \texttt{w}. Она
поддерживает несколько форматов входных данных, таких как результаты
ассемблирования, дружественные к порядку байтов DWORD, файлы,
шестнадцатеричные файлы, широкие строки:

\begin{verbatim}
[0x00404888]> w?
Usage: w[x] [str] [<file] [<<EOF] [@addr]
| w[1248][+-][n]       увеличит/уменьшить на 1 байт, слово..
| w foobar             запись строки 'foobar'
| w0 [len]             запись 'len' байт значениями 0x00
| w6[de] base64/hex    запись base64-декодированной или -кодированной строки
| wa[?] push ebp       запись оп-кодов, разделеных символом ';' (окружите команду '"'-ками)
| waf f.asm            ассоциировать файл и результат записать
| waF f.asm            ассоциировать файл и результат записать, затем показать ('wx') оп-коды в шестнадцатеричном виде полученного кода
| wao[?] op            изменить оп-код (изменить условия переходов (jump), вставить nop и др.)
| wA[?] r 0            изменить/заменить оп-код по текущему смещению (смотрите wA?)
| wb 010203            заполнить текущий блок шестнадцатеричными данными циклично
| wB[-]0xVALUE         установить или сбросить биты заданным значением
| wc                   перечислить все изменения, относящиеся к записи
| wc[?][jir+-*?]       показать кэш команд undo/commit/reset/list (плагин io.cache)
| wd [off] [n]         сдублировать N байт (memcpy), расположенных в текущем смещении, также смотрите y?
| we[?] [nNsxX] [arg]  выполнять операции "запись" в режиме вставки (extend write)
| wf[fs] -|file        записать содержимое файла по текущему смещению
| wh r2                команды операционной системы whereis/which
| wm f0ff              установить двоичную маску в виде шестнадцатеричного кода для использования в последющих командах записи
| wo[?] hex            запись в блок при помощи операций. Инструкции - 'wo?' fmi
| wp[?] -|file         применить заплатку radare из файла. Инструкции - wp? fmi
| wr 10                запись десяти случайных байтов
| ws pstring           запись одного байта длины и затем строки
| wt[f][?] file [sz]   запись в файл (с текущего смещения, размером blocksize или sz байт)
| wts host:port [sz]   отправить данные на удаленную рабочую станцию host:port по tcp://
| ww foobar            запись wide-строки 'f\x00o\x00o\x00b\x00a\x00r\x00'
| wx[?][fs] 9090       запись двух intel-овских оп-кодов (с wxfile или wxseek)
| wv[?] eip+34         запись 32-64-товых значений с учетом cfg.bigendian
| wz string            запись строки, заканчивающейся нулем (аналогично w + \x00)
\end{verbatim}

Примеры:

\begin{verbatim}
 [0x00000000]> wx 123456 @ 0x8048300
 [0x00000000]> wv 0x8048123 @ 0x8049100
 [0x00000000]> wa jmp 0x8048320
\end{verbatim}

\hypertarget{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux43fux43eux432ux435ux440ux445-ux441ux443ux449ux435ux441ux442ux432ux443ux44eux449ux438ux445-ux434ux430ux43dux43dux44bux445}{%
\subsubsection{Сохранение поверх существующих
данных}\label{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux43fux43eux432ux435ux440ux445-ux441ux443ux449ux435ux441ux442ux432ux443ux44eux449ux438ux445-ux434ux430ux43dux43dux44bux445}}

Команда \texttt{wo} (write over) имеет множество подкоманд, каждая
комбинирует существующие данные с новыми данными. Команда применяется к
текущему блоку. Поддерживаемые операторы включают XOR, ADD, SUB,
\ldots{}

\begin{verbatim}
[0x4A13B8C0]> wo?
|Usage: wo[asmdxoArl24] [hexpairs] @ addr[:bsize]
|Примеры:
|  wox 0x90   ; выполнить операцию xor 0x90 с текущим блоком
|  wox 90     ; выполнить операцию xor 0x90 с текущим блоком
|  wox 0x0203 ; выполнить операцию xor 0203 с текущим блоком
|  woa 02 03  ; добавить [0203][0203][...] к текущему блоку
|  woe 02 03  ; создать последовательность от 2 до 255 с шагом 3
|Поддерживаемые операции:
|  wow  ==  запись циклического значения (псевдоним для 'wb')
|  woa  +=  сложение
|  wos  -=  вычитание
|  wom  *=  умножение
|  wod  /=  деление
|  wox  ^=  xor (исключающее или)
|  woo  |=  or (или)
|  woA  &=  and (и)
|  woR  сгенерировать случайные байты (псевдоним для 'wr $b')
|  wor  >>= сдвиг вправо
|  wol  <<= сдвиг влево
|  wo2  2=  2-байтовый обмен
|  wo4  4=  4-байтовый обмен
\end{verbatim}

Возможна реализация алгоритмов шифрования с использованием команд ядра
radare и \texttt{wo}. Пример сеанса, выполняющего xor(90) + add(01, 02):

\begin{verbatim}
[0x7fcd6a891630]> px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  4889 e7e8 6839 0000 4989 c48b 05ef 1622
0x7fcd6a891640  005a 488d 24c4 29c2 5248 89d6 4989 e548
0x7fcd6a891650  83e4 f048 8b3d 061a 2200 498d 4cd5 1049
0x7fcd6a891660  8d55 0831 ede8 06e2 0000 488d 15cf e600
[0x7fcd6a891630]> wox 90
[0x7fcd6a891630]> px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d819 7778 d919 541b 90ca d81d c2d8 1946
0x7fcd6a891640  1374 60d8 b290 d91d 1dc5 98a1 9090 d81d
0x7fcd6a891650  90dc 197c 9f8f 1490 d81d 95d9 9f8f 1490
0x7fcd6a891660  13d7 9491 9f8f 1490 13ff 9491 9f8f 1490
[0x7fcd6a891630]> woa 01 02
[0x7fcd6a891630]> px
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F
0x7fcd6a891630  d91b 787a 91cc d91f 1476 61da 1ec7 99a3
0x7fcd6a891640  91de 1a7e d91f 96db 14d9 9593 1401 9593
0x7fcd6a891650  c4da 1a6d e89a d959 9192 9159 1cb1 d959
0x7fcd6a891660  9192 79cb 81da 1652 81da 1456 a252 7c77
\end{verbatim}

\hypertarget{ux43cux430ux441ux448ux442ux430ux431ux438ux440ux43eux432ux430ux43dux438ux435}{%
\subsection{Масштабирование}\label{ux43cux430ux441ux448ux442ux430ux431ux438ux440ux43eux432ux430ux43dux438ux435}}

Масштабирование --- это режим отображения информации, позволяющий
получить глобальное представление всего файла или карты памяти на одном
экране. В этом режиме каждый байт картинки представляет блок
\texttt{file\_size/block\_size} байт файла. Используйте команду
\texttt{pz} или просто \texttt{Z} в визуальном режиме, чтобы переключить
режим масштабирования.

Для быстрой прокрутки в режиме масштабирования можно использовать
курсор. Повторное нажатие \texttt{z} приведет к увеличению масштаба в
текущем положении курсора.

\begin{verbatim}
[0x004048c5]> pz?
|Usage: pz [len] печать масштабированных блоков размером filesize/N
| e zoom.maxsz   макимальный размер блока
| e zoom.from    начальный адрес
| e zoom.to      конечный адрес
| e zoom.byte    указать, как вычислять каждый байт
| pzp            количество печатных символов
| pzf            подсчитать количество флагов в блоке
| pzs            строки в заданном диапазоне
| pz0            число байт равных '0'
| pzF            число байт равных 0xFF
| pze            вычислить энтропию и расширить на диапазон 0-255
| pzh            вывести начало (значение первых байтов); это режим по умолчанию
\end{verbatim}

Рассмотрим несколько примеров:

\begin{verbatim}
[0x08049790]> e zoom.byte=h
[0x08049790]> pz // или по умолчанию pzh
0x00000000  7f00 0000 e200 0000 146e 6f74 0300 0000
0x00000010  0000 0000 0068 2102 00ff 2024 e8f0 007a
0x00000020  8c00 18c2 ffff 0080 4421 41c4 1500 5dff
0x00000030  ff10 0018 0fc8 031a 000c 8484 e970 8648
0x00000040  d68b 3148 348b 03a0 8b0f c200 5d25 7074
0x00000050  7500 00e1 ffe8 58fe 4dc4 00e0 dbc8 b885
\end{verbatim}

\begin{verbatim}
[0x08049790]> e zoom.byte=p
[0x08049790]> pz // или pzp
0x00000000  2f47 0609 070a 0917 1e9e a4bd 2a1b 2c27
0x00000010  322d 5671 8788 8182 5679 7568 82a2 7d89
0x00000020  8173 7f7b 727a 9588 a07b 5c7d 8daf 836d
0x00000030  b167 6192 a67d 8aa2 6246 856e 8c9b 999f
0x00000040  a774 96c3 b1a4 6c8e a07c 6a8f 8983 6a62
0x00000050  7d66 625f 7ea4 7ea6 b4b6 8b57 a19f 71a2
\end{verbatim}

\begin{verbatim}
[0x08049790]> eval zoom.byte = flags
[0x08049790]> pz // или pzf
0x00406e65  48d0 80f9 360f 8745 ffff ffeb ae66 0f1f
0x00406e75  4400 0083 f801 0f85 3fff ffff 410f b600
0x00406e85  3c78 0f87 6301 0000 0fb6 c8ff 24cd 0026
0x00406e95  4100 660f 1f84 0000 0000 0084 c074 043c
0x00406ea5  3a75 18b8 0500 0000 83f8 060f 95c0 e9cd
0x00406eb5  feff ff0f 1f84 0000 0000 0041 8801 4983
0x00406ec5  c001 4983 c201 4983 c101 e9ec feff ff0f
\end{verbatim}

\begin{verbatim}
[0x08049790]> e zoom.byte=F
[0x08049790]> pO // или pzF
0x00000000  0000 0000 0000 0000 0000 0000 0000 0000
0x00000010  0000 2b5c 5757 3a14 331f 1b23 0315 1d18
0x00000020  222a 2330 2b31 2e2a 1714 200d 1512 383d
0x00000030  1e1a 181b 0a10 1a21 2a36 281e 1d1c 0e11
0x00000040  1b2a 2f22 2229 181e 231e 181c 1913 262b
0x00000050  2b30 4741 422f 382a 1e22 0f17 0f10 3913
\end{verbatim}

Масштабирование можно ограничить диапазоном байтов, и не показывать всё
пространство, --- переменные среды \texttt{zoom.from} и
\texttt{zoom.to}:

\begin{verbatim}
[0x00003a04]> e? zoom.
zoom.byte:  Функция обратного вызова для вычисления каждого байта (смотрите инструкцию в pz?)
zoom.from:  Начальный адрес блока для масштабирования
zoom.in:    Границы для масштабирования
zoom.maxsz: Максимальный размер блока для масштабирования
zoom.to:    Конечный адрес для масштабирования
[0x00003a04]> e zoom.
zoom.byte = h
zoom.from = 0
zoom.in = io.map
zoom.maxsz = 512
zoom.to = 0
\end{verbatim}

\hypertarget{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435ux432ux441ux442ux430ux432ux43aux430}{%
\subsection{Сохранение/Вставка}\label{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435ux432ux441ux442ux430ux432ux43aux430}}

Radare2 имеет свой буфер обмена для сохранения и загрузки оттуда частей
памяти, взятых из текущего объекта ввода-вывода. Содержимым буфера
обмена можно манипулировать при помощи команды \texttt{y} (yank).

Двумя основными операциями являются:

\begin{itemize}
\tightlist
\item
  Копирование (yank),
\item
  Вставка (paste).
\end{itemize}

Операция yank загружает (вытаскивает) N байт, заданных аргументом, в
буфер обмена. Затем используя команду \texttt{yy}, делаем вставку
сохраненного ранее блока в файл. Можно загружать/вставлять (yank/paste)
байты в визуальном режиме, выбирая их в режиме курсора (\texttt{Vc}), а
затем используя привязки клавиш \texttt{y} и \texttt{Y}, являющиеся
псевдонимами для команд \texttt{y} и \texttt{yy} интерфейса командной
строки.

\begin{verbatim}
[0x00000000]> y?
Usage: y[ptxy] [len] [[@]addr]   # Посмотрите wd? memcpy то же самое, что и 'yf'.
| y!              открытие cfg.editor для редактирования содержания буфера обмена
| y 16 0x200      копировать 16 байт в буфер обмена с адреса 0x200
| y 16 @ 0x200    копировать 16 байт в буфер обмена с адреса 0x200
| y 16            копировать 16 байт в буфер обмена
| y               показать информацию о yank-буфере (srcoff len байт)
| y*              печать в виде команд r2 того, что будет загружено из буфера
| yf 64 0x200     скопировать 64 байта из файла по смещению 0x200
| yfa file copy   скопировать все байты из файла (открывает ввод-вывод на запись, w/)
| yfx 10203040    загрузить из шестнадцатеричного кода (то же, что и ywx)
| yj              показать в виде формата JSON содержимого из буфера обмена
| yp              печать содержания буфера обмена
| yq              печать содержания буфера обмена в шестнадцатеричном виде
| ys              печать содержания буфера обмена в виде строки
| yt 64 0x200     коировать 64 байта с текущего смещения по адресу 0x200
| ytf file        выдать дамп содержания буфера обмена в заданный файл
| yw hello world  загрузить из строки
| ywx 10203040    загрузить из шестнадцатеричного кода (то же, что и yfx)
| yx              выдать содержимого буфера обмена а шестнадцатеричном виде
| yy 0x3344       вставить в буфер обмена
| yz [len]        копировать строку, завершающуюся нулем, в буфер обмена, учитывая ограничения blocksize
\end{verbatim}

Пример сессии:

\begin{verbatim}
[0x00000000]> s 0x100    ; установить смещение 0x100
[0x00000100]> y 100      ; вытащить в буфер обмена 100 байт с текущего смещения
[0x00000200]> s 0x200    ; установить смещение 0x200
[0x00000200]> yy         ; вставить 100 байт из буфера обмена
\end{verbatim}

Можно выполнить сохранение и вставку в одной строке, используя команду
\texttt{yt} (yank-to). Вот её синтаксис:

\begin{verbatim}
[0x4A13B8C0]> x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, ffff 81c3 eea6 0100 8b83 08ff ............
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).

[0x4A13B8C0]> yt 8 0x4A13B8CC @ 0x4A13B8C0

[0x4A13B8C0]> x
   offset   0 1  2 3  4 5  6 7  8 9  A B  0123456789AB
0x4A13B8C0, 89e0 e839 0700 0089 c7e8 e2ff ...9........
0x4A13B8CC, 89e0 e839 0700 0089 8b83 08ff ...9........
0x4A13B8D8, ffff 5a8d 2484 29c2           ..Z.$.).
\end{verbatim}

\hypertarget{ux441ux440ux430ux432ux43dux435ux43dux438ux435-ux431ux430ux439ux442ux43eux432}{%
\subsection{Сравнение
байтов}\label{ux441ux440ux430ux432ux43dux435ux43dux438ux435-ux431ux430ux439ux442ux43eux432}}

В реверс-инжениринге часто решаются задачи поиска различий между двумя
двоичными файлами, выявления измененных байтов, сравнения графов,
представляющих результаты анализа кода, а также выполнение других
операций сравнения. Сравнение реализуется при помощи программы radiff2:

\begin{verbatim}
$ radiff2 -h
\end{verbatim}

Внутри r2 функциональные возможности, предоставляемые radiff2, доступны
при помощи набора команд \texttt{c}.

Команда \texttt{c} (сокращение от «compare») позволяет сравнивать
массивы байтов из разных источников. Команда принимает ввод в нескольких
форматах, а затем сравнивает его со значениями, найденными в текущем
смещении.

\begin{verbatim}
[0x00404888]> c?
Usage: c[?dfx] [argument]   # Сравнение
| c [string]               Сравнение обычной строки со строкой с escape-последовательностями
| c* [string]              То же, что выше, но печатая результат в виде команд r2
| c1 [addr]                Сравнить 8 бит в текущем смещении
| c2 [value]               Сравнить со словом, полученным в результате вычисления выражения
| c4 [value]               Сравнить с двойным словом, полученным в результате вычисления выражения
| c8 [value]               Сравнить с quadword, полученным в результате вычисления выражения
| cat [file]               Показать содержимое файла (смотрите pwd, ls)
| cc [at]                  Сравнить две колонки шестнадцатеричных дампов, ограниченных размером блока
| ccc [at]                 То же, что выше, но показывая измененные строки
| ccd [at]                 Сравнить два столбца дизассемблирования, ограниченных размером блока
| ccdd [at]                Сравнить вывод декомпилятора (e cmd.pdc=pdg|pdd)
| cf [file]                Сравнить с содержимым файлов по текущему смещению
| cg[?] [o] [file]         Сравнение графов текущего файла и файла [file]
| cu[?] [addr] @at         Сравнить дампы памяти по адресу $$ и dst, используя формат unified diff
| cud [addr] @at           Unified diff disasm from $$ and given address
| cv[1248] [hexpairs] @at  Сравнить 1,2,4,8-байтовые последовательности (silent return in $?)
| cV[1248] [addr] @at      Сравнить 1,2,4,8-байтовые последовательности, задаваемые адресом (silent, return in $?)
| cw[?] [us?] [...]        Сравнить watcher-ов памяти
| cx [hexpair]             Сравнить строки шестнадцатеричных кодов (ипользуйте '.' для обозначения позиции в шпблоне)
| cx* [hexpair]            Сравнить строки шестнадцатеричных кодов (вывод в виде команд r2)
| cX [addr]                Аналогично 'cc', но используя hexdiff
| cd [dir]                 Перейти в директорий
| cl|cls|clear             Стереть все с экрана, (clear0 - перейти на 0, и только 0)
\end{verbatim}

Чтобы сравнить содержимое памяти по текущему смещению с заданной строкой
шестнадцатеричных значений используйте\texttt{cx}:

\begin{verbatim}
[0x08048000]> p8 4
7f 45 4c 46

[0x08048000]> cx 7f 45 90 46
Compare 3/4 equal bytes
0x00000002 (byte=03)   90 ' '  ->  4c 'L'
[0x08048000]>
\end{verbatim}

Еще одна команда группы \texttt{с} - это \texttt{cc} (compare code).
Сравнение последовательности байтов с последовательностью в памяти по
заданному адресу:

\begin{verbatim}
[0x4A13B8C0]> cc 0x39e8e089 @ 0x4A13B8C0
\end{verbatim}

Сравнение содержимого двух функций, указанных по именам:

\begin{verbatim}
[0x08049A80]> cc sym.main2 @ sym.main
\end{verbatim}

Команда \texttt{с8} сравнивает quadword по текущему смещению (в
приведенном ниже примере 0x00000000) с математическим выражением:

\begin{verbatim}
[0x00000000]> c8 4

Compare 1/8 equal bytes (0%)
0x00000000 (byte=01)   7f ' '  ->  04 ' '
0x00000001 (byte=02)   45 'E'  ->  00 ' '
0x00000002 (byte=03)   4c 'L'  ->  00 ' '
\end{verbatim}

Параметр может быть математическим выражением, в котором используются
имена флагов и все, что разрешено в выражении:

\begin{verbatim}
[0x00000000]> cx 7f469046

Compare 2/4 equal bytes
0x00000001 (byte=02)   45 'E'  ->  46 'F'
0x00000002 (byte=03)   4c 'L'  ->  90 ' '
\end{verbatim}

Можно использовать команду сравнения, чтобы найти различия между текущим
блоком и файлом, ранее сброшенным на диск:

\begin{verbatim}
r2 /bin/true
[0x08049A80]> s 0
[0x08048000]> cf /bin/true
Compare 512/512 equal bytes
\end{verbatim}

\hypertarget{ux431ux430ux437ux430-ux434ux430ux43dux43dux44bux445-ux441ux442ux440ux43eux43a}{%
\section{База данных
строк}\label{ux431ux430ux437ux430-ux434ux430ux43dux43dux44bux445-ux441ux442ux440ux43eux43a}}

Аббревиатура SDB расшифровывается как String DataBase. SDB - это база
данных ``ключ-значение'', работающая только со строками (автор -
pancake). Она используется во многих частях r2, база данных хранится на
диске и в памяти, является небольшой и быстрой для управления ---
хеш-таблица на стероидах. Дисковое представление реализовано на основе
djb cdb, поддерживающей JSON и интроспекцию массивов. Также есть
библиотека sdbtypes для vala, реализующая несколько структур данных
поверх SDB или memcache.

SDB поддерживает

\begin{itemize}
\tightlist
\item
  пространства имен (несколько путей sdb),
\item
  атомарную синхронизацию базы данных,
\item
  привязку для vala, luvit, newlisp и nodejs,
\item
  интерфейс командной строки для баз данных sdb,
\item
  клиент и сервер memcache с бэкэндом sdb,
\item
  массивы (синтаксический сахар),
\item
  интеграцию с json.
\end{itemize}

\hypertarget{ux43fux440ux438ux43cux435ux440-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f}{%
\subsection{Пример
использования}\label{ux43fux440ux438ux43cux435ux440-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f}}

Создание базы данных!

\begin{verbatim}
$ sdb d hello=world
$ sdb d hello
world
\end{verbatim}

Использование массивов:

\begin{verbatim}
$ sdb - '[]list=1,2' '[0]list' '[0]list=foo' '[]list' '[+1]list=bar'
1
foo
2
foo
bar
2
\end{verbatim}

Проверим работоспособность json:

\begin{verbatim}
$ sdb d g='{"foo":1,"bar":{"cow":3}}'
$ sdb d g?bar.cow
3
$ sdb - user='{"id":123}' user?id=99 user?id
99
\end{verbatim}

Используя командную строку без дисковой базы данных:

\begin{verbatim}
$ sdb - foo=bar foo a=3 +a -a
bar
4
3

$ sdb -
foo=bar
foo
bar
a=3
+a
4
-a
3
\end{verbatim}

Удаление базы данных

\begin{verbatim}
$ rm -f d
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux43dux435ux43dux438ux44f-ux431ux430ux437ux44b-ux434ux430ux43dux43dux44bux445}{%
\subsection{Применения базы
данных}\label{ux43fux440ux438ux43cux435ux43dux435ux43dux438ux44f-ux431ux430ux437ux44b-ux434ux430ux43dux43dux44bux445}}

SDB позволяет хранить данные внутри сеансов radare2! Рассмотрим простой
двоичный файл и проверим, что уже \emph{SDB}-изировано.

\begin{verbatim}
$ cat test.c
int main(){
    puts("Hello world\n");
}
$ gcc test.c -o test
\end{verbatim}

\begin{verbatim}
$ r2 -A ./test
[0x08048320]> k **
bin
anal
syscall
debug
\end{verbatim}

\begin{verbatim}
[0x08048320]> k bin/**
fd.6
[0x08048320]> k bin/fd.6/*
archs=0:0:x86:32
\end{verbatim}

Файл, соответствующий шестому дескриптору файла, является двоичным
файлом x86\_32.

\begin{verbatim}
[0x08048320]> k anal/meta/*
meta.s.0x80484d0=12,SGVsbG8gd29ybGQ=
[...]
[0x08048320]> ?b64- SGVsbG8gd29ybGQ=
Hello world
\end{verbatim}

Строки хранятся в кодировке base64.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ux435ux449ux435-ux43fux440ux438ux43cux435ux440ux44b}{%
\subsection{Еще
примеры}\label{ux435ux449ux435-ux43fux440ux438ux43cux435ux440ux44b}}

Пространства имен

\begin{verbatim}
k **
\end{verbatim}

Подпространства имен

\begin{verbatim}
k anal/**
\end{verbatim}

Ключи

\begin{verbatim}
k *
k anal/*
\end{verbatim}

Задание ключа

\begin{verbatim}
k foo=bar
\end{verbatim}

Получение значения ключа

\begin{verbatim}
k foo
\end{verbatim}

Список всех системных вызовов

\begin{verbatim}
k syscall/*~^0x
\end{verbatim}

Список всех комментариев

\begin{verbatim}
k anal/meta/*~.C.
\end{verbatim}

Показать комментарий, ассоциированный с заданным смещением:

\begin{verbatim}
k %anal/meta/[1]meta.C.0x100005000
\end{verbatim}

\hypertarget{dietline}{%
\section{Dietline}\label{dietline}}

Radare2 поставляется с
\href{https://en.wikipedia.org/wiki/GNU_Readline}{readline}-подобной
командной строкой ввода, реализованная на основе ``бережливого''
принципа навигации по истории команд и редактирования содержимого. Она
позволяет пользователям передвигать курсор, перебирать предыдущие
команды, обеспечивает автодополнение. Благодаря портативности Radare2,
Dietline обеспечивает единый пользовательский интерфейс для всех
поддерживаемых платформ. Интерфейс используется во всех подоболочках
Rarade2: в основной командной строке, оболочке SDB, визуальных
подсказках и подсказках адреса смещения. Также реализованы наиболее
распространенные функции и сочетания клавиш, совместимые с GNU Readline.

Dietline поддерживает два основных режима конфигурации: режимы Emacs и
Vi. Он также поддерживает знаменитый \texttt{Ctrl-R}, обратный поиск по
истории. Клавиша \texttt{TAB} позволяет прокручивать варианты
автодополнения.

\hypertarget{ux430ux432ux442ux43eux434ux43eux43fux43eux43bux43dux435ux43dux438ux435}{%
\section{Автодополнение}\label{ux430ux432ux442ux43eux434ux43eux43fux43eux43bux43dux435ux43dux438ux435}}

В каждой оболочке и Radare2 поддерживается автодополнение команд. Есть
несколько режимов --- файлы, флаги и ключи/пространства имен SDB.
Простой способ выбора возможных вариантов завершения --- прокручиваемый
всплывающий виджет. Он включается с помощью \texttt{scr.prompt.popup},
просто установите его в \texttt{true}.

\hypertarget{ux440ux435ux436ux438ux43c-emacs-ux43fux43e-ux443ux43cux43eux43bux447ux430ux43dux438ux44e}{%
\section{Режим Emacs (по
умолчанию)}\label{ux440ux435ux436ux438ux43c-emacs-ux43fux43e-ux443ux43cux43eux43bux447ux430ux43dux438ux44e}}

По умолчанию режим dietline совместим с привязками клавиш режима
readline, подобного Emacs. Таким образом, активны:

\hypertarget{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435}{%
\subsection{Перемещение}\label{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435}}

\begin{itemize}
\tightlist
\item
  \texttt{Ctrl-a} - перейти в начало строки,
\item
  \texttt{Ctrl-e} - перейти в конец строки,
\item
  \texttt{Ctrl-b} - переместиться на один символ назад,
\item
  \texttt{Ctrl-f} - переместиться на один символ вперед.
\end{itemize}

\hypertarget{ux443ux434ux430ux43bux435ux43dux438ux435}{%
\subsection{Удаление}\label{ux443ux434ux430ux43bux435ux43dux438ux435}}

\begin{itemize}
\tightlist
\item
  \texttt{Ctrl-w} - удалить предыдущее слово,
\item
  \texttt{Ctrl-u} - удалить всю линию,
\item
  \texttt{Ctrl-h} - удалить символ слева,
\item
  \texttt{Ctrl-d} - удалить символ справа,
\item
  \texttt{Alt-d} - удалить символ после курсора.
\end{itemize}

\hypertarget{killing-and-yanking}{%
\subsection{Killing and Yanking}\label{killing-and-yanking}}

\begin{itemize}
\tightlist
\item
  \texttt{Ctrl-k} - удалить текст с текущей точки до конца строки,
\item
  \texttt{Ctrl-x} - удалить текст с начала строки до текущей позиции,
\item
  \texttt{Ctrl-t} - удалить от текущей точки до конца текущего слова, а
  если позиция находиться между словами, то до конца следующего слова.
\item
  \texttt{Ctrl-w} - удалить часть слова левее от текущей позиции,
  используя пробел в качестве ограничителя. Удаленная часть сохраняется
  в специальный буфер,
\item
  \texttt{Ctrl-y} - вытащить из буфера удаленных строк и поместить в
  текущую позицию,
\item
  \texttt{Ctrl-{]}} - сдвинуть буфер на одну позицию, и вытащить оттуда
  новую строку. Вращение можно делать только если предыдущая команда
  была yank или yank-pop.
\end{itemize}

\hypertarget{ux438ux441ux442ux43eux440ux438ux44f}{%
\subsection{История}\label{ux438ux441ux442ux43eux440ux438ux44f}}

\begin{itemize}
\tightlist
\item
  \texttt{Ctrl-r} - поиск в обратном направлении в истории.
\end{itemize}

\hypertarget{ux440ux435ux436ux438ux43c-vi}{%
\section{Режим Vi}\label{ux440ux435ux436ux438ux43c-vi}}

Radare2 также настраивается на режим vi, подключаемый при помощи
\texttt{scr.prompt.vi}. В этом режиме доступны сочетания клавиш:

\hypertarget{ux432ux445ux43eux434-ux432-ux43aux43eux43cux430ux43dux434ux43dux44bux435-ux440ux435ux436ux438ux43cux44b}{%
\subsection{Вход в командные
режимы}\label{ux432ux445ux43eux434-ux432-ux43aux43eux43cux430ux43dux434ux43dux44bux435-ux440ux435ux436ux438ux43cux44b}}

\begin{itemize}
\tightlist
\item
  \texttt{ESC} - вход в режим управления,
\item
  \texttt{i} - вход в режим вставки.
\end{itemize}

\hypertarget{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-1}{%
\subsection{Перемещение}\label{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-1}}

\begin{itemize}
\tightlist
\item
  \texttt{j} - выполняет функцию стрелки вверх,
\item
  \texttt{k} - выполняет функцию стрелки вниз,
\item
  \texttt{a} - переместить курсор вперед и перейти в режим вставки,
\item
  \texttt{I} - перейти в начало строки и перейти в режим вставки,
\item
  \texttt{A} - перейти в конец строки и перейти в режим вставки,
\item
  \texttt{\^{}} - перейти в начало строки,
\item
  \texttt{0} - перейти в начало строки,
\item
  \texttt{\$} - перейти в конец строки,
\item
  \texttt{h} - передвинуться на одну позицию назад,
\item
  \texttt{l} - передвинуться на одну позицию вперед.
\end{itemize}

\hypertarget{ux443ux434ux430ux43bux435ux43dux438ux435-ux438-ux432ux441ux442ux430ux432ux43aux430}{%
\subsection{Удаление и
вставка}\label{ux443ux434ux430ux43bux435ux43dux438ux435-ux438-ux432ux441ux442ux430ux432ux43aux430}}

\begin{itemize}
\tightlist
\item
  \texttt{x} - вырезает символ,
\item
  \texttt{dw} - удалить текущее слово,
\item
  \texttt{diw} - удалить текущее слово,
\item
  \texttt{db} - удалить предыдущее слово,
\item
  \texttt{D} - удалить строку целиком,
\item
  \texttt{dh} - удалить символ слева,
\item
  \texttt{dl} - удалить символ справа,
\item
  \texttt{d\$} - удалить текст от текущей позиции до конца строки,
\item
  \texttt{d\^{}} - удалить текст от текущей позиции до начала строки,
\item
  \texttt{de} - удалить текст от текущей позиции до конца слова, а если
  позиция находиться между словами, то до конца следующего слова.
\item
  \texttt{p} - вытащить из буфера удаленных строк и поместить в текущую
  позицию,
\item
  \texttt{c} - работают аналогично командам группы d, но переходит в
  режим вставки в конце операции, если перед командой вставить число, то
  команда будет выполнена несколько раз.
\end{itemize}

Если непонятно, в каком режиме vi вы находитесь, установите
\texttt{scr.prompt.mode=true}, при этом будет происходить обновление
цвета командной строки в зависимости от режима vi.

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c}{%
\section{Визуальный
режим}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c}}

Визуальный режим является более удобной альтернативой интерфейсу
командной строки radare2. Он обеспечивает удобную навигацию,
поддерживает режим курсора для выбора байтов и предлагает множество
привязок клавиш для упрощения использования отладчика. Чтобы войти в
визуальный режим, используйте команду \texttt{V}. Чтобы выйти из него
обратно в командную строку, нажмите клавишу \texttt{q}.

\hypertarget{ux43dux430ux432ux438ux433ux430ux446ux438ux44f}{%
\subsection{Навигация}\label{ux43dux430ux432ux438ux433ux430ux446ux438ux44f}}

Навигация может осуществляться с помощью HJKL, клавиш со стрелками и
PgUp/PgDown. Также работают клавиши Home и End. Как в Vim, действия
можно повторять, предваряя навигационную клавишу номером, например,
\texttt{5j} будет двигаться вниз на пять строк, а \texttt{2l} будет
перемещаться на два символа вправо.

\begin{figure}
\centering
\includegraphics{visualmode.png}
\caption{Визуальный режим}
\end{figure}

\hypertarget{ux440ux435ux436ux438ux43cux44b-ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux44f-ux43fux430ux43dux435ux43bux438}{%
\subsection{режимы отображения
(панели)}\label{ux440ux435ux436ux438ux43cux44b-ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux44f-ux43fux430ux43dux435ux43bux438}}

Визуальный режим использует «режимы отображения», представляемые
панелями, содержимое которых настраивается. По умолчанию это:

↻ \textbf{Панель дампа} -\textgreater{} \textbf{Панель
дизассемблирования} → \textbf{Панель отладки} → \textbf{Панель дампа
Word} → \textbf{Панель дампа без Hex} → \textbf{Панель цветовой разметки
Op-анализа} → \textbf{Панель аннотированного дампа} (Панели дампов
отображают байты в шестнадцатеричном виде)↺.

Обратите внимание, что верхняя часть панели содержит используемую сейчас
команду, например, для режима дизассемблирования:

\begin{verbatim}
[0x00404890 16% 120 /bin/ls]> pd $r @ entry0
\end{verbatim}

\hypertarget{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux439}{%
\subsection{Получение
инструкций}\label{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux439}}

Чтобы просмотреть справку по всем ключевым функциям, определенным для
визуального режима, нажмите \texttt{?}:

\begin{verbatim}
Справка по визуальному режиму:
 ?        показать эту справку
 ??       показать удобный для пользователя hud
 %        в режиме курсора находит подходящую пару или переключает автоблокировку
 @        перерисовывать экран каждые 1 с (многопользовательский вид)
 ^        установить смещение на начало функции
 !        войти в режим визуальных панелей
 _        введите флаг/комментарий/функции/.. hud (то же, что и VF_)
 =        задать cmd.vprompt (верхняя строка)
 |        задать cmd.cprompt (правый столбец)
 .        установить смещение на значения программноммного счетчика
 \        переключить режим визуального разделения
 "        переключите режим столбца (использует pC..)
 /        в режиме курсора поиск в текущем блоке
 :cmd     выполнить команду радара
 ;[-]cmt  добавить/удалить комментарий
 0        установить смещение на начало текущей функции
 [1-9]    следовать jmp/call, обозначенному ярлыком (например ;[1])
 ,file    add a link to the text file
 /*+-[]   изменить размер блока, [] = изменить размер hex.cols
 </>      поиск в соответствии с размером блока (поиск курсора в режиме курсора)
 a/A      (a)ссемблировать код, в визуальном режиме - (A)ссемблер
 b        просматривать символы, флаги, конфигурации, классы, ...
 B        включить/выключить точку останова
 c/C      переключатель (c)ursor и (C)olors
 d[f?]    определить функцию, данные, код, ..
 D        войти в режим визуального сравнения (установить diff.from/to)
 e        редактирование конфигурационных переменных среды
 f/F      устанавить/удалить или просматривать флаги. f - удаление, F - просмотр, ...
 gG       установить смещение на начало и конец файла (0-$s)
 hjkl     перемещение (или HJKL) (влево-вниз-вверх-вправо)
 i        вставка шеснадцатеричного кода или строки (in hexdump), используйте tab для переключения
 mK/'K    пометить/перейти к ключу (любой ключ)
 M        обзор подмонтированной файловой системы
 n/N      установить смещение на следующую/предыдущую функцию/флаг/хит (scr.nkey)
 g        установить смещение на заданное смещение
 O        переключить режимы отображения asm.pseudo и asm.esil
 p/P      переключение режимов отображения (hex, disasm, debug, words, buf)
 q        возврат к командной строке радара
 r        обновить экран / в режиме курсора - просмотр комментариев
 R        слуйчным образом перенастроить палитру цветов (ecr)
 sS       step / step over
 t        просмотр типов
 T        вход в текстовый журнал чата консоли (TT)
 uU       undo/redo установки смещения
 v        меню анализа кода функций/переменных (визуальный режим)
 V        (V)просмотр графа управления с использованием cmd.graph (agv?)
 wW       установить курсор на следующее/предыдущее слово
 xX       показывает xrefs/refs текущей функции из/в данные/код
 yY       копирование и вставка выбранного региона
 z        fold/unfold комментариев в дизассемблерировании
 Z        включение/выключение масштабирования
 Enter    установить адрес на цель jump/call

Функциональные клавиши: (см. 'e key.'), по умолчанию:
  F2      включить/выключить точку останова,
  F4      выполнить до курсора,
  F7      single step (шаг отладки),
  F8      step over (шаг, не входя в вызов),
  F9      continue (продолжить).
\end{verbatim}

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440}{%
\section{Визуальный
дизассемблер}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440}}

\hypertarget{ux43dux430ux432ux438ux433ux430ux446ux438ux44f-1}{%
\subsection{Навигация}\label{ux43dux430ux432ux438ux433ux430ux446ux438ux44f-1}}

Перемещение внутри дизассемблирования осуществляется с помощью клавиш со
стрелками или \texttt{hjkl}. Используйте \texttt{g} для смещения
непосредственно к флагу или адресу, введите его в командной строки:
\texttt{{[}offset{]}\textgreater{}}. Переходы по jump и call - клавиши
\texttt{цифр} на клавиатуре \texttt{{[}0-9{]}}, а также номер справа в
окне дизассемблирования. В этом примере ввод \texttt{1} на клавиатуре
будет следовать за вызовом \texttt{sym.imp.\_\_libc\_start\_main} и,
следовательно, устанавливать смещение на адрес этого символа.

\begin{verbatim}
0x00404894      e857dcffff     call sym.imp.__libc_start_main ;[1]
\end{verbatim}

Вернуться на предыдущее смещение - клавиша \texttt{u}, \texttt{U} -
повторение поиска.

\hypertarget{ux43aux43eux43cux430ux43dux434ux430-d---ux43eux43fux440ux435ux434ux435ux43bux438ux442ux44c}{%
\subsection{\texorpdfstring{Команда \texttt{d} -
определить}{Команда d - определить}}\label{ux43aux43eux43cux430ux43dux434ux430-d---ux43eux43fux440ux435ux434ux435ux43bux438ux442ux44c}}

Клавиша \texttt{d} используется для изменения типа данных текущего
блока, доступно несколько основных типов/структур, а также более
продвинутый с использованием шаблона \texttt{pf} :

\begin{verbatim}
d → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → b
0x004048f7 .byte 0x48
d → B
0x004048f7 .word 0xc148
d → d
0x004048f7 hex length=165 delta=0
0x004048f7  48c1 e83f 4801 c648 d1fe 7415 b800 0000
...
\end{verbatim}

Для улучшения удобочитаемости кода можно изменить способ представления
числовых значений radare2 при дизассемблировании, по умолчанию
большинство вариантов отображают числовое значение как
шестнадцатеричное. Иногда надо числа представлять в десятичной, двоичной
системах счисления и даже печатать пользовательские константы. Чтобы
изменить формат значения, используется \texttt{d}, за которым следует
\texttt{i}, затем надо выбрать, в какой системе счисления работать, это
эквивалентно \texttt{ahi}:

\begin{verbatim}
d → i → ...
0x004048f7      48c1e83f       shr rax, 0x3f
d → i →  10
0x004048f7      48c1e83f       shr rax, 63
d → i →  2
0x004048f7      48c1e83f       shr rax, '?'
\end{verbatim}

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43aux443ux440ux441ux43eux440ux430-ux434ux43bux44f-ux432ux441ux442ux430ux432ux43aux438ux438ux441ux43fux440ux430ux432ux43bux435ux43dux438ux44f}{%
\subsubsection{Использование курсора для
вставки/исправления\ldots{}}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43aux443ux440ux441ux43eux440ux430-ux434ux43bux44f-ux432ux441ux442ux430ux432ux43aux438ux438ux441ux43fux440ux430ux432ux43bux435ux43dux438ux44f}}

Помните, что возможность редактировать файла доступна только, если файл
загружен в radare2 с использованием флага \texttt{-w}. В противном
случае файл открывается в режиме ``только для чтения''.

При нажатии строчной буквы \texttt{c} radare переключается режим
курсора. Когда этот режим активен, выделенный в данный момент байт (или
диапазон байтов) подсвечивается.

\begin{figure}
\centering
\includegraphics{cursor.png}
\caption{Курсор по адресу 0x00404896}
\end{figure}

Курсор используется для выбора диапазона байтов или просто для указания
конкретного байта. Его можно использовать для создания именованного
флага по указанному смещению. Для этого установите смещение, затем
нажмите клавишу \texttt{f} и введите имя флага. Если файл был открыт в
режиме записи (флаг \texttt{-w} или команды \texttt{o+}), то курсор
может перезаписывать выбранный диапазон новыми значениями. Для этого
выберите диапазон байтов (при нажатии клавиш HJKL и SHIFT), затем
нажмите клавишу \texttt{i} и введите шестнадцатеричные значения для
новых данных. Данные будут повторяться по мере необходимости для
заполнения выбранного диапазона. Например:

\begin{verbatim}
<выбрать 10 байт в визуальном режиме, используя SHIFT+HJKL>
<нажать 'i' и затем ввести '12 34'>
\end{verbatim}

Выбранные десять байтов будут изменены на ``12 34 12 34 12 12\ldots{}''.

Визуальный ассемблер --- это функция, которая обеспечивает
предварительный просмотр в реальном времени при вводе новых инструкций
исправления в ассемблерном коде. Чтобы использовать эту функцию, найдите
или поместите курсор в нужное место и нажмите клавишу «A». Чтобы ввести
несколько инструкций подряд, разделите их точкой с запятой - \texttt{;}.

\hypertarget{ux43fux435ux440ux435ux43aux440ux430ux441ux43dux44bux435-ux441ux441ux44bux43bux43aux438}{%
\subsection{Перекрасные
ссылки}\label{ux43fux435ux440ux435ux43aux440ux430ux441ux43dux44bux435-ux441ux441ux44bux43bux43aux438}}

Во время анализа radare2 обнаруживает перекрасные ссылки (XREF), эта
информация в визуальном дизассемблировании показывается с помощью тега
\texttt{XREF} :

\begin{verbatim}
; DATA XREF from 0x00402e0e (unk)
str.David_MacKenzie:
\end{verbatim}

Чтобы увидеть, где вызывается этот флаг, нажмите \texttt{x}, если вы
хотите перейти к месту, где используются данные, затем нажмите
соответствующую цифру {[}0-9{]} на клавиатуре. (Эта функциональность
аналогична \texttt{axt})

\texttt{X} соответствует обратной операции \texttt{axf}.

\hypertarget{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux430ux440ux433ux443ux43cux435ux43dux442ux43eux432-ux444ux443ux43dux43aux446ux438ux438}{%
\subsection{Отображение аргументов
функции}\label{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux430ux440ux433ux443ux43cux435ux43dux442ux43eux432-ux444ux443ux43dux43aux446ux438ux438}}

Чтобы включить это представление, используйте переменную конфигурации
\texttt{e\ dbg.funcarg\ =\ true}

\begin{figure}
\centering
\includegraphics{funcarg.png}
\caption{funcarg}
\end{figure}

\hypertarget{ux434ux43eux431ux430ux432ux43bux435ux43dux438ux435-ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux44f}{%
\subsection{Добавление
комментария}\label{ux434ux43eux431ux430ux432ux43bux435ux43dux438ux435-ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux44f}}

Чтобы добавить комментарий, нажмите \texttt{;}.

\hypertarget{ux432ux432ux435ux434ux438ux442ux435-ux434ux440ux443ux433ux438ux435-ux43aux43eux43cux430ux43dux434ux44b}{%
\subsection{Введите другие
команды}\label{ux432ux432ux435ux434ux438ux442ux435-ux434ux440ux443ux433ux438ux435-ux43aux43eux43cux430ux43dux434ux44b}}

Чтобы вводить команды, используйте \texttt{:}.

\hypertarget{ux43fux43eux438ux441ux43a}{%
\subsection{Поиск}\label{ux43fux43eux438ux441ux43a}}

\texttt{/}: позволяет подсвечивать строки на текущем дисплее.
\texttt{:cmd} позволяет использовать одну из команд ``/?'', выполняющих
специализированный поиск.

\hypertarget{hud-ux44b}{%
\subsection{HUD-ы}\label{hud-ux44b}}

\hypertarget{userfriendly-hud}{%
\subsubsection{UserFriendly HUD}\label{userfriendly-hud}}

Доступ к ``UserFriendly HUD'' можно получить с помощью комбинации клавиш
\texttt{??}. HUD действует как интерактивная шпаргалка, которую можно
использовать для более легкого поиска и выполнения команд. Он особенно
полезен для новичков. Для опытных пользователей есть другие HUD-ы, более
специфичные для конкретной деятельности.

\hypertarget{hud-ux434ux43bux44f-ux444ux43bux430ux433ux43eux432ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux435ux432ux444ux443ux43dux43aux446ux438ux439}{%
\subsubsection{HUD для
флагов/комментариев/функций/\ldots{}}\label{hud-ux434ux43bux44f-ux444ux43bux430ux433ux43eux432ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux435ux432ux444ux443ux43dux43aux446ux438ux439}}

HUD отображается с помощью клавиши \texttt{\_}, он показывает список
всех определенных флагов и позволяет переходить к ним. С помощью
клавиатуры вы можете быстро отфильтровать список до флага, который
содержит определенный шаблон.

Режим ввода HUD можно закрыть с помощью \^{}C. Он также завершится при
нажатии backspace, когда строка ввода пользователя пуста.

\hypertarget{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}{%
\subsection{Настройка
дизассемблирования}\label{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}}

Внешний вид дизассемблирования контролируется с помощью конфигурационных
ключей ``asm.*``, изменяемых с помощью команды \texttt{e}. Все ключи
конфигурации также можно редактировать с помощью редактора визуальной
конфигурации.

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux434ux430ux43aux442ux43eux440-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438}{%
\subsection{Визуальный редактор
конфигурации}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux434ux430ux43aux442ux43eux440-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438}}

Доступ к этому HUD можно получить с помощью клавиши \texttt{e} в
визуальном режиме. Редактор позволяет легко просматривать и изменять
конфигурацию radare2. Например, если вы хотите что-то изменить в дисплее
дизассемблирования, выберите \texttt{asm} из списка, перейдите к
элементу, который вы хотите изменить, а затем выберите его, нажав
\texttt{Enter}. Если элемент является логической переменной, он будет
переключаться, в противном случае будет предложено ввести новое
значение.

\begin{figure}
\centering
\includegraphics{select_asm.png}
\caption{Выберите сначала asm}
\end{figure}

Пример переключения на псевдодизассемблирование:

\begin{figure}
\centering
\includegraphics{pseudo_disable.png}
\caption{Псевдодизассемблирование запрещено}
\end{figure}

\begin{figure}
\centering
\includegraphics{pseudo_enable.png}
\caption{Псевдодизассемблирование разрешено}
\end{figure}

Ниже приведены некоторые примеры настроек переменных среды, связанных с
дизассемблированием.

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-4}{%
\subsection{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-4}}

\hypertarget{asm.arch-ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b-asm.bits-ux440ux430ux437ux43cux435ux440-ux441ux43bux43eux432ux430-ux432-ux431ux438ux442ux430ux445-ux43dux430-ux430ux441ux441ux435ux43cux431ux43bux435ux440ux435}{%
\paragraph{asm.arch: Изменение архитектуры \&\& asm.bits: Размер слова в
битах на
ассемблере}\label{asm.arch-ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b-asm.bits-ux440ux430ux437ux43cux435ux440-ux441ux43bux43eux432ux430-ux432-ux431ux438ux442ux430ux445-ux43dux430-ux430ux441ux441ux435ux43cux431ux43bux435ux440ux435}}

Просмотр списка всех дуг с помощью \texttt{e\ asm.arch=?}

\begin{verbatim}
e asm.arch = dalvik
0x00404870      31ed4989       cmp-long v237, v73, v137
0x00404874      d15e4889       rsub-int v14, v5, 0x8948
0x00404878      e24883e4       ushr-int/lit8 v72, v131, 0xe4
0x0040487c      f0505449c7c0   +invoke-object-init-range {}, method+18772 ;[0]
0x00404882      90244100       add-int v36, v65, v0
\end{verbatim}

\begin{verbatim}
e asm.bits = 16
0000:4870      31ed           xor bp, bp
0000:4872      49             dec cx
0000:4873      89d1           mov cx, dx
0000:4875      5e             pop si
0000:4876      48             dec ax
0000:4877      89e2           mov dx, sp
\end{verbatim}

Последняя операция также может быть выполнена с помощью \texttt{\&} в
визуальном режиме.

\hypertarget{asm.pseudo-ux432ux43aux43bux44eux447ux438ux442ux44c-ux43fux441ux435ux432ux434ux43eux441ux438ux43dux442ux430ux43aux441ux438ux441}{%
\paragraph{asm.pseudo: Включить
псевдосинтаксис}\label{asm.pseudo-ux432ux43aux43bux44eux447ux438ux442ux44c-ux43fux441ux435ux432ux434ux43eux441ux438ux43dux442ux430ux43aux441ux438ux441}}

\begin{verbatim}
e asm.pseudo = true
0x00404870      31ed           ebp = 0
0x00404872      4989d1         r9 = rdx
0x00404875      5e             pop rsi
0x00404876      4889e2         rdx = rsp
0x00404879      4883e4f0       rsp &= 0xfffffffffffffff0
\end{verbatim}

\hypertarget{asm.syntax-ux432ux44bux431ux43eux440-ux441ux438ux43dux442ux430ux43aux441ux438ux441ux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f-intel-att-masm}{%
\paragraph{asm.syntax: Выбор синтаксиса дизассемблирования (intel, att,
masm\ldots)}\label{asm.syntax-ux432ux44bux431ux43eux440-ux441ux438ux43dux442ux430ux43aux441ux438ux441ux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f-intel-att-masm}}

\begin{verbatim}
e asm.syntax = att
0x00404870      31ed           xor %ebp, %ebp
0x00404872      4989d1         mov %rdx, %r9
0x00404875      5e             pop %rsi
0x00404876      4889e2         mov %rsp, %rdx
0x00404879      4883e4f0       and $0xfffffffffffffff0, %rsp
\end{verbatim}

\hypertarget{asm.describe-ux43fux43eux43aux430ux437ux430ux442ux44c-ux43eux43fux438ux441ux430ux43dux438ux435-ux43eux43f-ux43aux43eux434ux430}{%
\paragraph{asm.describe: Показать описание
оп-кода}\label{asm.describe-ux43fux43eux43aux430ux437ux430ux442ux44c-ux43eux43fux438ux441ux430ux43dux438ux435-ux43eux43f-ux43aux43eux434ux430}}

\begin{verbatim}
e asm.describe = true
0x00404870  xor ebp, ebp   ; logical exclusive or
0x00404872  mov r9, rdx    ; moves data from src to dst
0x00404875  pop rsi        ; pops last element of stack and stores the result in argument
0x00404876  mov rdx, rsp   ; moves data from src to dst
0x00404879  and rsp, -0xf  ; binary and operation between src and dst, stores result on dst
\end{verbatim}

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux430ux441ux441ux435ux43cux431ux43bux435ux440}{%
\section{Визуальный
ассемблер}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux430ux441ux441ux435ux43cux431ux43bux435ux440}}

Визуальный режим можно использовать для ассемблирования кода - клавиша
\texttt{A}. Например, давайте заменим \texttt{push} на \texttt{jmp}:

\begin{figure}
\centering
\includegraphics{before.png}
\caption{Было}
\end{figure}

Обратите внимание на новый вариант дизассемблирования и новые стрелки,
отражающие переходы:

\begin{figure}
\centering
\includegraphics{after.png}
\caption{Стало}
\end{figure}

Нужно открыть файл в режиме записи (\texttt{r2\ -w} или \texttt{oo+}),
только так можно вносить исправления в файл. Также можно использовать
режим кэширования: \texttt{e\ io.cache\ =\ true} и \texttt{wc?}.

Помните, что исправление файлов в режиме отладки только исправляет
память, а не файл.

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux434ux430ux43aux442ux43eux440-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438-1}{%
\section{Визуальный редактор
конфигурации}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux434ux430ux43aux442ux43eux440-ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux438-1}}

Команда \texttt{Ve} или \texttt{e} в визуальном режиме позволяют
редактировать конфигурацию radare2 визуально. Например, если вы хотите
изменить режим отображения дизассемблирования, выберите \texttt{asm} в
списке и выберите вариант отображения.

\begin{figure}
\centering
\includegraphics{select_asm.png}
\caption{Выберите сначала asm}
\end{figure}

Пример переключения на псевдодизассемблирование:

\begin{figure}
\centering
\includegraphics{pseudo_disable.png}
\caption{Псевдодизассемблирование запрещено}
\end{figure}

\begin{figure}
\centering
\includegraphics{pseudo_enable.png}
\caption{Псевдодизассемблирование разрешено}
\end{figure}

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux435-ux43fux430ux43dux435ux43bux438}{%
\section{Визуальные
панели}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux435-ux43fux430ux43dux435ux43bux438}}

\hypertarget{ux43aux43eux43dux446ux435ux43fux446ux438ux44f}{%
\subsection{Концепция}\label{ux43aux43eux43dux446ux435ux43fux446ux438ux44f}}

Визуальные панели характеризуются следующими основными функциональными
возможностями:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Разделение экрана,
\item
  Отображение нескольких экранов, таких как символы, регистры, стек, а
  также пользовательские панели,
\item
  Меню охватывает все эти часто используемые команды, так что вам не
  нужно запоминать ни одну из них.
\end{enumerate}

Для CUI разработаны полезные графические интерфейсы в качестве меню, то
есть визуальные панели.

Доступ к панелям можно получить с помощью команды \texttt{v} или с
помощью \texttt{!} из визуального режима.

\hypertarget{ux43eux431ux437ux43eux440}{%
\subsection{Обзор}\label{ux43eux431ux437ux43eux440}}

\begin{figure}
\centering
\includegraphics{panels_overview.png}
\caption{Обзор панелей}
\end{figure}

\hypertarget{ux43aux43eux43cux430ux43dux434ux44b}{%
\subsection{Команды}\label{ux43aux43eux43cux430ux43dux434ux44b}}

\begin{verbatim}
|Visual Ascii Art Panels:
| |      разделить панел вертикально
| -      разделить панель горизонтально
| :      выполнить команду при помощи командной строки r2
| ;      добавить/удалить коментарий
| _      запуск hud-режима (input)
| \      показать user-friendly hud
| ?      показать справку
| !      запустить игру r2048
| .      установить смещение равное PC или на точку входа
| *      показать декомпилятор в текущей панели
| "      создать панель из списка и заменть текщее
| /      подсветить ключевые слова
| (      включить/выключить "снег"
| &      включить/выключить кэш
| [1-9]  следовать на целевой адрес jmp/call, задаваемый ярлыком (например ;[1])
| ' '    (пробел) включить/выключить граф управления / режим панелей
| tab    перейти на следующую панель
| Enter  запуск режима Zoom
| a      включить/выключить автообновление декомпилятора
| b      просмотр символов, флагов, конфигурации, классов, ...
| c      включить/выключить курсор
| C      включить/выключить цветную тему
| d      задать сущность по текущему адресу, аналогично Vd
| D      показать дизассемблирование в текущей панели
| e      сменить заголовок и "команду" текущей панели
| f      задасть/добавить ключевые слова фильтра
| F      удалить все фильтры
| g      перейти/установить на смещение на заданный адрес
| G      перейти/установить нв подсвеченное
| i      вставить шеснадцатеричный код
| hjkl   перемещение изображения в панели (навигация, влево-вниз-вверх-вправо)
| HJKL   перемещение изображения в панели (навигация, влево-вниз-вверх-вправо) постранично
| m      выбрать панель меню
| M      открыть новую панель
| n/N    установить смещение следующей/предыдущей функции/флаг/хит (scr.nkey)
| p/P    повернуть расположение элементов на панели
| q      выход или закрыть вкладку
| Q      закрыть все вкладки и выйти
| r      включить/выключить хинты вызов/переход/загрузка адреса
| R      сгенерировать палитру из случайных цветов (ecr)
| s/S    step in / step over (отладка)
| t/T    открыть комендную строку / закрыть ее
| u/U    undo / redo установки смещения
| w      запуск оконного режима
| V      перейти в режим графа
| xX     показать xrefs/refs текущей функции от/в данные/лщв
| z      сменить текущую панель с первой
\end{verbatim}

\hypertarget{ux431ux430ux437ux43eux432ux44bux435-ux444ux443ux43dux43aux446ux438ux438}{%
\subsection{Базовые
функции}\label{ux431ux430ux437ux43eux432ux44bux435-ux444ux443ux43dux43aux446ux438ux438}}

Используйте клавишу \texttt{TAB} для перемещения по панелям, пока не
дойдете до целевой. Клавиши \texttt{hjkl} - прокручивание панели, на
которой вы сейчас находитесь. Используйте \texttt{S} и \texttt{s} для
step over/in, и все панели будут динамически обновляться во время
отладки. На панелях «Регистры» или «Стек» значения можно редактировать,
вставив шестнадцатеричный формат. Об этом будет рассказано позже.

Использование \texttt{tab} позволяет вам перемещаться между панелями,
настоятельно рекомендуется использовать \texttt{m} для открытия меню.
Как обычно, вы можете использовать \texttt{hjkl} для перемещения по меню
и найдете там тонны полезных вещей. Также можно нажать \texttt{"} для
быстрого просмотра различных настроек просмотра предложений и изменения
содержимого выбранной панели.

\hypertarget{ux440ux430ux437ux434ux435ux43bux435ux43dux438ux435-ux44dux43aux440ux430ux43dux430}{%
\subsection{Разделение
экрана}\label{ux440ux430ux437ux434ux435ux43bux435ux43dux438ux435-ux44dux43aux440ux430ux43dux430}}

Символы \texttt{\textbar{}} - вертикальное и \texttt{-} - горизонтальное
разделение. Можно удалить любую панель, нажав клавишу \texttt{X}.

Размер разделенных панелей может быть изменен из оконного режима, доступ
к которому осуществляется с помощью \texttt{w}.

\hypertarget{ux43aux43eux43cux430ux43dux434ux44b-ux43eux43aux43eux43dux43dux43eux433ux43e-ux440ux435ux436ux438ux43cux430}{%
\subsection{Команды оконного
режима}\label{ux43aux43eux43cux430ux43dux434ux44b-ux43eux43aux43eux43dux43dux43eux433ux43e-ux440ux435ux436ux438ux43cux430}}

\begin{verbatim}
|Справка по панели оконный режима:
| ?      показать эту справку
| ??     показать user-friendly hud
| Enter  запуск режима Zoom
| c      включить/выключить курсор
| hjkl   перемещение изображения в панели (навигация, влево-вниз-вверх-вправо)
| JK     изменить размер вертикально
| HL     изменить размер горизонтально
| q      выйти из оконного режима
\end{verbatim}

\hypertarget{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux437ux43dux430ux447ux435ux43dux438ux439}{%
\subsection{Изменение
значений}\label{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux437ux43dux430ux447ux435ux43dux438ux439}}

На панели «Регистр» или «Стек» можно редактировать значения. Используйте
\texttt{c} для активации режима курсора, перемещать курсор -
\texttt{hjkl}, как обычно. Затем нажмите \texttt{i}, как и в режиме
вставки vim, чтобы вставить значение.

\hypertarget{ux432ux43aux43bux430ux434ux43aux438}{%
\subsection{Вкладки}\label{ux432ux43aux43bux430ux434ux43aux438}}

Визуальные панели также предлагают вкладки для быстрого доступа к
нескольким формам информации. Нажмите клавишу \texttt{t}, чтобы войти в
режим вкладок. Номера вкладок будут видны в правом верхнем углу.

По умолчанию показывается одна вкладка, можно нажать \texttt{t} для
создания новой вкладки с теми же панелями, и \texttt{T}, чтобы создать
новую чистую панель.

Для обхода вкладок можно ввести номер вкладки.

И нажатие \texttt{-} удаляет вкладку, в которой вы находитесь.

\hypertarget{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux43cux430ux43aux435ux442ux43eux432}{%
\subsection{Сохранение
макетов}\label{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux435-ux43cux430ux43aux435ux442ux43eux432}}

Можно сохранить пользовательский макет визуальных панелей, выбрав опцию
«Сохранить макет» в меню «Файл», либо выполнив:

\begin{verbatim}
v= test
\end{verbatim}

Где \texttt{test} --- это имя, под которым вы хотите сохранить
настройки.

Сохраненный макет можно открыть, передав имя в качестве параметра
\texttt{v}:

\begin{verbatim}
v test
\end{verbatim}

Дополнительные инструкции можно узнать в разделе \texttt{v?}.

\hypertarget{ux43fux43eux438ux441ux43a-ux431ux430ux439ux442ux43eux432}{%
\section{Поиск
байтов}\label{ux43fux43eux438ux441ux43a-ux431ux430ux439ux442ux43eux432}}

Поисковая система radare2 поддерживает поиск по нескольким ключевым
словам, двоичным маскам и шестнадцатеричным значениям. Автором
подсистемы является esteve, также несколько функций реализована поверх
нее. Подсистема автоматически создает флаги для найденных
\emph{вхождений} (hits), позволяя ссылаться на них далее.

Поиск инициируется командой \texttt{/}.

\begin{verbatim}
[0x00000000]> /?
|Usage: /[!bf] [arg] # Инструменты поиска (Инструкция по настройке - 'e??search')
|Используйте io.va для поиска в невиртуализированных адресных пространствах
| / foo\x00               поиск строки 'foo\0'
| /j foo\x00              поиск строки 'foo\0' с вфводом в json
| /! ff                   поиск первого вхождения, не соответствующего критерию поиска, модификатор команды
| /!x 00                  найти первый байт != 0x00
| /+ /bin/sh              конструировать строку из кусков
| //                      повторить предыдущую операцию поиска
| /a jmp eax              ассемблировать оп-код и попытаться найти его байты
| /A jmp                  найти проанализированные инструкции данного типа (инструкция - /A?)
| /b                      поиск в обратном направлении, модификатор команды, за которым следует команда
| /B                      поиск в распознанных заголовках RBin
| /c jmp [esp]            поиск инструкций, соответствующих заданной строке
| /ce rsp,rbp             поиск соответствующих критерию esil-выражений
| /C[ar]                  поиск криптографических материалов
| /d 101112               поиск дельтифицированной последовательности из N байт
| /e /E.F/i               проверка соответствия регулярному выражению
| /E esil-expr            смещение подходящего критерию esil-выражения %%= here
| /f                      поиск вперед, модификатор команды, за которым идет команда
| /F file [off] [sz]      поиск в содержимом файла, ограниченный смещением и размером
| /g[g] [from]            найти все пути в графе из A в B (/gg следует по jump-ам, смотрите search.count и anal.depth)
| /h[t] [hash] [len]      найти блок, для которого подходит заданых хэш, подробности в ph
| /i foo                  поиск строки 'foo', игнорируя размер букв
| /m magicfile            поиск подходящего "magic file" (используйте blocksize)
| /M                      поиск известных файловых систем и монтировать их автоматически
| /o [n]                  показать смещение в n инструкций в обратном направлении
| /O [n]                  аналогично /o, но используется другая функция обработки ошибки, если стандартная не может быть использована
| /p patternsize          искать шаблон заданного размера
| /P patternsize          искать подобные блоки
| /r[erwx][?] sym.printf  анализировать оп-код, ссылающийся на смещение (/re для esil)
| /R [grepopcode]         поиск соответствий для ROP gadgets, разделяются точкой с запятой
| /s                      поиск всех системных вызовов в регионе (ЭКСПЕРИМЕНТАЛЬНАЯ функция)
| /v[1248] value          поиск 32-битового значения с учетом `cfg.bigendian`
| /V[1248] min max        поиск 32-битового значения с учетом `cfg.bigendian`, ограничен диапазоном
| /w foo                  поиск wide-строки 'f\0o\0o\0'
| /wi foo                 поиск wide-строки, игнорируя размер букв 'f\0o\0o\0'
| /x ff..33               поиск шестнадцатеричных данных, игнорируя некоторые позиции символов
| /x ff0033               поиск шестнадцатеричных данных
| /x ff43:ffd0            поиск шестнадцатеричных данных с маской
| /z min max              поиск шестнадцатеричных данных, ограничен размером
\end{verbatim}

Поскольку в radare2 все рассматривается как файл, то не имеет значения,
выполняете ли вы поиск в сокете, на удаленном устройстве, в памяти
процесса или в файле. Следующая синтаксическая структура `/\emph{'
запускает многострочный комментарий, а не команду поиска. Введите '}/',
чтобы закончить комментарий.

\hypertarget{ux43eux431ux44bux447ux43dux44bux439-ux43fux43eux438ux441ux43a}{%
\subsection{Обычный
поиск}\label{ux43eux431ux44bux447ux43dux44bux439-ux43fux43eux438ux441ux43a}}

Поиск обычной текстовой строки в файле будет выглядеть примерно так:

\begin{verbatim}
$ r2 -q -c "/ lib" /bin/ls
Searching 3 bytes from 0x00400000 to 0x0041ae08: 6c 69 62
hits: 9
0x00400239 hit0_0 "lib64/ld-linux-x86-64.so.2"
0x00400f19 hit0_1 "libselinux.so.1"
0x00400fae hit0_2 "librt.so.1"
0x00400fc7 hit0_3 "libacl.so.1"
0x00401004 hit0_4 "libc.so.6"
0x004013ce hit0_5 "libc_start_main"
0x00416542 hit0_6 "libs/"
0x00417160 hit0_7 "lib/xstrtol.c"
0x00417578 hit0_8 "lib"
\end{verbatim}

Как видно из вывода выше, radare2 генерирует флаг ``hit''
(\emph{вхождение}) для каждой найденной записи. Затем можно использовать
команду \texttt{ps}, чтобы увидеть строки, хранящиеся в смещениях,
отмеченных флагами, имена будут выведены в форме
\texttt{hit0\_\textless{}номер\_вхождения\textgreater{}}:

\begin{verbatim}
[0x00404888]> / ls
...
[0x00404888]> ps @ hit0_0
lseek
\end{verbatim}

Можно искать строки с wide-символами (например, буквы юникода) с помощью
команды \texttt{/w}:

\begin{verbatim}
[0x00000000]> /w Hello
0 results found.
\end{verbatim}

Для выполнения поиска строк без учета регистра используйте параметр
\texttt{/i}:

\begin{verbatim}
[0x0040488f]> /i Stallman
Searching 8 bytes from 0x00400238 to 0x0040488f: 53 74 61 6c 6c 6d 61 6e
[# ]hits: 004138 < 0x0040488f  hits = 0
\end{verbatim}

В строке поиска можно указывать шестнадцатеричные
escape-последовательности, предварив их \texttt{\textbackslash{}x}:

\begin{verbatim}
[0x00000000]> / \x7FELF
\end{verbatim}

Если вместо этого ищете строку шестнадцатеричных значений, вероятно
лучше использовать команду \texttt{/x}:

\begin{verbatim}
[0x00000000]> /x 7F454C46
\end{verbatim}

Если надо замаскировать некоторый кусок во время поиска, можно
использовать символ \textbf{.} (точка):

\begin{verbatim}
[0x00407354]> /x 80..80
0x0040d4b6 hit3_0 800080
0x0040d4c8 hit3_1 808080
0x004058a6 hit3_2 80fb80
\end{verbatim}

Если вам не известны некоторые значения битов вашего шестнадцатеричного
паттерна, можно использовать битовую маску в вашем шаблоне. Каждый бит,
равный единице в маске, указывает на поиск значения бита в шаблоне. Бит,
равный нулю в маске, указывает, что значение совпадающего значения может
быть равно 0 или 1:

\begin{verbatim}
[0x00407354]> /x 808080:ff80ff
0x0040d4c8 hit4_0 808080
0x0040d7b0 hit4_1 808080
0x004058a6 hit4_2 80fb80    
\end{verbatim}

Можно заметить, что команда \texttt{/x\ 808080:ff00ff} эквивалентна
команде \texttt{/x\ 80..80}.

После завершения поиска результаты сохраняются в пространстве флага
\texttt{searches}.

\begin{verbatim}
[0x00000000]> fs
0    0 . strings
1    0 . symbols
2    6 . searches

[0x00000000]> f
0x00000135 512 hit0_0
0x00000b71 512 hit0_1
0x00000bad 512 hit0_2
0x00000bdd 512 hit0_3
0x00000bfb 512 hit0_4
0x00000f2a 512 hit0_5
\end{verbatim}

Чтобы удалить флаги ``hit'', используйте команду \texttt{f-hit*}.

Часто во время длительных сеансов поиска нужно запускать последний поиск
более одного раза. Вы можете использовать команду \texttt{//} для
повторения последнего поиска.

\begin{verbatim}
[0x00000f2a]> //     ; повторить последний поиск
\end{verbatim}

\hypertarget{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux43fux430ux440ux430ux43cux435ux442ux440ux43eux432-ux43fux43eux438ux441ux43aux430}{%
\subsection{Настройка параметров
поиска}\label{ux43dux430ux441ux442ux440ux43eux439ux43aux430-ux43fux430ux440ux430ux43cux435ux442ux440ux43eux432-ux43fux43eux438ux441ux43aux430}}

Поисковая система radare2 настраивается с помощью нескольких
конфигурационных переменных, изменяемых с помощью команды \texttt{e}.

\begin{verbatim}
e cmd.hit = x         ; команеда radare2, которую надо запускать для каждого вхождения (hit)
e search.distance = 0 ; ограничение расстояния при поиске строк
e search.in = [foo]   ; указать границы поиска. Поддерживаемые значения перечислены в разделе e search.in=??
e search.align = 4    ; показывать только результаты поиска, выровненные на заданные границы
e search.from = 0     ; начальный адрес
e search.to = 0       ; конечный адрес
e search.asmstr = 0   ; поиск строки, а не результата ассемблирования
e search.flags = true ; если разрешен, то создать флаг для каждого вхождения
\end{verbatim}

Переменная \texttt{search.align} используется для ограничения допустимых
поисковых запросов определенным выравниванием. Например, при помощи
\texttt{e\ search.align=4} будут выведены только результаты, найденные
на 4-байтовых смещениях. Логическая переменная \texttt{search.flags}
инструктирует поисковую систему помечать вхождения флагами, ими потом
можно ссылаться на найденные смещения. Если текущий поиск прерывается с
помощью последовательности клавиш \texttt{Ctrl-C}, текущая позиция
поиска помечается \texttt{search\_stop}.

\hypertarget{ux43fux43eux438ux441ux43a-ux441ux43eux43fux43eux441ux442ux430ux432ux43bux435ux43dux438ux435ux43c-ux441-ux448ux430ux431ux43bux43eux43dux43eux43c}{%
\subsection{Поиск сопоставлением с
шаблоном}\label{ux43fux43eux438ux441ux43a-ux441ux43eux43fux43eux441ux442ux430ux432ux43bux435ux43dux438ux435ux43c-ux441-ux448ux430ux431ux43bux43eux43dux43eux43c}}

Команда \texttt{/p} позволяет делать повторный поиск шаблонов к
серверному хранилищу ввода-вывода. Можно идентифицировать повторяющиеся
последовательности байтов без явного их указания. Единственный параметр
команды задает минимальную обнаруживаемую длину шаблона.

Пример:

\begin{verbatim}
[0x00000000]> /p 10
\end{verbatim}

Вывод команды покажет различные найденные шаблоны и сколько раз каждый
из них встречается.

Возможен поиск шаблонов с известной разницей между последовательными
байтами с помощью команды \texttt{/d}. Например, команда для поиска всех
шаблонов, где у первого и второго байта первые биты различны, а у
второго и третьего байтов отличаются вторые биты:

\begin{verbatim}
[0x00000000]> /d 0102
Searching 2 bytes in [0x0-0x400]
hits: 2
0x00000118 hit2_0 9a9b9d
0x00000202 hit2_1 a4a5a7
\end{verbatim}

\hypertarget{ux430ux432ux442ux43eux43cux430ux442ux438ux437ux430ux446ux438ux44f-ux43eux431ux440ux430ux431ux43eux442ux43aux438-ux43dux430ux439ux434ux435ux43dux43dux44bux445-ux432ux445ux43eux436ux434ux435ux43dux438ux439}{%
\subsection{Автоматизация обработки найденных
вхождений}\label{ux430ux432ux442ux43eux43cux430ux442ux438ux437ux430ux446ux438ux44f-ux43eux431ux440ux430ux431ux43eux442ux43aux438-ux43dux430ux439ux434ux435ux43dux43dux44bux445-ux432ux445ux43eux436ux434ux435ux43dux438ux439}}

Переменная конфигурации \texttt{cmd.hit} используется для определения
команды radare2, запускающейся в момент, когда найдено соответствие
поисковому запросу (\emph{вхождение}, \emph{hit}). Если вы хотите
выполнить несколько команд, разделяйте их \texttt{;}. Можно задать
команды в отдельном сценарии, а затем выполнить его целиком с помощью
команды \texttt{.\ \ script-file-name}.

Пример использования:

\begin{verbatim}
[0x00404888]> e cmd.hit = p8 8
[0x00404888]> / lib
Поиск трех байтов с 0x00400000 до 0x0041ae08: 6c 69 62
hits: 9
0x00400239 hit4_0 "lib64/ld-linux-x86-64.so.2"
31ed4989d15e4889
0x00400f19 hit4_1 "libselinux.so.1"
31ed4989d15e4889
0x00400fae hit4_2 "librt.so.1"
31ed4989d15e4889
0x00400fc7 hit4_3 "libacl.so.1"
31ed4989d15e4889
0x00401004 hit4_4 "libc.so.6"
31ed4989d15e4889
0x004013ce hit4_5 "libc_start_main"
31ed4989d15e4889
0x00416542 hit4_6 "libs/"
31ed4989d15e4889
0x00417160 hit4_7 "lib/xstrtol.c"
31ed4989d15e4889
0x00417578 hit4_8 "lib"
31ed4989d15e4889
\end{verbatim}

\hypertarget{ux43fux43eux438ux441ux43a-ux432-ux43eux431ux440ux430ux442ux43dux43eux43c-ux43dux430ux43fux440ux430ux432ux43bux435ux43dux438ux438}{%
\subsection{Поиск в обратном
направлении}\label{ux43fux43eux438ux441ux43a-ux432-ux43eux431ux440ux430ux442ux43dux43eux43c-ux43dux430ux43fux440ux430ux432ux43bux435ux43dux438ux438}}

Иногда надо найти что-то, что находится ``выше по тексту''. Для
реализованы команды поиска в обратном направлении с заданным критерием
поиска --- команда \texttt{/b}.

\begin{verbatim}
# Поиск вперед
[0x100001200]> / nop  
0x100004b15 hit0_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
0x100004f50 hit0_1 .STUWabcdefghiklmnopqrstuwx1] [file .
# Поиск назад
[0x100001200]> /b nop
[0x100001200]> s 0x100004f50p
[0x100004f50]> /b nop
0x100004b15 hit2_0 .STUWabcdefghiklmnopqrstuvwxbin/ls.
[0x100004f50]>
\end{verbatim}

Обратите внимание, что \texttt{/b} делает то же самое, что и \texttt{/},
но в обратном направлении, так что, если надо использовать \texttt{/x} в
обратном направлении? Можно использовать \texttt{/bx}, аналогичной
работают и другие поисковые подкоманды:

\begin{verbatim}
[0x100001200]> /x 90
0x100001a23 hit1_0 90
0x10000248f hit1_1 90
0x1000027b2 hit1_2 90
0x100002b2e hit1_3 90
0x1000032b8 hit1_4 90
0x100003454 hit1_5 90
0x100003468 hit1_6 90
0x10000355b hit1_7 90
0x100003647 hit1_8 90
0x1000037ac hit1_9 90
0x10000389c hit1_10 90
0x100003c5c hit1_11 90

[0x100001200]> /bx 90
[0x100001200]> s 0x10000355b
[0x10000355b]> /bx 90
0x100003468 hit3_0 90
0x100003454 hit3_1 90
0x1000032b8 hit3_2 90
0x100002b2e hit3_3 90
0x1000027b2 hit3_4 90
0x10000248f hit3_5 90
0x100001a23 hit3_6 90
[0x10000355b]>
\end{verbatim}

\hypertarget{ux43fux43eux438ux441ux43a-ux432-ux440ux435ux437ux443ux43bux44cux442ux430ux442ux430ux445-ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}{%
\subsection{Поиск в результатах
ассемблирования}\label{ux43fux43eux438ux441ux43a-ux432-ux440ux435ux437ux443ux43bux44cux442ux430ux442ux430ux445-ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}}

Если надо найти определенные оп-коды ассемблера, можно использовать
команды \texttt{/a}. Команда \texttt{/ad/\ jmp\ {[}esp{]}} ищет
указанную категорию мнемоники ассемблера:

\begin{verbatim}
[0x00404888]> /ad/ jmp qword [rdx]
f hit_0 @ 0x0040e50d   # 2: jmp qword [rdx]
f hit_1 @ 0x00418dbb   # 2: jmp qword [rdx]
f hit_2 @ 0x00418fcb   # 3: jmp qword [rdx]
f hit_3 @ 0x004196ab   # 6: jmp qword [rdx]
f hit_4 @ 0x00419bf3   # 3: jmp qword [rdx]
f hit_5 @ 0x00419c1b   # 3: jmp qword [rdx]
f hit_6 @ 0x00419c43   # 3: jmp qword [rdx]
\end{verbatim}

Команда \texttt{/a\ jmp\ eax} собирает строку для машинного кода, затем
выполняет поиск байтов по-кода:

\begin{verbatim}
[0x00404888]> /a jmp eax
hits: 1
0x004048e7 hit3_0 ffe00f1f8000000000b8
\end{verbatim}

\hypertarget{ux43fux43eux438ux441ux43a-ux43aux440ux438ux43fux442ux43eux433ux440ux430ux444ux438ux447ux435ux441ux43aux438ux445-ux434ux430ux43dux43dux44bux445}{%
\subsection{Поиск криптографических
данных}\label{ux43fux43eux438ux441ux43a-ux43aux440ux438ux43fux442ux43eux433ux440ux430ux444ux438ux447ux435ux441ux43aux438ux445-ux434ux430ux43dux43dux44bux445}}

\hypertarget{ux43fux43eux438ux441ux43a-ux43aux43bux44eux447ux435ux439-aes}{%
\subsubsection{Поиск ключей
AES}\label{ux43fux43eux438ux441ux43a-ux43aux43bux44eux447ux435ux439-aes}}

Radare2 способен находить \textbf{расширенные ключи AES} с помощью
команды \texttt{/ca}. Он выполняет поиск от текущей позиции поиска до
предела \texttt{search.distance} или до конца файла. Можно прервать
текущий поиск, нажав \texttt{Ctrl-C}. Например, чтобы найти ключи AES в
дампе памяти:

\begin{verbatim}
0x00000000]> /ca
Searching 40 bytes in [0x0-0x1ab]
hits: 1
0x000000fb hit0_0 6920e299a5202a6d656e636869746f2a
\end{verbatim}

Полученная длина соответствует размеру используемого ключа AES: 128, 192
или 256 бит. Если вы просто ищете ключи AES в виде открытого текста в
двоичном файле, \texttt{/ca} не найдет их, они должны быть расшифрованы
специальным алгоритмом.

\hypertarget{ux43fux43eux438ux441ux43a-ux437ux430ux43aux440ux44bux442ux44bux445-ux43aux43bux44eux447ux435ux439-ux438-ux441ux435ux440ux442ux438ux444ux438ux43aux430ux442ux43eux432}{%
\subsubsection{Поиск закрытых ключей и
сертификатов}\label{ux43fux43eux438ux441ux43a-ux437ux430ux43aux440ux44bux442ux44bux445-ux43aux43bux44eux447ux435ux439-ux438-ux441ux435ux440ux442ux438ux444ux438ux43aux430ux442ux43eux432}}

Команда \texttt{/cr} реализует поиск закрытых ключей (RSA и ECC).
Команда \texttt{/cd} реализует аналогичную функцию поиска сертификатов.

\begin{verbatim}
[0x00000000]> /cr
Searching 11 bytes in [0x0-0x15a]
hits: 2
0x000000fa hit1_0 302e020100300506032b657004220420fb3d588296fed5694ff7049eafb74490bf4bc6467ee11a08...
\end{verbatim}

\hypertarget{ux44dux43dux442ux440ux43eux43fux438ux439ux43dux44bux439-ux430ux43dux430ux43bux438ux437}{%
\subsubsection{Энтропийный
анализ}\label{ux44dux43dux442ux440ux43eux43fux438ux439ux43dux44bux439-ux430ux43dux430ux43bux438ux437}}

\texttt{p=e} дают подсказки, указывая участки с высокой энтропией,
пытающиеся скрыть жестко закодированный секрет. Есть возможность
разграничить участки энтропии для последующего использования с помощью
команды \texttt{\textbackslash{}s}:

\begin{verbatim}
[0x00000000]> b
0x100
[0x00000000]> b 4096
[0x00000000]> /s
0x00100000 - 0x00101000 ~ 5.556094
0x014e2c88 - 0x014e3c88 ~ 0.000000
0x01434374 - 0x01435374 ~ 6.332087
0x01435374 - 0x0144c374 ~ 3.664636
0x0144c374 - 0x0144d374 ~ 1.664368
0x0144d374 - 0x0144f374 ~ 4.229199
0x0144f374 - 0x01451374 ~ 2.000000
(...)
[0x00000000]> /s*
f entropy_section_0 0x00001000 0x00100000
f entropy_section_1 0x00001000 0x014e2c88
f entropy_section_2 0x00001000 0x01434374
f entropy_section_3 0x00017000 0x01435374
f entropy_section_4 0x00001000 0x0144c374
f entropy_section_5 0x00002000 0x0144d374
f entropy_section_6 0x00002000 0x0144f374
\end{verbatim}

Размер блока увеличивается до 4096 байт со 100 байт по умолчанию, чтобы
энтропийный поиск \texttt{/s} мог работать на блоках разумного размера.
Флаги разделов могут быть переданы в оператор ``точка'' \texttt{./s*}, и
затем перебраны при помощи \texttt{px\ 32\ @@\ entropy*}.

\hypertarget{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435-1}{%
\section{Дизассемблирование}\label{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435-1}}

Дизассемблирование в радаре --- это всего лишь способ представления
массива байтов. Он обрабатывается как специальный режим печати внутри
команды \texttt{p}.

В прежние времена, когда ядро радара было меньше, дизассемблер
управлялся внешним файлом rsc. То есть радар сначала сбрасывал текущий
блок в файл, а потом просто вызывал \texttt{objdump}, сконфигурированный
на дизассемблирование для Intel, ARM и другие поддерживаемые
архитектуры.

Это было работающее и дружественное к Unix решение, но оно было
неэффективным, так как повторяло одни и те же дорогостоящие действия
снова и снова, так же не было кеша. В результате прокрутка была ужасно
медленной.

Поэтому возникла необходимость создать универсальную библиотеку
дизассемблера для поддержки нескольких плагинов для разных архитектур.
Перечислим текущие используемые плагины с помощью

\begin{verbatim}
$ rasm2 -L
\end{verbatim}

или в radare2:

\begin{verbatim}
> e asm.arch=??
\end{verbatim}

За много лет до появления capstone r2 использовал дизассемблеры udis86 и
olly, разные от gnu (binutils).

В настоящее время поддержка дизассемблера является одной из основных
особенностей радара. Теперь у него есть много параметров - порядок
следования байтов, включая вариант целевой архитектуры и варианты
дизассемблера и др.

Чтобы получить дизассемблированный код, используйте команду \texttt{pd}.
Он принимает числовой аргумент, указывающий сколько оп-кодов текущего
блока вы хотите видеть. Большинство команд в radare считают текущий
размер блока ограничением по умолчанию для ввода данных. Если вы хотите
дизассемблировать больше байтов, установите новый размер блока с помощью
команды \texttt{b}.

\begin{verbatim}
[0x00000000]> b 100    ; установить размер блока равным 100
[0x00000000]> pd       ; дизассемблировать сто байт
[0x00000000]> pd 3     ; дизассемблировать три оп-кода
[0x00000000]> pD 30    ; дизассемблировать 30 байт
\end{verbatim}

Команда \texttt{pD} работает как \texttt{pd}, но принимает в качестве
аргумента количество байтов вместо количества оп-кодов.

«Псевдо»-синтаксис может быть несколько проще для понимания человеком,
чем нотации ассемблера по умолчанию. Но иногда становится раздражающим
чтение большого объема кода. Попробуйте использовать разные варианты:

\begin{verbatim}
[0x00405e1c]> e asm.pseudo = true
[0x00405e1c]> pd 3
          ; JMP XREF from 0x00405dfa (fcn.00404531)
          0x00405e1c    488b9424a80. rdx = [rsp+0x2a8]
          0x00405e24    64483314252. rdx ^= [fs:0x28]
          0x00405e2d    4889d8       rax = rbx

[0x00405e1c]> e asm.syntax = intel
[0x00405e1c]> pd 3
          ; JMP XREF from 0x00405dfa (fcn.00404531)
          0x00405e1c    488b9424a80. mov rdx, [rsp+0x2a8]
          0x00405e24    64483314252. xor rdx, [fs:0x28]
          0x00405e2d    4889d8       mov rax, rbx

[0x00405e1c]> e asm.syntax=att
[0x00405e1c]> pd 3
          ; JMP XREF from 0x00405dfa (fcn.00404531)
          0x00405e1c    488b9424a80. mov 0x2a8(%rsp), %rdx
          0x00405e24    64483314252. xor %fs:0x28, %rdx
          0x00405e2d    4889d8       mov %rbx, %rax
\end{verbatim}

\hypertarget{ux434ux43eux431ux430ux432ux43bux435ux43dux438ux435-ux43cux435ux442ux430ux434ux430ux43dux43dux44bux445-ux43a-ux442ux435ux43aux441ux442ux443-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}{%
\subsection{Добавление метаданных к тексту
дизассемблера}\label{ux434ux43eux431ux430ux432ux43bux435ux43dux438ux435-ux43cux435ux442ux430ux434ux430ux43dux43dux44bux445-ux43a-ux442ux435ux43aux441ux442ux443-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}}

Типичная работа, связанная с взломом двоичных файлов, --- аннотация, она
значительно увеличивает производительность процесса. Radare предлагает
несколько способов хранения и извлечения таких метаданных.

Следуя общим основным принципам UNIX, легко написать небольшую утилиту
на языке сценариев, которая использует \texttt{objdump}, \texttt{otool}
или любую другую существующую утилиту для получения информации из
двоичного файла, и импортировать ее результаты в radare. Например,
взгляните на \texttt{idc2r.py}, которая поставляется с
\href{https://github.com/radareorg/radare2ida}{radare2ida}. Ее
использование - запуск
\texttt{idc2r.py\ file.idc\ \textgreater{}\ file.r2}. Она считывает файл
IDC, экспортированный из базы данных IDA Pro, и создает скрипт r2,
содержащий те же комментарии, имена функций и другие данные. Полученный
файл `file.r2' можно импортировать с помощью команды ``точка''
(\texttt{.}) radar-а:

\begin{verbatim}
[0x00000000]> . file.r2
\end{verbatim}

Команда \texttt{.} используется для интерпретации команд Radare из
внешних источников, включая файлы и выходные данные программы. Чтобы
пропустить генерацию промежуточного файла и импортировать скрипт
напрямую, можно использовать такую комбинацию:

\begin{verbatim}
[0x00000000]> .!idc2r.py < file.idc
\end{verbatim}

Импорт метаданных IDA Pro из дампа IDC является устаревшим механизмом и
может перестать работать в будущем. Рекомендуемый способ - использовать
скрипт \texttt{ida2r2.py}, основанный на
\href{https://github.com/williballenthin/python-idb}{python-idb}, он
открывает IDB-файлы напрямую без установки IDA Pro.

Команда \texttt{C} используется для управления комментариями и
отображением данных. Можно снабдить некоторый диапазон байтов
метаданными, указывающими как его следует интерпретировать: код, блок
двоичных данных или строкой. Также можно запустить внешнюю программу,
передав ей часть данных флага. Программа должна провести анализ и
передать обратно метаданные, например, комментарии. Данные для анализа
никто не запрещает получать из внешнего файла или базы данных, в том
числе.

Существует множество различных команд задания метаданных, вот краткий
обзор некоторых из них:

\begin{verbatim}
[0x00404cc0]> C?
| Usage: C[-LCvsdfm*?][*?] [...]   # Управление метаданными
| C                                              перечислить метаданные в виде текста
| C*                                             перечислить метаданные в виде команд r2
| C*.                                            перечень метаданных, привязанных к текущему смещению, ыормат команд r2
| C- [len] [[@]addr]                             удалить метаданные, привязанные к заданному диапазону адресов
| C.                                             перечислить метаданные, привязанные к текущему смещению в виде текста
| CC! [@addr]                                    редактировать комментарий при помощи $EDITOR-а
| CC[?] [-] [comment-text] [@addr]               добавить/удалить комментарий
| CC.[addr]                                      показат комментарий, привязанный к текущему адресу
| CCa[-at]|[at] [text] [@addr]                   добавить/удалить комментарий, привязанный к текущему адресу
| CCu [comment-text] [@addr]                     добавить уникальный комментарий
| CF[sz] [fcn-sign..] [@addr]                    сигнатура функции
| CL[-][*] [file:line] [addr]                    показать или добавить 'code line'-информацию (bininfo)
| CS[-][space]                                   управление meta-пространствами для фильтрации комментариев и т.п.
| C[Cthsdmf]                                     перечислить комментарии/типы/скрытое/строки/данные/magic-и в виде текста
| C[Cthsdmf]*                                    перечислить комментарии/типы/скрытое/строки/данные/magic-и в виде команд r2
| Cd[-] [size] [repeat] [@addr]                  сделать шестнадцатеричный дамп массива данных (Cd 4 10 == dword [10])
| Cd. [@addr]                                    показать размер данныз по текущему адресу
| Cf[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]  задать формат области память (смотрите pf?)
| Ch[-] [size] [@addr]                           скрыть данные
| Cm[-] [sz] [fmt..] [@addr]                     распознать magic (смотрите pm?)
| Cs[?] [-] [size] [@addr]                       добавить строку
| Ct[?] [-] [comment-text] [@addr]               добавить/удалить комментарий об анализе типа
| Ct.[@addr]                                     показать содержимое по текущему смещению или заданному адресу
| Cv[bsr][?]                                     добавить комментарий к аргументу функции
| Cz[@addr]                                      добавить строку (смотрите Cs?)
\end{verbatim}

Добавление комментария к определенной строке/адресу - команда
\texttt{Ca} :

\begin{verbatim}
[0x00000000]> CCa 0x0000002 this guy seems legit
[0x00000000]> pd 2
0x00000000    0000         add [rax], al
;      this guy seems legit
0x00000002    0000         add [rax], al
\end{verbatim}

Семейство команд \texttt{C?} позволяет пометить некоторый диапазон
адресов заданным типом. Три основных типа метаданных - это код
(дизассемблирование выполняется с помощью asm.arch), блок данных (массив
элементов данных) или строка. Команда \texttt{cs} - определение
метаданных для строки, команда \texttt{Cd} - для массива элементов
данных, команда \texttt{Cf} - определение сложных структур данных.

Аннотация типов данных легче всего выполнять в визуальном режиме,
используя клавишу «d», сокращение от ``data type change''. Используйте
курсор для выбора диапазона байтов (нажмите клавишу \texttt{c}, чтобы
переключить режим курсора, используйте клавиши HJKL для определения
области выделения), затем нажмите «d», чтобы получить меню возможных
действий/типов. Например, чтобы пометить диапазон как строку,
используйте опцию `s' из меню. В командной строке такой же результат
получается при помощи команды \texttt{Cs}:

\begin{verbatim}
[0x00000000]> f string_foo @ 0x800
[0x00000000]> Cs 10 @ string_foo
\end{verbatim}

Команда \texttt{Cf} используется для определения структуры для участка
памяти (используется тот же синтаксис, что в команде \texttt{pf}). Вот
пример:

\begin{verbatim}
[0x7fd9f13ae630]> Cf 16 2xi foo bar
[0x7fd9f13ae630]> pd
;-- rip:
0x7fd9f13ae630 format 2xi foo bar {
0x7fd9f13ae630 [0] {
 foo : 0x7fd9f13ae630 = 0xe8e78948
 bar : 0x7fd9f13ae634 = 14696
}
0x7fd9f13ae638 [1] {
 foo : 0x7fd9f13ae638 = 0x8bc48949
 bar : 0x7fd9f13ae63c = 571928325
}
} 16
0x7fd9f13ae633    e868390000   call 0x7fd9f13b1fa0
0x7fd9f13ae638    4989c4       mov r12, rax
\end{verbatim}

Аргумент \texttt{{[}sz{]}} у \texttt{Cf} используется для задания
количества байтов, занимаемых структурой при дизассемблировании, она
полностью независима от размера структуры данных, определяемой строкой
задания формата. Может это кажется странным, но этому есть несколько
применений. Например, можно задать и форматирование структуры,
отображаемой при дизассемблировании, и по-прежнему отображать эти адреса
в виде смещений и байтов. Для больших структур удобно идентифицировать
только несколько полей, если нужны только они. Затем можно указать r2
отображать только эти поля, используя строку формата и специальные
`skip'-поля, а также продолжить дизассемблирование после отображения
всей структуры, задав ей полный размер с помощью аргумента \texttt{sz}.
Использование \texttt{Cf} позволяет описывать сложные структуры при
помощи простых однострочных командных выражений. Посмотрите инструкцию
\texttt{pf?}.

Помните, что все команды группы \texttt{C} также доступны в визуальном
режиме, нажав кнопку \texttt{d} (data conversion). В отличие от команды
\href{../analysis/types.md}{\texttt{t}} команда \texttt{Cf} не изменяет
результаты анализа. Это только инструмент визуализации.

Иногда добавление одной строки комментария бывает недостаточно, radare2
позволяет создавать ссылки на текстовые файлы. Функция реализуется
командой \texttt{СС,} или нажатием клавиши \texttt{,} в визуальном
режиме. В результате откроется \texttt{\$EDITOR} для создания нового
файла, если файл существует, просто создаст ссылку. Файл будет показан в
комментариях к коду:

\begin{verbatim}
[0x00003af7 11% 290 /bin/ls]> pd $r @ main+55 # 0x3af7
│0x00003af7  call sym.imp.setlocale        ;[1] ; ,(locale-help.txt) ; char *setlocale(int category, const char *locale)
│0x00003afc  lea rsi, str.usr_share_locale ; 0x179cc ; "/usr/share/locale"
│0x00003b03  lea rdi, [0x000179b2]         ; "coreutils"
│0x00003b0a  call sym.imp.bindtextdomain   ;[2] ; char *bindtextdomain(char *domainname, char *dirname)
\end{verbatim}

Найдите \texttt{,(locale-help.txt)} в комментариях выше, если теперь
снова нажать \texttt{,} в визуальном режиме, файл откроется. Используя
этот механизм, создаются длинные описания конкретных мест в
дизассемблированном коде, устанавливаются ссылки на документацию, статьи
по теме.

\hypertarget{esil}{%
\section{ESIL}\label{esil}}

ESIL расшифровывается как ``Evaluable Strings Intermediate Language''.
Технология использует описание на языке, подобном
\href{https://en.wikipedia.org/wiki/Forth_\%28programming_language\%29}{Forth},
семантики оп-кодов операций целевого процессора. Представления ESIL
интерпретируются, имитируя отдельные инструкции. Команды выражения ESIL
разделяются запятыми. Его виртуальная машина описывается так:

\begin{verbatim}
   while ((word=haveCommand())) {
     if (word.isOperator()) {
       esilOperators[word](esil);
     } else {
       esil.push (word);
     }
     nextCommand();
   }
\end{verbatim}

Как мы видим, ESIL использует интерпретатор на основе стека, аналогичный
тому, который обычно используется для калькуляторов. Есть две категории
входных данных: значения и операторы. Значение просто помещается в стек,
затем оператор извлекает значения (если хотите, его аргументы) из стека,
выполняет операцию и помещает результаты (если они есть) обратно в стек.
ESIL использует постфиксную нотацию операций, которые мы хотим
выполнить.

Посмотрим пример:

\begin{verbatim}
4,esp,-=,ebp,esp,=[4]
\end{verbatim}

Догадываетесь, что это такое? Если возьмем запись и преобразуем ее
обратно в инфиксную, получим

\begin{verbatim}
esp -= 4
4bytes(dword) [esp] = ebp
\end{verbatim}

Теперь видно, что это выражение соответствует инструкции x86.
\texttt{push\ ebp}! Круто, да? Цель проекта состоит в том, чтобы
выразить большинство операций, выполняемых процессорами: двоичные
арифметические операции, загрузка и сохранение ячеек памяти, обработка
системных вызовов. Преобразовав инструкции в ESIL, будет видно, что
делает программа во время исполнения. Технология позволяет моделировать
самые загадочные архитектуры, или, если у вас нет устройства для
отладки.

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-esil}{%
\subsection{Использование
ESIL}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-esil}}

Визуальный режим r2 отлично подходит для использования ESIL.

Есть три переменные среды r2, управляющие формой представления процесса
исполнения программы:

\begin{verbatim}
[0x00000000]> e emu.str = true
\end{verbatim}

Переменная \texttt{asm.emu} настраивает r2, таким образом, чтобы
отображалась информация ESIL. Если установлено значение true, справа от
вашего дизассемблированного кода добавятся комментарии, показывающие
изменения содержимого регистров и адресов памяти в результате исполнения
соответствующей инструкции. Например, для инструкции, вычитающей
значение из регистра, ESIL сообщит, каким было значение до и каким оно
становится после исполнения инструкции. Теперь не нужно отслеживать,
какое значение куда идет. Правда при этом приходится воспринимать сразу
много информации, что иногда просто не нужно. В r2 есть хороший
компромисс. Для этого есть \texttt{emu.str} (\texttt{asm.emustr} для
версии r2 \textless= 2.2). Вместо сверхподробного вывода с каждым
значением регистра, настройка добавляет к коду только действительно
полезную информацию, например, строки, найденные по адресам, или
вероятность того, что переход будет выполнен или нет.

Третья важная переменная - \texttt{asm.esil}. Она переключает
дизассемблирование таким образом, что оно больше не показывает
фактически дизассемблированные инструкции, а вместо этого печатает
соответствующие выражения ESIL, описывающие, что делает инструкция. Если
хотите посмотреть, как инструкции выражаются в ESIL, просто установите
значение переменной «asm.esil» в true.

\begin{verbatim}
[0x00000000]> e asm.esil = true
\end{verbatim}

В визуальном режиме также можно переключить эти варианты представления
кода, просто нажав \texttt{О} .

\hypertarget{esil-ux43aux43eux43cux430ux43dux434ux44b}{%
\subsection{ESIL-команды}\label{esil-ux43aux43eux43cux430ux43dux434ux44b}}

\begin{itemize}
\tightlist
\item
  ``ae'' : Вычислить выражение ESIL.
\end{itemize}

\begin{verbatim}
[0x00000000]> "ae 1,1,+"
0x2
[0x00000000]>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  ``aes'' : Шаг ESIL.
\end{itemize}

\begin{verbatim}
[0x00000000]> aes
[0x00000000]>10aes
\end{verbatim}

\begin{itemize}
\tightlist
\item
  ``aeso'' : ESIL Step Over.
\end{itemize}

\begin{verbatim}
[0x00000000]> aeso
[0x00000000]>10aeso
\end{verbatim}

\begin{itemize}
\tightlist
\item
  ``aesu'' : ESIL Step Until.
\end{itemize}

\begin{verbatim}
[0x00001000]> aesu 0x1035
ADDR BREAK
[0x00001019]>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  ``ar'' : Показать/задать регистр ESIL.
\end{itemize}

\begin{verbatim}
[0x00001ec7]> ar r_00 = 0x1035
[0x00001ec7]> ar r_00
0x00001035
[0x00001019]>
\end{verbatim}

\hypertarget{ux43dux430ux431ux43eux440-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux439-esil}{%
\subsubsection{Набор инструкций
ESIL}\label{ux43dux430ux431ux43eux440-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux439-esil}}

Вот полный набор инструкций, используемый виртуальной машиной ESIL:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0517}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0517}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0517}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.0517}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.7931}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Код операции ESIL
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Операнды
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Название
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Операция
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Пример
\end{minipage} \\
\midrule
\endhead
TRAP & src & Trap & Trap-сигнал & \\
**\(** | src | Прерывание | interrupt | 0x80,\) & & & & \\
\textbf{()} & src & Системный вызов & syscall & rax,() \\
\textbf{\$\$} & src & Адрес инструкции & Получить адрес текущей
инструкции стек=адрес инструкции & \\
\textbf{==} & src,dst & Сравнение & stack = (dst == src) ;
update\_eflags(dst - src) & \\
\textbf{\textless{}} & src,dst & Меньше (сравнение с учетом знака) &
stack = (dst \textless{} src) ; update\_eflags(dst - src) &
{[}0x0000000{]}\textgreater{} ``ae 1,5,\textless{}'' 0x0\textgreater{}
``ae 5,5''0x0'' \\
\textbf{\textless=} & src,dst & Меньше или равно (сравнение с учетом
знака) & stack = (dst \textless= src) ; update\_eflags(dst - src) &
{[}0x0000000{]}\textgreater{} ``ae 1,5,\textless{}'' 0x0\textgreater{}
``ae 5,5''0x1'' \\
\textbf{\textgreater{}} & src,dst & Больше (сравнение с учетом знака) &
stack = (dst \textgreater{} src) ; update\_eflags(dst - src) &
\textgreater{} ``ae 1,5,\textgreater{}''0x1\textgreater{} ``ae
5,5,\textgreater{}''0x0 \\
\textbf{\textgreater=} & src,dst & Больше или равно (сравнение с учетом
знака) & stack = (dst \textgreater= src) ; update\_eflags(dst - src) &
\textgreater{} ``ae 1,5,\textgreater=''0x1\textgreater{} ``ae
5,5,\textgreater=''0x1 \\
\textbf{\textless\textless{}} & src,dst & Сдвиг влево & stack = dst
\textless\textless{} src & \textgreater{} ``ae
1,1,\textless\textless{}''0x2\textgreater{} ``ae
2,1,\textless\textless{}''0x4 \\
\textbf{\textgreater\textgreater{}} & src,dst & Сдвиг вправо & stack =
dst \textgreater\textgreater{} src & \textgreater{} ``ae
1,4,\textgreater\textgreater{}''0x2\textgreater{} ``ae
2,4,\textgreater\textgreater{}''0x1 \\
\textbf{\textless\textless\textless{}} & src,dst & Циклический сдвиг
влево & stack=dst ROL src & \textgreater{} ``ae
31,1,\textless\textless\textless{}''0x80000000\textgreater{} ``ae
32,1,\textless\textless\textless{}''0x1 \\
\textbf{\textgreater\textgreater\textgreater{}} & src,dst & Циклический
сдвиг вправо & stack=dst ROR src & \textgreater{} ``ae
1,1,\textgreater\textgreater\textgreater{}''0x80000000\textgreater{}
``ae 32,1,\textgreater\textgreater\textgreater{}''0x1 \\
\textbf{\&} & src,dst & AND & stack = dst \& src & \textgreater{} ``ae
1,1,\&''0x1\textgreater{} ``ae 1,0,\&''0x0\textgreater{} ``ae
0,1,\&''0x0\textgreater{} ``ae 0,0,\&''0x0 \\
\textbf{\textbar{}} & src,dst & OR & stack = dst \textbar{} src &
\textgreater{} ``ae 1,1,\textbar{}''0x1\textgreater{} ``ae
1,0,\textbar{}''0x1\textgreater{} ``ae 0,1,\textbar{}''0x1\textgreater{}
``ae 0,0,\textbar{}''0x0 \\
\textbf{\^{}} & src,dst & XOR & stack = dst \^{}src & \textgreater{}
``ae 1,1,\^{}''0x0\textgreater{} ``ae 1,0,\^{}''0x1\textgreater{} ``ae
0,1,\^{}''0x1\textgreater{} ``ae 0,0,\^{}''0x0 \\
\textbf{+} & src,dst & ADD & stack = dst + src & \textgreater{} ``ae
3,4,+''0x7\textgreater{} ``ae 5,5,+''0xa \\
\textbf{-} & src,dst & SUB & stack = dst - src & \textgreater{} ``ae
3,4,-''0x1\textgreater{} ``ae 5,5,-''0x0\textgreater{} ``ae
4,3,-''0xffffffffffffffff \\
\textbf{*} & src,dst & MUL & stack = dst * src & \textgreater{} ``ae
3,4,*''0xc\textgreater{} ``ae 5,5,*''0x19 \\
\textbf{/} & src,dst & DIV & stack = dst / src & \textgreater{} ``ae
2,4,/''0x2\textgreater{} ``ae 5,5,/''0x1\textgreater{} ``ae
5,9,/''0x1 \\
\textbf{\%} & src,dst & MOD & stack = dst \% src & \textgreater{} ``ae
2,4,\%''0x0\textgreater{} ``ae 5,5,\%''0x0\textgreater{} ``ae
5,9,\%''0x4 \\
\textbf{\textasciitilde{}} & bits,src & SIGNEXT & stack = src sign
extended & \textgreater{} ``ae
8,0x80,\textasciitilde{}''0xffffffffffffff80 \\
\textbf{\textasciitilde/} & src,dst & SIGNED DIV & stack = dst / src
(signed) & \textgreater{} ``ae
2,-4,\textasciitilde/''0xfffffffffffffffe \\
\textbf{\textasciitilde\%} & src,dst & SIGNED MOD & stack = dst \% src
(signed) & \textgreater{} ``ae
2,-5,\textasciitilde\%''0xffffffffffffffff \\
\textbf{!} & src & NEG & stack = !!!src & \textgreater{} ``ae
1,!''0x0\textgreater{} ``ae 4,!''0x0\textgreater{} ``ae 0,!''0x1 \\
\textbf{++} & src & INC & stack = src++ & \textgreater{} ar r\_00=0;ar
r\_000x00000000\textgreater{} ``ae r\_00,++''0x1\textgreater{} ar
r\_000x00000000\textgreater{} ``ae 1,++''0x2 \\
\textbf{--} & src & DEC & stack = src-- & \textgreater{} ar r\_00=5;ar
r\_000x00000005\textgreater{} ``ae r\_00,--''0x4\textgreater{} ar
r\_000x00000005\textgreater{} ``ae 5,--''0x4 \\
\textbf{=} & src,reg & EQU & reg = src & \textgreater{} ``ae
3,r\_00,=''\textgreater{} aer r\_000x00000003\textgreater{} ``ae
r\_00,r\_01,=''\textgreater{} aer r\_010x00000003 \\
\textbf{:=} & src,reg & слвбое EQU & reg = src without side effects &
\textgreater{} ``ae 3,r\_00,:=''\textgreater{} aer
r\_000x00000003\textgreater{} ``ae r\_00,r\_01,:=''\textgreater{} aer
r\_010x00000003 \\
\textbf{+=} & src,reg & ADD eq & reg = reg + src & \textgreater{} ar
r\_01=5;ar r\_00=0;ar r\_000x00000000\textgreater{} ``ae
r\_01,r\_00,+=''\textgreater{} ar r\_000x00000005\textgreater{} ``ae
5,r\_00,+=''\textgreater{} ar r\_000x0000000a \\
\textbf{-=} & src,reg & SUB eq & reg = reg - src & \textgreater{} ``ae
r\_01,r\_00,-=''\textgreater{} ar r\_000x00000004\textgreater{} ``ae
3,r\_00,-=''\textgreater{} ar r\_000x00000001 \\
\textbf{*=} & src,reg & MUL eq & reg = reg * src & \textgreater{} ar
r\_01=3;ar r\_00=5;ar r\_000x00000005\textgreater{} ``ae
r\_01,r\_00,*=''\textgreater{} ar r\_000x0000000f\textgreater{} ``ae
2,r\_00,*=''\textgreater{} ar r\_000x0000001e \\
\textbf{/=} & src,reg & DIV eq & reg = reg / src & \textgreater{} ar
r\_01=3;ar r\_00=6;ar r\_000x00000006\textgreater{} ``ae
r\_01,r\_00,/=''\textgreater{} ar r\_000x00000002\textgreater{} ``ae
1,r\_00,/=''\textgreater{} ar r\_000x00000002 \\
\textbf{\%=} & src,reg & MOD eq & reg = reg \% src & \textgreater{} ar
r\_01=3;ar r\_00=7;ar r\_00 0x00000007 \textgreater{} ``ae
r\_01,r\_00,\%='' \textgreater{} ar r\_00 0x00000001 \textgreater{} ar
r\_00=9;ar r\_00 0x00000009 \textgreater{} ``ae 5,r\_00,\%=''
\textgreater{} ar r\_00 0x00000004 \\
\textbf{\textless\textless=} & src,reg & Shift Left eq & reg = reg
\textless\textless{} src & \textgreater{} ar r\_00=1;ar r\_01=1;ar
r\_010x00000001\textgreater{} ``ae
r\_00,r\_01,\textless\textless=''\textgreater{} ar
r\_010x00000002\textgreater{} ``ae
2,r\_01,\textless\textless=''\textgreater{} ar r\_010x00000008 \\
\textbf{\textgreater\textgreater=} & src,reg & Shift Right eq & reg =
reg \textless\textless{} src & \textgreater{} ar r\_00=1;ar r\_01=8;ar
r\_010x00000008\textgreater{} ``ae
r\_00,r\_01,\textgreater\textgreater=''\textgreater{} ar
r\_010x00000004\textgreater{} ``ae
2,r\_01,\textgreater\textgreater=''\textgreater{} ar r\_010x00000001 \\
\textbf{\&=} & src,reg & AND eq & reg = reg \& src & \textgreater{} ar
r\_00=2;ar r\_01=6;ar r\_010x00000006\textgreater{} ``ae
r\_00,r\_01,\&=''\textgreater{} ar r\_010x00000002\textgreater{} ``ae
2,r\_01,\&=''\textgreater{} ar r\_010x00000002\textgreater{} ``ae
1,r\_01,\&=''\textgreater{} ar r\_010x00000000 \\
\textbf{\textbar=} & src,reg & OR eq & reg = reg \textbar{} src &
\textgreater{} ar r\_00=2;ar r\_01=1;ar r\_010x00000001\textgreater{}
``ae r\_00,r\_01,\textbar=''\textgreater{} ar
r\_010x00000003\textgreater{} ``ae 4,r\_01,\textbar=''\textgreater{} ar
r\_010x00000007 \\
\textbf{\^{}=} & src,reg & XOR eq & reg = reg \^{} src & \textgreater{}
ar r\_00=2;ar r\_01=0xab;ar r\_010x000000ab\textgreater{} ``ae
r\_00,r\_01,\^{}=''\textgreater{} ar r\_010x000000a9\textgreater{} ``ae
2,r\_01,\^{}=''\textgreater{} ar r\_010x000000ab \\
\textbf{++=} & reg & INC eq & reg = reg + 1 & \textgreater{} ar
r\_00=4;ar r\_000x00000004\textgreater{} ``ae r\_00,++=''\textgreater{}
ar r\_000x00000005 \\
\textbf{--=} & reg & DEC eq & reg = reg - 1 & \textgreater{} ar
r\_00=4;ar r\_000x00000004\textgreater{} ``ae r\_00,--=''\textgreater{}
ar r\_000x00000003 \\
\textbf{!=} & reg & NOT eq & reg = !reg & \textgreater{} ar r\_00=4;ar
r\_000x00000004\textgreater{} ``ae r\_00,!=''\textgreater{} ar
r\_000x00000000\textgreater{} ``ae r\_00,!=''\textgreater{} ar
r\_000x00000001 \\
--- & --- & --- & --- &
---------------------------------------------- \\
={[}{]}={[}*{]}={[}1{]}={[}2{]}={[}4{]}={[}8{]} & src,dst & poke &
*dst=src & \textgreater{} ``ae
0xdeadbeef,0x10000,={[}4{]},''\textgreater{} pxw 4@0x100000x00010000
0xdeadbeef \ldots.\textgreater{} ``ae
0x0,0x10000,={[}4{]},''\textgreater{} pxw 4@0x100000x00010000
0x00000000 \\
{[}{]}{[}*{]}{[}1{]}{[}2{]}{[}4{]}{[}8{]} & src & peek & stack=*src &
\textgreater{} w test@0x10000\textgreater{} ``ae
0x10000,{[}4{]},''0x74736574\textgreater{} ar
r\_00=0x10000\textgreater{} ``ae r\_00,{[}4{]},''0x74736574 \\
\textbar={[}{]}\textbar={[}1{]}\textbar={[}2{]}\textbar={[}4{]}\textbar={[}8{]}
& reg & nombre & code & \textgreater{} \textgreater{} \\
SWAP & & Swap & Поменять местами два верхних элемента & SWAP \\
DUP & & Duplicate & Дублировать верхний элемент в стеке & DUP \\
NUM & & Numeric & Если верхний элемент является ссылкой (регистровое
имя, метка и т.д.), разыменовать его и положить на стек его реальное
значение & NUM \\
CLEAR & & Clear & Очистить стек & CLEAR \\
BREAK & & Break & Останавливает эмуляцию ESIL & BREAK \\
GOTO & n & Goto & Переход к N-му слову ESIL & GOTO 5 \\
TODO & & To Do & Останавливает выполнение (причина: выражение ESIL не
завершено) & TODO \\
\bottomrule
\end{longtable}

\hypertarget{ux444ux43bux430ux433ux438-esil}{%
\subsubsection{Флаги ESIL}\label{ux444ux43bux430ux433ux438-esil}}

Виртуальная машина ESIL по умолчанию предоставляет набор вспомогательных
операций для вычисления флагов. Они выполняют свою задачу, сравнивая
старое и новое значение операнда dst последней выполненной операции eq.
На каждой операции eq (например, \texttt{==}) ESIL сохраняет старое и
новое значение операнда dst. Обратите внимание, что существуют также
слабые операции eq (например, \texttt{:=}), которые не влияют на
операции с флагами. Операция \texttt{==} влияет на операции с флагами,
несмотря на то, что она не является операцией eq. Операции с флагами
задаются префиксным символом \texttt{\$}.

\begin{verbatim}
z      - флаг zero (ноль) устанавливается только если результат был 0
b      - флаг borrow (заем), требует указывать из какого бита занимать (пример: 4,$b - проверяет, можно ли занимать из бита 4)
c      - флаг carry (перенос), то же что выше(пример: 7,$c - проверяет наличие переноса из бита 7)
o      - флаг overflow (переполнение)
p      - флаг parity (четность)
r      - флаг regsize (изменение размера) ( asm.bits/8 )
s      - флаг sign (знак)
ds     - delay slot state
jt     - jump target
js     - jump target set
\end{verbatim}

\hypertarget{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux438-ux43aux43eux43cux430ux43dux434ux44b}{%
\subsection{Синтаксис и
команды}\label{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux438-ux43aux43eux43cux430ux43dux434ux44b}}

Целевой оп-код транслируется в список выражений ESIL, разделенных
запятыми.

\begin{verbatim}
xor eax, eax    ->    0,eax,=,1,zf,=
\end{verbatim}

Доступ к памяти определяется операциями ``скобки'':

\begin{verbatim}
mov eax, [0x80480]   ->   0x80480,[],eax,=
\end{verbatim}

Размер данных по умолчанию определяется размером операнда назначения.

\begin{verbatim}
movb $0, 0x80480     ->   0,0x80480,=[1]
\end{verbatim}

Оператор \texttt{?} использует значение своего аргумента, решает,
следует ли вычислять выражение в фигурных скобках.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Значение равно нулю? -\textgreater{} Пропустить.
\item
  Значение не равно нулю? -\textgreater{} Вычислить.
\end{enumerate}

\begin{verbatim}
cmp eax, 123  ->   123,eax,==,$z,zf,=
jz eax        ->   zf,?{,eax,eip,=,}
\end{verbatim}

Запустить несколько выражений под условным выражением можно, поместив их
в фигурные скобки:

\begin{verbatim}
zf,?{,eip,esp,=[],eax,eip,=,$r,esp,-=,}
\end{verbatim}

Пробелы, переводы строки и другие символы игнорируются. Итак, первое,
что нужно сделать при подготовке ESIL-программы, --- удалить пробелы:

\begin{verbatim}
esil = r_str_replace (esil, " ", "", R_TRUE);
\end{verbatim}

Системные вызовы нуждаются в особой обработке. Они обозначаются символом
«\$» в начале выражения. Можно передать необязательное числовое значение
- номер системного вызова. Эмулятор ESIL должен обрабатывать системные
вызовы. Смотри (r\_esil\_syscall).

\hypertarget{ux43fux43eux440ux44fux434ux43eux43a-ux430ux440ux433ux443ux43cux435ux43dux442ux43eux432-ux434ux43bux44f-ux43dux435ux430ux441ux441ux43eux446ux438ux430ux442ux438ux432ux43dux44bux445-ux43eux43fux435ux440ux430ux446ux438ux439}{%
\subsection{Порядок аргументов для неассоциативных
операций}\label{ux43fux43eux440ux44fux434ux43eux43a-ux430ux440ux433ux443ux43cux435ux43dux442ux43eux432-ux434ux43bux44f-ux43dux435ux430ux441ux441ux43eux446ux438ux430ux442ux438ux432ux43dux44bux445-ux43eux43fux435ux440ux430ux446ux438ux439}}

Как обсуждалось в IRC, текущая реализация работает следующим образом:

\begin{verbatim}
a,b,-      b - a
a,b,/=     b /= a
\end{verbatim}

Такой вариант более удобочитаем, но менее удобен для стека.

\hypertarget{ux441ux43fux435ux446ux438ux430ux43bux44cux43dux44bux435-ux443ux43aux430ux437ux430ux43dux438ux44f}{%
\subsubsection{Специальные
указания}\label{ux441ux43fux435ux446ux438ux430ux43bux44cux43dux44bux435-ux443ux43aux430ux437ux430ux43dux438ux44f}}

NOP представлены в виде пустых строк. Как было сказано выше, прерывания
помечаются командой '\('. Например, «0x80,\)». Он делегирует эмуляцию с
машины ESIL callback-функции, реализующей обработчик прерывания для
конкретной ОС/ядра/платформы.

Аппаратные прерывания (traps) реализованы при помощи команды
\texttt{TRAP}. Они используются для создания исключений для недопустимых
инструкций, деления на ноль, ошибки чтения памяти или любых других
действий, необходимых для конкретных архитектур.

\hypertarget{ux44dux43aux441ux43fux440ux435ux441ux441-ux430ux43dux430ux43bux438ux437}{%
\subsubsection{Экспресс-анализ}\label{ux44dux43aux441ux43fux440ux435ux441ux441-ux430ux43dux430ux43bux438ux437}}

Вот список некоторых экспресс-проверок для извлечения информации из
строки ESIL. Соответствующая информация, вероятно, будет найдена в
первом выражении списка.

\begin{verbatim}
indexOf('[')    -> включает ссылки на ячейки памяти
indexOf("=[")   -> пишет в память
indexOf("pc,=") -> изменяет счетчик инструкций (branch, jump, call)
indexOf("sp,=") -> изменяет стек (что если мы нашли sp+= или sp-=?)
indexOf("=")    -> получить src и dst
indexOf(":")    -> впереди неизвестный esil-, raw-оп-код
indexOf("$")    -> получает доступ к флагам виртуальной машиня esil, например: $z
indexOf("$")    -> системный вызов, например: 1,$
indexOf("TRAP") -> может перехватить
indexOf('++')   -> включает итератор
indexOf('--')   -> считает до 0
indexOf("?{")   -> условный оператор
equalsTo("")    -> пустая строка, вроде nop (будет неправдой, если мы добавим pc+=x)
\end{verbatim}

Общие операции: * Проверить dstreg. * Проверить srcreg. * Получить
целевой адрес. * Переход? * Условие? * Вычислить. * Системный вызов?

\hypertarget{ux444ux43bux430ux433ux438-ux446ux43f}{%
\subsubsection{Флаги ЦП}\label{ux444ux43bux430ux433ux438-ux446ux43f}}

Флаги ЦП обычно определяются как однобитные регистры в профиле RReg.
Иногда их можно найти в типе регистра `flg'.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435}{%
\subsubsection{Переменные}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435}}

Свойства переменных виртуальной машины:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  У них нет предопределенной разрядности. Таким образом, их при
  необходимости, легко расширить до 128, 256 и 512 бит, например, для
  MMX, SSE, AVX, Neon SIMD.
\item
  Может быть неограниченное количество переменных. Это сделано для
  совместимости с SSA-формами.
\item
  Имена регистров не имеют определенного синтаксиса. Это просто строки.
\item
  Числа могут быть указаны в любой системе счисления, поддерживаемой
  RNum (десятичная, шестнадцатеричная, восьмеричная, двоичная\ldots).
\item
  Каждый бэкенд ESIL должен иметь связанный профиль RReg для описания
  спецификаций регистра ESIL.
\end{enumerate}

\hypertarget{ux431ux438ux442ux43eux432ux44bux435-ux43cux430ux441ux441ux438ux432ux44b}{%
\subsubsection{Битовые
массивы}\label{ux431ux438ux442ux43eux432ux44bux435-ux43cux430ux441ux441ux438ux432ux44b}}

Что с ними можно сделать? А как насчет битовой арифметики, если
использовать переменные вместо регистров?

\hypertarget{ux430ux440ux438ux444ux43cux435ux442ux438ux43aux430}{%
\subsubsection{Арифметика}\label{ux430ux440ux438ux444ux43cux435ux442ux438ux43aux430}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ADD (``+''),
\item
  MUL (``*''),
\item
  SUB (``-''),
\item
  DIV (``/''),
\item
  MOD (``\%'').
\end{enumerate}

\hypertarget{ux431ux438ux442ux43eux432ux430ux44f-ux430ux440ux438ux444ux43cux435ux442ux438ux43aux430}{%
\subsubsection{Битовая
арифметика}\label{ux431ux438ux442ux43eux432ux430ux44f-ux430ux440ux438ux444ux43cux435ux442ux438ux43aux430}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  AND ``\&'',
\item
  OR ``\textbar{}'',
\item
  XOR ``\^{}'',
\item
  SHL ``\textless\textless{}'',
\item
  SHR ``\textgreater\textgreater{}'',
\item
  ROL ``\textless\textless\textless{}'',
\item
  ROR ``\textgreater\textgreater\textgreater{}'',
\item
  NEG ``!''.
\end{enumerate}

\hypertarget{ux43fux43eux434ux434ux435ux440ux436ux43aux430-ux443ux441ux442ux440ux43eux439ux441ux442ux432-ux441-ux43fux43bux430ux432ux430ux44eux449ux435ux439-ux437ux430ux43fux44fux442ux43eux439}{%
\subsubsection{Поддержка устройств с плавающей
запятой}\label{ux43fux43eux434ux434ux435ux440ux436ux43aux430-ux443ux441ux442ux440ux43eux439ux441ux442ux432-ux441-ux43fux43bux430ux432ux430ux44eux449ux435ux439-ux437ux430ux43fux44fux442ux43eux439}}

На момент написания этой статьи ESIL еще не поддерживает FPU. Можете
реализовать поддержку неподдерживаемых инструкций с помощью r2pipe. Рано
или поздно мы получим надлежащую поддержку мультимедиа и операций с
плавающей запятой.

\hypertarget{ux43eux431ux440ux430ux431ux43eux442ux43aux430-ux43fux440ux435ux444ux438ux43aux441ux430-x86-rep-ux432-esil}{%
\subsubsection{Обработка префикса x86 REP в
ESIL}\label{ux43eux431ux440ux430ux431ux43eux442ux43aux430-ux43fux440ux435ux444ux438ux43aux441ux430-x86-rep-ux432-esil}}

ESIL указывает, что команды анализа потока управления должны быть в
верхнем регистре. Имейте в виду, что некоторые архитектуры используют
имена регистров в верхнем регистре. Соответствующий профиль регистра
должен позаботиться о том, чтобы не использовать повторно ни одно из
следующего:

\begin{verbatim}
3,SKIP   - пропустить N инструкций, создает относительные переходы GOTO вперед
3,GOTO   - переход к инструкции 3
LOOP     - псевдоним для 0,GOTO
BREAK    - закончить вычислять выражение
STACK    - вывести содержимое стека на экран
CLEAR    - очистить стек
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux440-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f-1}{%
\paragraph{Пример
использования:}\label{ux43fux440ux438ux43cux435ux440-ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux44f-1}}

rep cmpsb

\begin{verbatim}
cx,!,?{,BREAK,},esi,[1],edi,[1],==,?{,BREAK,},esi,++,edi,++,cx,--,0,GOTO
\end{verbatim}

\hypertarget{ux43dux435ux440ux435ux430ux43bux438ux437ux43eux432ux430ux43dux43dux44bux435ux43dux435ux43eux431ux440ux430ux431ux43eux442ux430ux43dux43dux44bux435-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux438}{%
\subsubsection{Нереализованные/необработанные
инструкции}\label{ux43dux435ux440ux435ux430ux43bux438ux437ux43eux432ux430ux43dux43dux44bux435ux43dux435ux43eux431ux440ux430ux431ux43eux442ux430ux43dux43dux44bux435-ux438ux43dux441ux442ux440ux443ux43aux446ux438ux438}}

Они выражаются командой TODO. Они действуют как «BREAK», но отображают
предупреждающее сообщение о том, что инструкция не реализована и не
будет эмулироваться. Например:

\begin{verbatim}
fmulp ST(1), ST(0)      =>      TODO,fmulp ST(1),ST(0)
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux440-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f-esil}{%
\subsubsection{Пример дизассемблирования
ESIL:}\label{ux43fux440ux438ux43cux435ux440-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f-esil}}

\begin{verbatim}
[0x1000010f8]> e asm.esil=true
[0x1000010f8]> pd $r @ entry0
0x1000010f8    55           8,rsp,-=,rbp,rsp,=[8]
0x1000010f9    4889e5       rsp,rbp,=
0x1000010fc    4883c768     104,rdi,+=
0x100001100    4883c668     104,rsi,+=
0x100001104    5d           rsp,[8],rbp,=,8,rsp,+=
0x100001105    e950350000   0x465a,rip,= ;[1]
0x10000110a    55           8,rsp,-=,rbp,rsp,=[8]
0x10000110b    4889e5       rsp,rbp,=
0x10000110e    488d4668     rsi,104,+,rax,=
0x100001112    488d7768     rdi,104,+,rsi,=
0x100001116    4889c7       rax,rdi,=
0x100001119    5d           rsp,[8],rbp,=,8,rsp,+=
0x10000111a    e93b350000   0x465a,rip,= ;[1]
0x10000111f    55           8,rsp,-=,rbp,rsp,=[8]
0x100001120    4889e5       rsp,rbp,=
0x100001123    488b4f60     rdi,96,+,[8],rcx,=
0x100001127    4c8b4130     rcx,48,+,[8],r8,=
0x10000112b    488b5660     rsi,96,+,[8],rdx,=
0x10000112f    b801000000   1,eax,=
0x100001134    4c394230     rdx,48,+,[8],r8,==,cz,?=
0x100001138    7f1a         sf,of,!,^,zf,!,&,?{,0x1154,rip,=,} ;[2]
0x10000113a    7d07         of,!,sf,^,?{,0x1143,rip,} ;[3]
0x10000113c    b8ffffffff   0xffffffff,eax,= ;  0xffffffff
0x100001141    eb11         0x1154,rip,= ;[2]
0x100001143    488b4938     rcx,56,+,[8],rcx,=
0x100001147    48394a38     rdx,56,+,[8],rcx,==,cz,?=
\end{verbatim}

\hypertarget{ux438ux43dux442ux440ux43eux441ux43fux435ux43aux446ux438ux44f}{%
\subsubsection{Интроспекция}\label{ux438ux43dux442ux440ux43eux441ux43fux435ux43aux446ux438ux44f}}

Чтобы упростить синтаксический анализ ESIL, у нас должен быть способ
представления выражений интроспекции для извлечения нужных нам данных.
Например, мы можем захотеть получить целевой адрес перехода. Транслятор
выражений ESIL должен предлагать API, позволяющий легко извлекать
информацию путем анализа выражений.

\begin{verbatim}
>  ao~esil,opcode
opcode: jmp 0x10000465a
esil: 0x10000465a,rip,=
\end{verbatim}

Нам нужен способ получить числовое значение `rip'. Это очень простой
пример, но есть и посложнее, вроде условных. Нам нужны выражения, чтобы
иметь возможность получить:

\begin{itemize}
\tightlist
\item
  тип кода операции,
\item
  целевой адрес перехода,
\item
  состояние, от которых что-то зависит,
\item
  список измененных регистров (write),
\item
  список использованных (accessed) регистров (read).
\end{itemize}

\hypertarget{api-hooks}{%
\subsubsection{API HOOKS}\label{api-hooks}}

Для эмуляции важно иметь возможность устанавливать хуки в синтаксическом
анализаторе, так, чтобы можно было расширить его для реализации анализа
без необходимости изменять его снова и снова. То есть каждый раз,
непосредственно перед выполнением операции, вызывается пользовательский
хук. Его можно использовать, например, для определения того, собирается
ли \texttt{RIP} измениться, обновляет ли стек инструкция. Позже можно
разделить этот callback на несколько и выполнить событийный анализ на
основе API, который можно расширить в JavaScript следующим образом:

\begin{verbatim}
esil.on('regset', function(){..
esil.on('syscall', function(){esil.regset('rip'
\end{verbatim}

API содержит функции \texttt{hook\_flag\_read()},
\texttt{hook\_execute()} и \texttt{hook\_mem\_read()}. Callbak должен
возвращать true или 1, если надо переопределить выполняемое им действие.
Например, чтобы запретить чтение памяти в регионе или отменить запись в
память, фактически сделав ее доступной только для чтения. Верните false
или 0, если вы хотите отслеживать синтаксический анализ выражения ESIL.

Для работы других операций требуются привязки к внешним функциям. То
есть к \texttt{r\_ref} и \texttt{r\_io}. Это должно быть определено при
инициализации виртуальной машины ESIL.

\begin{itemize}
\tightlist
\item
  Io Get/Set \texttt{Out\ ax,\ 44\ \ 44,ax,:ou}
\item
  Селекторы (cs, ds, gs\ldots)
  \texttt{Mov\ eax,\ ds:{[}ebp+8{]}\ \ Ebp,8,+,:ds,eax,=}
\end{itemize}

\hypertarget{ux430ux43dux430ux43bux438ux437-ux434ux430ux43dux43dux44bux445-ux438-ux43aux43eux434ux430}{%
\section{Анализ данных и
кода}\label{ux430ux43dux430ux43bux438ux437-ux434ux430ux43dux43dux44bux445-ux438-ux43aux43eux434ux430}}

Radare2 имеет очень богатый набор команд и параметров конфигурации для
выполнения анализа данных и кода, извлекать полезную информацию из
двоичного файла, такую как указатели, ссылки на строки, базовые блоки,
оп-коды, адреса переходов, перекрестные ссылки и многое другое. Эти
операции обрабатываются семейством команд \texttt{a} (analyze):

\begin{verbatim}
|Usage: a[abdefFghoprxstc] [...]
| aa[?]              анализировать все (fcns + bbs) (aa0, если не требуется переименование подпрограмм)
| a8 [hexpairs]      анализировать байты
| ab[b] [addr]       анализировать блок по заданному адресу
| abb [len]          анализировать N базовых блоков при ограниценни [len] или section.size по умолчанию
| abt [addr]         найти траектории (paths) в графе функций bb с текущего смещения до заданного адреса
| ac [cycles]        анализировать, какие оп-коды могут быть запущены в [cycles]
| ad[?]              анализировать "трамплин" данных (wip)
| ad [from] [to]     анализировать указатели на данные (from-to)
| ae[?] [expr]       анализировать результат вычисления выражения из оп-кодов (смотрите ao)
| af[?]              анализировать функции
| aF                 то же, что выше, но с использованием anal.depth=1
| ag[?] [options]    отрисовывать граф в различных форматах
| ah[?]              запустить анализ с подсказками (с указанием размера оп-кода, ...)
| ai [addr]          информация о адресе (показать разрешения, стек, хип, ...)
| an [name] [@addr]  показать/преименовать/создать флаги/функции, привязываемые к адресу
| ao[?] [len]        анализировать оп-коды (или провести их эмуляцию)
| aO[?] [len]        анализировать N инструкций в M байтах
| ap                 найти прелюдию для текущего смещения
| ar[?]              как 'dr', но для виртуальной машины ESIL (регистры)
| as[?] [num]        анализировать системный вызов, используя dbg.reg
| av[?] [.]          показать переменные
| ax[?]              управление ссфлками и кросс-сылками (xrefs), смотрите также afx?
\end{verbatim}

Фактически пространство имен \texttt{a} является одним из самых больших
в radare2 и позволяет управлять разными частями процедуры анализа:

\begin{itemize}
\tightlist
\item
  Анализ тела функций,
\item
  Анализ ссылок на данные,
\item
  Использование загруженных символов,
\item
  Управление различными типами графов, таких как CFG и граф вызовов,
\item
  Управление переменными,
\item
  Управление типами,
\item
  Эмуляция с помощью виртуальной машины ESIL,
\item
  Интроспекция оп-кодов,
\item
  Информация об объектах, например виртуальных таблиц.
\end{itemize}

\hypertarget{ux430ux43dux430ux43bux438ux437-ux43aux43eux434ux430}{%
\section{Анализ
кода}\label{ux430ux43dux430ux43bux438ux437-ux43aux43eux434ux430}}

Анализ кода является распространенным методом, используемым для
извлечения информации из ассемблерного кода. Radare2 включает различные
методы анализа кода, реализованные в ядре и доступные в разных командах.
Все функциональные возможности r2 доступны также при помощи API. API
дает возможность реализовать новые этапы анализа, используя какой-либо
язык программирования, и даже при помощи командной строки r2, скриптов в
операционной системе, реализовать алгоритмы при помощи плагинов. Цель
анализа --- выявить внутренние структуры данных для идентификации
\emph{базовых блоков} (наборов инструкция процессора, ограниченных
метками и адресными переходами), \emph{вызовов функций} и извлечения
\emph{информации} на уровне \emph{оп-кодов}.

Наиболее распространенной последовательностью команд анализа radare2
является \texttt{aa}, что расшифровывается как «\emph{analyze all}». Это
относится ко всем символам и точкам входа. Если в двоичном файле удалены
(stripped) символы, нужно использовать другие команды, такие как
\texttt{aaa}, \texttt{aab}, \texttt{aar}, \texttt{aac} и им подобные.
Каждая команда выявляет свою информацию, и для эффективного их
использования необходимо ознакомиться в ними и подобрать набор для
решения конкретных задач.

\begin{verbatim}
[0x08048440]> aa
[0x08048440]> pdf @ main
           ; DATA XREF from 0x08048457 (entry0)
/ (fcn) fcn.08048648 141
|     ;-- main:
|     0x08048648    8d4c2404     lea ecx, [esp+0x4]
|     0x0804864c    83e4f0       and esp, 0xfffffff0
|     0x0804864f    ff71fc       push dword [ecx-0x4]
|     0x08048652    55           push ebp
|     ; CODE (CALL) XREF from 0x08048734 (fcn.080486e5)
|     0x08048653    89e5         mov ebp, esp
|     0x08048655    83ec28       sub esp, 0x28
|     0x08048658    894df4       mov [ebp-0xc], ecx
|     0x0804865b    895df8       mov [ebp-0x8], ebx
|     0x0804865e    8975fc       mov [ebp-0x4], esi
|     0x08048661    8b19         mov ebx, [ecx]
|     0x08048663    8b7104       mov esi, [ecx+0x4]
|     0x08048666    c744240c000. mov dword [esp+0xc], 0x0
|     0x0804866e    c7442408010. mov dword [esp+0x8], 0x1 ;  0x00000001
|     0x08048676    c7442404000. mov dword [esp+0x4], 0x0
|     0x0804867e    c7042400000. mov dword [esp], 0x0
|     0x08048685    e852fdffff   call sym..imp.ptrace
|        sym..imp.ptrace(unk, unk)
|     0x0804868a    85c0         test eax, eax
| ,=< 0x0804868c    7911         jns 0x804869f
| |   0x0804868e    c70424cf870. mov dword [esp], str.Don_tuseadebuguer_ ;  0x080487cf
| |   0x08048695    e882fdffff   call sym..imp.puts
| |      sym..imp.puts()
| |   0x0804869a    e80dfdffff   call sym..imp.abort
| |      sym..imp.abort()
| `-> 0x0804869f    83fb02       cmp ebx, 0x2
|,==< 0x080486a2    7411         je 0x80486b5
||    0x080486a4    c704240c880. mov dword [esp], str.Youmustgiveapasswordforusethisprogram_ ;  0x0804880c
||    0x080486ab    e86cfdffff   call sym..imp.puts
||       sym..imp.puts()
||    0x080486b0    e8f7fcffff   call sym..imp.abort
||       sym..imp.abort()
|`--> 0x080486b5    8b4604       mov eax, [esi+0x4]
|     0x080486b8    890424       mov [esp], eax
|     0x080486bb    e8e5feffff   call fcn.080485a5
|        fcn.080485a5() ; fcn.080484c6+223
|     0x080486c0    b800000000   mov eax, 0x0
|     0x080486c5    8b4df4       mov ecx, [ebp-0xc]
|     0x080486c8    8b5df8       mov ebx, [ebp-0x8]
|     0x080486cb    8b75fc       mov esi, [ebp-0x4]
|     0x080486ce    89ec         mov esp, ebp
|     0x080486d0    5d           pop ebp
|     0x080486d1    8d61fc       lea esp, [ecx-0x4]
\     0x080486d4    c3           ret
\end{verbatim}

В этом примере анализируется весь файл (\texttt{aa}), а затем печатается
дизассемблирование функции \texttt{main()} (\texttt{pdf}). Команда
\texttt{aa} относится к семейству команд автоматического анализа и
выполняет только самые основные этапы автоматического анализа. В radare2
существует множество различных типов команд автоматического анализа с
различной ``глубиной'' анализа, включая частичную эмуляцию: \texttt{aa},
\texttt{aaa}, \texttt{aab}, \texttt{aaaa}, \ldots{} Существует также
аналоги этих команд в виде флагов командной строки r2: \texttt{r2\ -A},
\texttt{r2\ -AA} и так далее.

Полностью автоматизированный анализ может дать противоречивые
результаты. Ранее было сказано, что radare2 предоставляет отдельные
команды для конкретных этапов анализа, что позволяет контролировать
процесс выявления информации об алгоритме и структурах данных.
Существует большой набор конфигурационных переменных для управления
результатами анализа. Их можно найти в пространстве имен \texttt{anal.*}
и \texttt{emu.*}.

\hypertarget{ux430ux43dux430ux43bux438ux437-ux444ux443ux43dux43aux446ux438ux439}{%
\subsection{Анализ
функций}\label{ux430ux43dux430ux43bux438ux437-ux444ux443ux43dux43aux446ux438ux439}}

Одной из наиболее важных команд анализа является набор команд
\texttt{af}. Комбинация\texttt{af} означает ``\emph{анализ функций}''
(analyze function). Команда запускает автоматический анализ заданной
функции. При желании описать функцию можно и вручную.

\begin{verbatim}
[0x00000000]> af?
Usage: af
| af ([name]) ([addr])                  анализ функций, начиная с заданного смещения или с $$
| afr ([name]) ([addr])                 анализировать функции рекурсивно
| af+ addr name [type] [diff]           ручной анализ функции (требует afb+)
| af- [addr]                            стереть все данные анализа функции (можно задавать смещением)
| afa                                   анализировать аргументы функции в точке вызова (afal управляется переменной dbg.funcarg)
| afb+ fcnA bbA sz [j] [f] ([t]( [d]))  добавить bb к функции @ fcnaddr
| afb[?] [addr]                         перечислить базовые блоки заданной функции
| afbF([0|1])                           скрыть/раскрыть базовый блок (переключить атрибут 'folded')
| afB 16                                сделать текущую функцию как "основную" (thumb) (настраивается переменной asm.bits)
| afC[lc] ([addr])@[addr]               вычислить Cycles (afC) или Cyclomatic Complexity (afCc)
| afc[?] type @[addr]                   установить соглашение о вызове для функции
| afd[addr]                             показать функцию + адрес для заданного смещения
| afF[1|0|]                             скрыть/раскрыть/переключить
| afi [addr|fcn.name]                   показать информацию о функциях (более подробный afl)
| afj [tableaddr] [count]               анализировать таблицу переходов функции
| afl[?] [ls*] [fcn name]               перечислить функции (смещение, размер, bbs, имя) (смотрите afll)
| afm name                              объединить две функции
| afM name                              вывести карту функций
| afn[?] name [addr]                    переименования функции по заданному адресу (поменять и флаг)
| afna                                  предложить имя функции автоматически для текущего смещения
| afo[?j] [fcn.name]                    показать адрес функции по ее адресу или текущему смещению
| afs[!] ([fcnsign])                    показать/установить сигнатуру функции по текущему смещению (afs! использует cfg.editor)
| afS[stack_size]                       установить размер фрейма стека для функции по текущему смещению
| afsr [function_name] [new_type]       изменить тит для заданной функции
| aft[?]                                сопоставление и распространение (propagation) типов
| afu addr                              изменть размер текущей функции в соответствии с заданным конечным смещением, затем провести ее анализ
| afv[absrx]?                           изменить данные об аргументах, регистрах и переменных функции
| afx                                   перечислить ссылки на функцию
\end{verbatim}

Используйте \texttt{afl} для перечисления найденных в результате анализа
функций. В группе \texttt{afl} есть еще много полезных команд, таких как
\texttt{aflj}, которая выводит данные о функции в формате JSON,
\texttt{aflm}, представляющая функции в виде, аналогичном makefile. Есть
также \texttt{afl=}, отображающая ASCII-арт-схему памяти функции.
Остальные команды можно найти, набрав \texttt{afl?}.

Некоторые из наиболее сложных задач при выполнении анализа функций ---
это слияние, обрезка и изменение ее размера. Как и в случае с другими
командами анализа, есть два режима: полуавтоматический и ручной. В
полуавтоматическом режиме можно использовать
\texttt{afm\ \textless{}function\ name\textgreater{}} для объединения
текущей функции с другой, указанной именем в аргументе команды,
\texttt{aff} проведет повторный анализ функции после сделанных изменений
или ее редактирования, \texttt{afu\ \textless{}address\textgreater{}}
--- изменение размера функции, задаваемого конечным смещением, и
повторный ее анализ.

Помимо перечисленных выше полуавтоматических способов редактирования /
анализа функции, анализ можно проводить в ручном режиме с помощью
команды \texttt{af+}, редактировать базовые блоки при помощи команд
\texttt{afb}. Перед изменением базовых блоков функции рекомендуется
сначала ознакомиться с уже имеющимися:

\begin{verbatim}
[0x00003ac0]> afb
0x00003ac0 0x00003b7f 01:001A 191 f 0x00003b7f
0x00003b7f 0x00003b84 00:0000 5 j 0x00003b92 f 0x00003b84
0x00003b84 0x00003b8d 00:0000 9 f 0x00003b8d
0x00003b8d 0x00003b92 00:0000 5
0x00003b92 0x00003ba8 01:0030 22 j 0x00003ba8
0x00003ba8 0x00003bf9 00:0000 81
\end{verbatim}

\hypertarget{ux430ux43dux430ux43bux438ux437-ux444ux443ux43dux43aux446ux438ux438-ux432ux440ux443ux447ux43dux443ux44e}{%
\subsubsection{Анализ функции
вручную}\label{ux430ux43dux430ux43bux438ux437-ux444ux443ux43dux43aux446ux438ux438-ux432ux440ux443ux447ux43dux443ux44e}}

Давайте сначала создадим двоичный файл, например:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ code\_block}\OperatorTok{()}
\OperatorTok{\{}
  \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

  \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;} \OperatorTok{++}\NormalTok{i}\OperatorTok{)}
\NormalTok{    result }\OperatorTok{+=} \DecValTok{1}\OperatorTok{;}

  \ControlFlowTok{return}\NormalTok{ result}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Затем скомпилируем его \texttt{gcc\ -c\ example.c\ -m32\ -O0\ -fno-pie},
получим объектный файл \texttt{example.o}, откройте его с помощью
radare2. Поскольку он еще не проанализирован, команда \texttt{pdf} не
покажет дизассемблирование:

\begin{verbatim}
$ r2 example.o
[0x08000034]> pdf
p: Cannot find function at 0x08000034
[0x08000034]> pd
            ;-- section..text:
            ;-- .text:
            ;-- code_block:
            ;-- eip:
            0x08000034      55             push ebp                    ; [01] -r-x section size 41 named .text
            0x08000035      89e5           mov ebp, esp
            0x08000037      83ec10         sub esp, 0x10
            0x0800003a      c745f8000000.  mov dword [ebp - 8], 0
            0x08000041      c745fc000000.  mov dword [ebp - 4], 0
        ,=< 0x08000048      eb08           jmp 0x8000052
       .--> 0x0800004a      8345f801       add dword [ebp - 8], 1
       :|   0x0800004e      8345fc01       add dword [ebp - 4], 1
       :`-> 0x08000052      837dfc09       cmp dword [ebp - 4], 9
       `==< 0x08000056      7ef2           jle 0x800004a
            0x08000058      8b45f8         mov eax, dword [ebp - 8]
            0x0800005b      c9             leave
            0x0800005c      c3             ret
\end{verbatim}

Наша цель состоит в том, чтобы вручную создать функцию со следующей
структурой

\begin{figure}
\centering
\includegraphics{analyze_one.png}
\caption{analyze\_one}
\end{figure}

Создаем функцию по смещению 0x8000034 с именем code\_block:

\begin{verbatim}
[0x8000034]> af+ 0x8000034 code_block
\end{verbatim}

В большинстве случаев инструкции jump или call используется в качестве
границ блоков кода.

Таким образом, диапазон первого блока составляет от
\texttt{0x08000034\ push\ ebp} до \texttt{0x08000048\ jmp\ 0x8000052},
используем команду \texttt{afb+} для его задания (добавления).

\begin{verbatim}
[0x08000034]> afb+ code_block 0x8000034 0x800004a-0x8000034 0x8000052
\end{verbatim}

Обратите внимание, что базовым синтаксисом \texttt{afb+} является
\texttt{afb+\ function\_address\ block\_address\ block\_size\ {[}jump{]}\ {[}fail{]}}.
Последняя инструкция этого блока содержит новый адрес (jmp 0x8000052),
поэтому добавляем этот адрес перехода (0x8000052) в аргументы команды,
чтобы явным образом \emph{отразить информацию о переходе}.

Следующий блок (0x08000052 \textasciitilde{} 0x08000056) является скорее
условным оператором if, который включает две ветви. Переход (аргумент
\texttt{jump}) на 0x800004a произойдет, если выполнится \texttt{jle}
(меньше или равно), в противном случае (аргумент \texttt{fail})
произойдет переход к следующей инструкции по адресу 0x08000058:

\begin{verbatim}
[0x08000034]> afb+ code_block 0x8000052 0x8000058-0x8000052 0x800004a 0x8000058
\end{verbatim}

Следуя потоку управления, создаем оставшиеся два блока (для
вышеупомянутых ветвей):

\begin{verbatim}
[0x08000034]> afb+ code_block 0x800004a 0x8000052-0x800004a 0x8000052
[0x08000034]> afb+ code_block 0x8000058 0x800005d-0x8000058
\end{verbatim}

В результате получим:

\begin{verbatim}
[0x08000034]> afb
0x08000034 0x0800004a 00:0000 22 j 0x08000052
0x0800004a 0x08000052 00:0000 8 j 0x08000052
0x08000052 0x08000058 00:0000 6 j 0x0800004a f 0x08000058
0x08000058 0x0800005d 00:0000 5
[0x08000034]> VV
\end{verbatim}

\begin{figure}
\centering
\includegraphics{handcraft_one.png}
\caption{handcraft\_one}
\end{figure}

Есть две очень важные команды: \texttt{afc} и \texttt{afB}. Последняя
является обязательной командой для некоторых платформ, таких как ARM.
Она предоставляет способ изменения ``bitness'' конкретной функции,
позволяя выбирать между режимами ARM и Thumb. Команда \texttt{afc}
позволяет вручную указать соглашение о вызове функции. Более подробную
информацию о ее использовании смотрите в
\href{calling_conventions.md}{calling\_conventions}.

\hypertarget{ux440ux435ux43aux443ux440ux441ux438ux432ux43dux44bux439-ux430ux43dux430ux43bux438ux437}{%
\subsection{Рекурсивный
анализ}\label{ux440ux435ux43aux443ux440ux441ux438ux432ux43dux44bux439-ux430ux43dux430ux43bux438ux437}}

Существует пять важных команд полуавтоматического анализа всей
программы:

\begin{itemize}
\tightlist
\item
  \texttt{aab} - выполнение анализа базовых блоков (алгоритм
  ``Nucleus''),
\item
  \texttt{aac} - анализ вызовов функций из заданной или текущей функции,
\item
  \texttt{aaf} - анализ всех вызовов функций,
\item
  \texttt{aar} - анализ ссылок на данные,
\item
  \texttt{aad} - анализ указателей на адреса.
\end{itemize}

И это только общие полуавтоматические алгоритмы поиска ссылок. Radare2
обеспечивает широкий выбор инструментов ручного задания ссылок.
Детальное управление информационной разметкой функции --- использование
команды \texttt{ax}.

\begin{verbatim}
Usage: ax[?d-l*]   # смотрите также 'afx?'
| ax              перечислить ссылки
| ax*             вывести команды radare
| ax addr [at]    добавить ссывку на код, ссылающийся на addr (из текущего смещения)
| ax- [at]        очистить все ссылки и ссылки с адреса
| ax-*            очистить все ссылки
| axc addr [at]   добавить ссыдку на код общего вида
| axC addr [at]   добавить ссылку на вызываемый код
| axg [addr]      показать граф xrefs достижения текущей функции
| axg* [addr]     показать граф xrefs достижения заданного адреса, используйте .axg*;aggv
| axgj [addr]     показать граф xrefs достижения текущей функции в формате json
| axd addr [at]   добавить ссфлку на данные
| axq             перечислить ссылки в простом удобном для человека формате
| axj             перечислить ссылки в формате json
| axF [flg-glob]  найти ссылки на данные или код флагов
| axm addr [at]   копировать ссылки на данные/код, ссылающиеся на адрес и, возможно, на текущее смещение (аргумент at)
| axt [addr]      найти ссылки на данные или код на заданный адрес
| axf [addr]      найти ссылки на данные или код с заданного адреса
| axv [addr]      перечислить сылки чтения, изменения, запуска на локальные переменные
| ax. [addr]      найти ссылки на данные или код из и с заданного адреса
| axff[j] [addr]  найти ссылки на данные или код из заданной функции
| axs addr [at]   добавить ссылку на строку
\end{verbatim}

Наиболее часто используемыми командами группы \texttt{ax} являются
\texttt{axt} и \texttt{axf}, особенно в составе различных сценариев
r2pipe. Допустим, мы видим строку в разделе данных или кода и хотим
найти все места ссылок на нее, используем \texttt{axt}:

\begin{verbatim}
[0x0001783a]> pd 2
;-- str.02x:
; STRING XREF from 0x00005de0 (sub.strlen_d50)
; CODE XREF from 0x00017838 (str.._s_s_s + 7)
0x0001783a     .string "%%%02x" ; len=7
;-- str.src_ls.c:
; STRING XREF from 0x0000541b (sub.free_b04)
; STRING XREF from 0x0000543a (sub.__assert_fail_41f + 27)
; STRING XREF from 0x00005459 (sub.__assert_fail_41f + 58)
; STRING XREF from 0x00005f9e (sub._setjmp_e30)
; CODE XREF from 0x0001783f (str.02x + 5)
0x00017841 .string "src/ls.c" ; len=9
[0x0001783a]> axt
sub.strlen_d50 0x5de0 [STRING] lea rcx, str.02x
(nofunc) 0x17838 [CODE] jae str.02x
\end{verbatim}

Есть также несколько полезных команд в подгруппе \texttt{axt}. Команда
\texttt{axtg} - выполнения перечня команд radare2, анализирующих
программные объекты, ссылающиеся на функцию, используя информацию в
XREF).

\begin{verbatim}
[0x08048320]> s main
[0x080483e0]> axtg
agn 0x8048337 "entry0 + 23"
agn 0x80483e0 "main"
age 0x8048337 0x80483e0
\end{verbatim}

Используйте \texttt{axt*} для просмотра команд radare2 и установки
флагов на соответствующие адреса в XREF. Также в группе \texttt{ax}
находится \texttt{axg}, которая находит путь между двумя точками в
файле, показывая граф XREF для достижения смещения или функции,
например:

\begin{verbatim}
:> axg sym.imp.printf
- 0x08048a5c fcn 0x08048a5c sym.imp.printf
  - 0x080483e5 fcn 0x080483e0 main
  - 0x080483e0 fcn 0x080483e0 main
    - 0x08048337 fcn 0x08048320 entry0
  - 0x08048425 fcn 0x080483e0 main
\end{verbatim}

Используйте \texttt{axg*} для генерации команд radare2, которые помогут
вам создавать графики с использованием команд \texttt{agn} и
\texttt{age} в соответствии с XREF. Помимо предопределенных алгоритмов
для идентификации функций есть способ указать ``\emph{прелюдию}''
(prelude) функции с параметром конфигурации \texttt{anal.prelude}.
Например, \texttt{e\ anal.prelude\ =\ 0x554889e5} задает прелюдию на
платформе x86\_64:

\begin{verbatim}
push rbp
mov rbp, rsp
\end{verbatim}

Она должна быть задана \emph{перед} тем, как запускать команды анализа.

\hypertarget{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f-1}{%
\subsection{Конфигурация}\label{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f-1}}

Radare2 позволяет изменять поведение практически любых этапов анализа и
поведение команд. Существуют различные типы параметров конфигурации:

\begin{itemize}
\tightlist
\item
  Управление потоком,
\item
  Управление основными блоками,
\item
  Элемент управления ссылками,
\item
  Ввод-вывод, диапазоны,
\item
  Управление анализом таблиц переходов,
\item
  Конкретные параметры платформы/процессора.
\end{itemize}

\hypertarget{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f-ux43fux43eux442ux43eux43aux430-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f}{%
\subsubsection{Конфигурация потока
управления}\label{ux43aux43eux43dux444ux438ux433ux443ux440ux430ux446ux438ux44f-ux43fux43eux442ux43eux43aux430-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f}}

Двумя наиболее часто используемыми вариантами изменения поведения
анализа потока управления в radare2 являются: \texttt{anal.hasext} и
\texttt{anal.jmp.after}. Первая настройка заставляет radare2 продолжить
анализ после окончания функции, даже если следующий кусок кода не
вызывается откуда-либо, --- это анализ всех доступных функций. Вторая
настройка заставляет radare2 продолжать анализ после безусловных
переходов, найденных в коде тела функции.

В дополнение к ним \texttt{anal.jmp.indir} управляет отслеживанием
косвенных переходов; \texttt{anal.pushret} - анализа последовательностей
\texttt{push\ ...;\ ret}; \texttt{anal.nopskip} для пропуска
NOP-последовательности в начале функции.

На данный момент radare2 также позволяет изменять максимальный размер
базового блока при помощи переменной \texttt{anal.bb.maxsize}. Значение
по умолчанию подходит к большинству случаев использования, полезно
увеличивать его при работе с обфусцированным кодом, кодом в который
внесены незначащие инструкции, но значительно усложняющие анализ кода
тела функции. Некоторые из настроек управления базовыми блоками могут
быть изменены в будущем в пользу более автоматизированных способов их
оценки.

Для некоторых необычных двоичных файлов или архитектур есть опция
\texttt{anal.noncode}. По умолчанию Radare2 не пытается анализировать
разделы данных в виде кода. Но в некоторых случаях -- вредоносное ПО,
упакованные двоичные файлы, двоичные файлы для встраиваемых систем ---
требуют проводить такой анализ.

\hypertarget{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux441ux441ux44bux43bux43aux430ux43cux438}{%
\subsubsection{Управление
ссылками}\label{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux441ux441ux44bux43bux43aux430ux43cux438}}

Управление ссылками --- наиболее важные настройки, кардинально меняющие
результаты анализа. Некоторые настройки можно отключить для экономии
времени и памяти при анализе больших двоичных файлов.

\begin{itemize}
\tightlist
\item
  \texttt{anal.jmp.ref} - разрешить создание ссылок на безусловные
  переходы,
\item
  \texttt{anal.jmp.cref} - то же самое, но для условных переходов,
\item
  \texttt{anal.datarefs} - отслеживание ссылок на данные в коде,
\item
  \texttt{anal.refstr} - поиск строк в ссылках на данные,
\item
  \texttt{anal.strings} - поиск строк и создание ссылок.
\end{itemize}

Флаг управления ссылками на строки по умолчанию отключен, так как
увеличивает время анализа.

\hypertarget{ux434ux438ux430ux43fux430ux437ux43eux43dux44b-ux430ux43dux430ux43bux438ux437ux430}{%
\subsubsection{Диапазоны
анализа}\label{ux434ux438ux430ux43fux430ux437ux43eux43dux44b-ux430ux43dux430ux43bux438ux437ux430}}

Настройки:

\begin{itemize}
\tightlist
\item
  \texttt{anal.limits} позволяет использовать пределы диапазона для
  операций анализа,
\item
  \texttt{anal.from} - начальный адрес предельного диапазона,
\item
  \texttt{anal.to} - соответствующий конец предельного диапазона.
\item
  \texttt{anal.in} - границы поиска для анализа. Вы можете установить
  его на \texttt{io.maps}, \texttt{io.sections.exec}, \texttt{dbg.maps}
  и др. Например:

  \begin{itemize}
  \tightlist
  \item
    Чтобы проанализировать конкретную карту памяти с помощью
    \texttt{anal.from} и \texttt{anal.to}, установите
    \texttt{anal.in\ =\ dbg.maps}.
  \item
    Для анализа в заданных границах, установите \texttt{anal.from} и
    \texttt{anal.to}, затем установите \texttt{anal.in=range}.
  \item
    Для анализа в текущем отображаемом сегменте или разделе можно
    установить \texttt{anal.in=bin.segment} или
    \texttt{anal.in=bin.section} соответственно.
  \item
    Для анализа в текущей карте памяти укажите \texttt{anal.in=dbg.map}.
  \item
    Задать \texttt{anal.in=dbg.stack} или \texttt{anal.in=dbg.heap} для
    анализа в стеке или куче.
  \item
    Для анализа в текущей функции или базовом блоке можно указать
    \texttt{anal.in=anal.fcn} или \texttt{anal.in=anal.bb}.
  \end{itemize}
\end{itemize}

Полный список настроек доступен при помощи \texttt{e\ anal.in=??}.

\hypertarget{ux442ux430ux431ux43bux438ux446ux44b-ux43fux435ux440ux435ux445ux43eux434ux43eux432}{%
\subsubsection{Таблицы
переходов}\label{ux442ux430ux431ux43bux438ux446ux44b-ux43fux435ux440ux435ux445ux43eux434ux43eux432}}

Таблицы переходов являются одной из самых сложных целей в двоичном
реверс-инжениринге. Их есть сотни различных типов, конечный результат
зависит от компилятора/компоновщика и этапов оптимизации LTO. Radare2
позволяет включать некоторые экспериментальные алгоритмы обнаружения
таблиц переходов с использованием \texttt{anal.jmp.tbl}. Наиболее
сложные этапы анализа используют алгоритмы анализа адресов, упакованных
в таблицы переходов. Этапы можно включить в перечень процедур,
запускаемых по умолчанию для каждой поддерживаемой платформы. Есть еще
две настройки, влияющие на результаты анализа таблиц переходов:

\begin{itemize}
\tightlist
\item
  \texttt{anal.jmp.indir} - отслеживать непрямые переходы, некоторые
  таблицы переходов опираются на них,
\item
  \texttt{anal.datarefs} - отслеживать ссылки на данные, некоторые
  таблицы переходов используют их.
\end{itemize}

\hypertarget{ux44dux43bux435ux43cux435ux43dux442ux44b-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f-ux441ux43fux435ux446ux438ux444ux438ux447ux43dux44bux435-ux434ux43bux44f-ux43fux43bux430ux442ux444ux43eux440ux43cux44b}{%
\subsubsection{Элементы управления, специфичные для
платформы}\label{ux44dux43bux435ux43cux435ux43dux442ux44b-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f-ux441ux43fux435ux446ux438ux444ux438ux447ux43dux44bux435-ux434ux43bux44f-ux43fux43bux430ux442ux444ux43eux440ux43cux44b}}

Существует две распространенные проблемы при анализе встроенных
архитектур: обнаружение ARM/Thumb и значения MIPS GP. В случае двоичных
файлов ARM radare2 поддерживает автоматическое обнаружение
переключателей режима ARM/Thumb, но надо иметь в виду, что он использует
частичную эмуляцию ESIL, тем самым замедляя процесс анализа. Если
результаты вас не устраивают, определенные параметры функций могут быть
переопределены при помощи \texttt{afB}.

Проблема MIPS GP еще сложнее. Известно, что значение GP может быть
разным не только для всей программы, но также и для отдельных функций.
Частично проблему решают настройки \texttt{anal.gp} и
\texttt{anal.gpfixed}. Первый устанавливает значение GP для всей
программы или конкретной функции. Второй позволяет «фиксировать»
значение GP, если какой-то код захочет изменить его, всегда сбрасывая
его, если факт смены обнаружен. Они в значительной степени
экспериментальны и могут быть изменены в будущем в пользу более
автоматизированного анализа.

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux43fux43eux434ux445ux43eux434}{%
\subsection{Визуальный
подход}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux43fux43eux434ux445ux43eux434}}

Один из самых простых способов увидеть и проверить последствия изменений
поведения команд анализа заключается в выполнении прокрутки в
специальном визуальном режиме \texttt{Vv}, позволяющем выполнять функции
предварительного просмотра:

\begin{figure}
\centering
\includegraphics{code_analysis_vv.png}
\caption{vv}
\end{figure}

Когда надо проверить, как изменения анализа влияют на результат в случае
больших функций, вместо этого можно использовать миникарту, позволяющую
видеть общий граф управления на том же экране. Чтобы войти в режим
миникарты введите \texttt{VV}, затем дважды нажмите клавишу \texttt{p}:

\begin{figure}
\centering
\includegraphics{code_analysis_vv2.png}
\caption{vv2}
\end{figure}

Этот режим позволяет увидеть дизассемблирование каждого базового блока в
отдельности, просто перемещаясь между ними с помощью клавиши
\texttt{Tab}.

\hypertarget{ux43fux43eux434ux441ux43aux430ux437ux43aux438-ux43fux43e-ux430ux43dux430ux43bux438ux437ux443}{%
\subsection{Подсказки по
анализу}\label{ux43fux43eux434ux441ux43aux430ux437ux43aux438-ux43fux43e-ux430ux43dux430ux43bux438ux437ux443}}

Нередки случаи, когда результаты анализа не идеальны даже после того,
как вы попробовали все до единого, включая параметры конфигурации.
Именно здесь появляется механизм «analysis hints» radare2. Он позволяет
переопределить некоторые основные свойства оп-кодов или метаданных или
даже переписать всю строку оп-кода. Эти команды расположены в
пространстве имен \texttt{ah}:

\begin{verbatim}
Usage: ah[lba-]  Подсказки (hints), генерируемые в результате анализа
| ah?                показать данную подсказку
| ah? offset         показать подсказки для заданного смещения
| ah                 перечислить подсказки в виде, удобном для чтения
| ah.                перечислить подсказки в виде, удобном для чтения, начиная с текущего смещения
| ah-                удалить все подсказки
| ah- offset [size]  удалить все подсказки, начиная с заденного смещения
| ah* offset         перечислить подсказки в формате команд radare
| aha ppc @ 0x42     задать архитекутуру ppc для всех адресов >= 0x42 или до следующей подсказки
| aha 0 @ 0x84       удалить вывод подсказок, касающихся архитектуры, для всех адресов >= 0x84 или до следующей подсказки
| ahb 16 @ 0x42      задать 16bit для всех адресов >= 0x42 или до следующей подсказки
| ahb 0 @ 0x84       отключить отображение подсказок класса "bits" для всех адресов >= 0x84 или до следующей подсказки
| ahc 0x804804       переназначить адрес call или jump
| ahd foo a0,33      заменить мнемонику оп-кода
| ahe 3,eax,+=       задать строковое отображение анализа виртуальной машины
| ahf 0x804840       переназначить fallback-адрес для call
| ahF 0x10           установить размер фрейма стека по текущему смещению
| ahh 0x804840       выделить визуально данный адрес в дизассемблировании
| ahi[?] 10          задать систему счисления для immediates (2, 8, 10, 10u, 16, i, p, S, s)
| ahj                перечислить подсказки в формате JSON
| aho call           сменить тип оп-кода (смотрите aho?) (устарело, перенесено в "ahd")
| ahp addr           установить подсказку для указателя
| ahr val            установить подсказку для возвращаемого значения функции
| ahs 4              установить размер оп-кода равным 4
| ahS jz             задать asm.syntax=jz для данного оп-кода
| aht [?] <type>     пометить immediate как смещение типа (устарело, перенесено в "aho")
| ahv val            сменить поле val оп-кода (полезно при назначении размеров таблиц переходов в jmp rax)
\end{verbatim}

Один из наиболее распространенных случаев --- установка системы
счисления для чисел:

\begin{verbatim}
[0x00003d54]> ahi?
Usage: ahi [2|8|10|10u|16|bodhipSs] [@ offset]   Задание системы счисления
| ahi <base>  задать систему счисления (2, 8, 10, 16)
| ahi 10|d    задать десятичную систему счисления со знаком (10), бит знака зависит от размера операнда
| ahi 10u|du  задать десятичную систему счисления без знака (11)
| ahi b       задать двоичную систему счисления (2)
| ahi o       задать восмеричную систему счисления (8)
| ahi h       задать шестнадцатеричную систему счисления (16)
| ahi i       представлять как IP-адрес (32)
| ahi p       представлять как htons(port) (3)
| ahi S       представлять как syscall (80)
| ahi s       представлять в виде строки (1)

[0x00003d54]> pd 2
0x00003d54      0583000000     add eax, 0x83
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]> ahi d
[0x00003d54]> pd 2
0x00003d54      0583000000     add eax, 131
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]> ahi b
[0x00003d54]> pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
\end{verbatim}

Примечательно, что некоторые этапы анализа или команды добавляют
подсказки внутреннего анализа, которые можно проверить с помощью команды
\texttt{ah} :

\begin{verbatim}
[0x00003d54]> ah
 0x00003d54 - 0x00003d54 => immbase=2
[0x00003d54]> ah*
 ahi 2 @ 0x3d54
\end{verbatim}

Иногда нам нужно переопределить адрес перехода или вызова, например, в
случае замысловатого перемещения, неизвестного radare2. Текущую
аналитическую информацию о конкретном оп-коде можно проверить с помощью
команды \texttt{ao}. Используем команду \texttt{ahc} для выполнения
такого изменения:

\begin{verbatim}
[0x00003cee]> pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]> ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00014530
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]> ahc 0x5382
[0x00003cee]> pd 2
0x00003cee      e83d080100     call sub.__errno_location_530
0x00003cf3      85c0           test eax, eax
[0x00003cee]> ao
address: 0x3cee
opcode: call 0x14530
mnemonic: call
prefix: 0
id: 56
bytes: e83d080100
refptr: 0
size: 5
sign: false
type: call
cycles: 3
esil: 83248,rip,8,rsp,-=,rsp,=[],rip,=
jump: 0x00005382
direction: exec
fail: 0x00003cf3
stack: null
family: cpu
stackop: null
[0x00003cee]> ah
 0x00003cee - 0x00003cee => jump: 0x5382
\end{verbatim}

Как видите, несмотря на неизменный вид дизассемблирования, адрес
перехода в оп-коде был изменен (настройка \texttt{jump}).

Если что-то из ранее описанного не помогло, можно просто переопределить
показанное дизассемблирование чем-либо, что вам нравиться:

\begin{verbatim}
[0x00003d54]> pd 2
0x00003d54      0583000000     add eax, 10000011b
0x00003d59      3d13010000     cmp eax, 0x113
[0x00003d54]> "ahd myopcode bla, foo"
[0x00003d54]> pd 2
0x00003d54                     myopcode bla, foo
0x00003d55      830000         add dword [rax], 0
\end{verbatim}

\hypertarget{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux43cux438}{%
\section{Управление
переменными}\label{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux43cux438}}

Radare2 позволяет работать с локальными переменными независимо от их
местоположения, в стеке они или в регистрах. Автоматический анализ
переменных включен по умолчанию, но его можно отключить с помощью
настройки \texttt{anal.vars}.

Основные команды управления переменными находятся в пространстве имен
\texttt{afv}:

\begin{verbatim}
Usage: afv  [rbs]
| afv*                          вывести комнды r2 для добавления аргумента/локальной переменной в пространство флагов (flagspace)
| afv-([name])                  удалить все или заданные переменные
| afv=                          перечислить переменные функции и ее аргументы с сылками на дизассемблирование
| afva                          анализировать аргументы и локальные переменные функции
| afvb[?]                       изменять аргументы и локальные переменные, доступные по смащению в регистре bp
| afvd name                     вывести команды r2 для отображения значений аргументов и локальных переменных в отладчике
| afvf                          показать переменные во фрейме стека, задаваемого регистром bp
| afvn [new_name] ([old_name])  переименовать аргумент или локальную переменную
| afvr[?]                       изменить аргумент, соответствующий регистру
| afvR [varname]                перечислить адреса, где к переменной получают доступ (ЧТЕНИЕ)
| afvs[?]                       управление аргументами и локальными переменными, адрессируемыми при помощи регистра sp
| afvt [name] [new_type]        сменить тип для заданного аргумента или переменной
| afvW [varname]                перечислить адреса, где к переменным получают доступ (ИЗМЕНЕНИЕ)
| afvx                          показать перекресные ссылки на переменные функции (то же самое, что и afvR+afvW)
\end{verbatim}

Команды \texttt{afvr}, \texttt{afvb} и \texttt{afvs} унифицированы, но
позволяют манипулировать аргументами и локальными переменными, хранимыми
в регистрах, в стеке по смещениям в BP/FP, индексируемыми при помощи SP.
Для группы команд \texttt{afvr} есть богатый набор операций над
регистровыми переменными:

\begin{verbatim}
|Usage: afvr [reg] [type] [name]
| afvr                        перечислить переменные, соответствующие регистрам
| afvr*                       то же, что и afvr, но в виде команд r2
| afvr [reg] [name] ([type])  определить аргумент, соответствующий ркгистру
| afvrj                       показать перечень регистровых переменных в формате JSON
| afvr- [name]                удалить регистровый аргумент
| afvrg [reg] [addr]          определить get-интерфейс аргумента
| afvrs [reg] [addr]          определить set-интерфейс аргумента
\end{verbatim}

Как и для многих других программных объектов, обнаружение переменных
происходит автоматически, результаты можно изменить с помощью команд
управления аргументами/локальными переменными. Этот вид анализа в
значительной степени полагается на предварительно загруженные прототипы
функций и соглашение о вызовах, таким образом загружая символы из
отладочной информации, можно значительно улучшить результаты анализа.
Более того, внеся изменения можно перезапустить анализ переменных с
помощью команды \texttt{afva}. Довольно часто анализ переменных
сопровождается \href{types.md}{анализом типов}, ознакомьтесь с
инструкциями команды \texttt{afta}.

Самый важный аспект реверс-инжениринга --- именование программных
объектов и сущностей. После переименования переменных в текстах
дизассемблирования автоматически меняются все ссылки на эти переменные.
Переименование аргументов и локальных переменных осуществляется при
помощи команды \texttt{afvn}. Удаление делается при помощи команды
\texttt{afv-}.

Как упоминалось ранее, анализ в значительной степени зависит от
информации о типах переменных. Следующая очень важная команда -
\texttt{afvt}, она позволяет изменять тип переменной:

\begin{verbatim}
[0x00003b92]> afvs
var int local_8h @ rsp+0x8
var int local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
[0x00003b92]> afvt local_10h char*
[0x00003b92]> afvs
var int local_8h @ rsp+0x8
var char* local_10h @ rsp+0x10
var int local_28h @ rsp+0x28
var int local_30h @ rsp+0x30
var int local_32h @ rsp+0x32
var int local_38h @ rsp+0x38
var int local_45h @ rsp+0x45
var int local_46h @ rsp+0x46
var int local_47h @ rsp+0x47
var int local_48h @ rsp+0x48
\end{verbatim}

Пока еще редко используемый инструмент, находящаяся в стадии интенсивной
разработки, --- построение списков переменных, которые читаются и
изменяются. Команда \texttt{afvR} перечисляет переменные, которые
читаются, а \texttt{afvW} - изменяются. Обе команды предоставляют список
адресов, где эти операции выполняются:

\begin{verbatim}
[0x00003b92]> afvR
local_48h  0x48ee
local_30h  0x3c93,0x520b,0x52ea,0x532c,0x5400,0x3cfb
local_10h  0x4b53,0x5225,0x53bd,0x50cc
local_8h  0x4d40,0x4d99,0x5221,0x53b9,0x50c8,0x4620
local_28h  0x503a,0x51d8,0x51fa,0x52d3,0x531b
local_38h
local_45h  0x50a1
local_47h
local_46h
local_32h  0x3cb1
[0x00003b92]> afvW
local_48h  0x3adf
local_30h  0x3d3e,0x4868,0x5030
local_10h  0x3d0e,0x5035
local_8h  0x3d13,0x4d39,0x5025
local_28h  0x4d00,0x52dc,0x53af,0x5060,0x507a,0x508b
local_38h  0x486d
local_45h  0x5014,0x5068
local_47h  0x501b
local_46h  0x5083
local_32h
[0x00003b92]>
\end{verbatim}

\hypertarget{ux432ux44bux432ux43eux434-ux442ux438ux43fux430}{%
\subsection{Вывод
типа}\label{ux432ux44bux432ux43eux434-ux442ux438ux43fux430}}

Вывод типа для локальных переменных и аргументов хорошо интегрирован с
командой \texttt{afta}. Посмотрим пример с простым бинарным файлом
\href{https://github.com/radareorg/radare2book/tree/master/examples/hello_world}{hello\_world}

\begin{verbatim}
[0x000007aa]> pdf
|           ;-- main:
/ (fcn) sym.main 157
| sym.main ();
| ; var int local_20h @ rbp-0x20
| ; var int local_1ch @ rbp-0x1c
| ; var int local_18h @ rbp-0x18
| ; var int local_10h @ rbp-0x10
| ; var int local_8h @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; "Hello"
| 0x000007b9  mov qword [local_18h], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; " r2-folks"
| 0x000007c4  mov qword [local_10h], rax
| 0x000007c8  mov rax, qword [local_18h]
| 0x000007cc  mov rdi, rax
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  После применения \texttt{afta}:
\end{itemize}

\begin{verbatim}
[0x000007aa]> afta
[0x000007aa]> pdf
| ;-- main:
| ;-- rip:
/ (fcn) sym.main 157
| sym.main ();
| ; var size_t local_20h @ rbp-0x20
| ; var size_t size @ rbp-0x1c
| ; var char *src @ rbp-0x18
| ; var char *s2 @ rbp-0x10
| ; var char *dest @ rbp-0x8
| ; DATA XREF from entry0 (0x6bd)
| 0x000007aa  push rbp
| 0x000007ab  mov rbp, rsp
| 0x000007ae  sub rsp, 0x20
| 0x000007b2  lea rax, str.Hello          ; 0x8d4 ; "Hello"
| 0x000007b9  mov qword [src], rax
| 0x000007bd  lea rax, str.r2_folks       ; 0x8da ; " r2-folks"
| 0x000007c4  mov qword [s2], rax
| 0x000007c8  mov rax, qword [src]
| 0x000007cc  mov rdi, rax                ; const char *s
| 0x000007cf  call sym.imp.strlen         ; size_t strlen(const char *s)
\end{verbatim}

Также информация о типе извлекается из форматных строк, таких как
\texttt{printf("fmt:\ \%s,\ \%u,\ \%d",...)}, спецификации форматов
находятся в \texttt{anal/d/spec.sdb}.

Можно создать новый профиль для указания набора символов определения
формата в зависимости от различных библиотек/операционных систем/языков
программирования, например:

\begin{verbatim}
win=spec
spec.win.u32=unsigned int
\end{verbatim}

Затем изменить спецификацию по умолчанию на вновь созданную, используя
переменную конфигурации \texttt{e\ anal.spec\ =\ win}

Для получения дополнительной информации о поддержке примитивных и
определяемых пользователем типов в radare2 читайте раздел
\href{types.md}{типы}.

\hypertarget{ux442ux438ux43fux44b-ux434ux430ux43dux43dux44bux445}{%
\section{Типы
данных}\label{ux442ux438ux43fux44b-ux434ux430ux43dux43dux44bux445}}

Radare2 поддерживает описание типов данных при помощи синтаксиса языка
C. Описания синтаксически анализируются, сохраняются во внутренний SDB и
доступны для интроспекции при помощи команды \texttt{k}. Синтаксис
описаний совместим с C11. Большинство связанных с этой функцией команд
находятся в пространстве имен \texttt{t}:

\begin{verbatim}
[0x00000000]> t?
| Usage: t   # команды задания типов (подсистемы cparse)
| t                          Перечислить все загруженные типы
| tj                         Перечислить все загруженные типы в формате json
| t <type>                   Показать тип в синтаксисе 'pf'
| t*                         Показать информацию о типах в виде команд r2
| t- <name>                  Удалить типы по их именам
| t-*                        Удалить все типы
| tail [filename]            Вывести последнюю часть файла
| tc [type.name]             Перечислить все/заданные типы в формате C
| te[?]                      Перечислить все загруженные enum-ы
| td[?] <string>             Загрузить типы из строк
| tf                         Перечислить все загруженные функции
| tk <sdb-query>             Выполнить запрос sdb
| tl[?]                      Показать/привязать тип по/к адресу
| tn[?] [-][addr]            Управление атрибутами и метками noreturn-функции
| to -                       Открыть cfg.editor для загрузки типов
| to <path>                  Загрузить типы из заголовочных файлов C
| toe [type.name]            Открыть cfg.editor для редактирования типов
| tos <path>                 Загрузить типы из базы данных sdb, представленной в текстовом виде
| tp  <type> [addr|varname]  Преобразовать данные по <addr-есу> в <type> и распечатать результат (XXX: тип может содержать пробелы)
| tpv <type> @ [value]       Показать смещение, представленное в формате, соответствующем заданному типу
| tpx <type> <hexpairs>      Показать значение для типа для заданной последовательности байтов (XXX: тип может содержать пробелы)
| ts[?]                      Показать загруженные типы-структуры
| tu[?]                      Показать загруженные типы-юнионы
| tx[f?]                     Распечатать xrefs
| tt[?]                      Перечислить все загруженные typedef-ы
\end{verbatim}

Обратите внимание, что базовые (атомарные) типы не соответствуют
стандарту C --- нет \texttt{char}, \texttt{\_Bool} и \texttt{short}. Эти
типы могут быть разными на разных платформах, radare2 использует
\emph{строго определенные} типы, такие как \texttt{int8\_t} или
\texttt{uint64\_t}, и конвертирует \texttt{int} в \texttt{int32\_t} или
в \texttt{int64\_t} в зависимости от бинарной или отлаживаемой
платформы/компилятора. Базовые типы перечисляются с помощью команды
\texttt{t}. Для типов структур нужно использовать \texttt{ts}, для
юнионов --- \texttt{tu}, а для перечислений --- \texttt{te}.

\begin{verbatim}
[0x00000000]> t
char
char *
double
float
gid_t
int
int16_t
int32_t
int64_t
int8_t
long
long long
pid_t
short
size_t
uid_t
uint16_t
uint32_t
uint64_t
uint8_t
unsigned char
unsigned int
unsigned short
void *
\end{verbatim}

\hypertarget{ux437ux430ux433ux440ux443ux437ux43aux430-ux442ux438ux43fux43eux432}{%
\subsubsection{Загрузка
типов}\label{ux437ux430ux433ux440ux443ux437ux43aux430-ux442ux438ux43fux43eux432}}

Есть три способа определить новый тип:

\begin{itemize}
\tightlist
\item
  Непосредственно из командной строки с помощью команды \texttt{td},
\item
  Из файла с помощью \texttt{to\ \textless{}имя\ файла\textgreater{}},
\item
  Открыть \texttt{\$EDITOR} для ввода определений с помощью
  \texttt{to\ -}.
\end{itemize}

\begin{verbatim}
[0x00000000]> "td struct foo {char* a; int b;}"
[0x00000000]> cat ~/radare2-regressions/bins/headers/s3.h
struct S1 {
    int x[3];
    int y[4];
    int z;
};
[0x00000000]> to ~/radare2-regressions/bins/headers/s3.h
[0x00000000]> ts
foo
S1
\end{verbatim}

Radare2 позволяет организовать папку для хранения описаний типов и
включений.

\begin{verbatim}
[0x00000000]> e? dir.types
dir.types: Месторасположение по умолчанию, где надо искать файлы формата cparse
[0x00000000]> e dir.types
/usr/include
\end{verbatim}

\hypertarget{ux440ux430ux441ux43fux435ux447ux430ux442ux43aux430-ux441ux442ux440ux443ux43aux442ux443ux440}{%
\subsubsection{Распечатка
структур}\label{ux440ux430ux441ux43fux435ux447ux430ux442ux43aux430-ux441ux442ux440ux443ux43aux442ux443ux440}}

Команда \texttt{ts} преобразует описание типа C (или, если быть точным,
представление SDB) в последовательность команд \texttt{pf}. Смотрите
подробнее о \href{../basic_commands/print_modes.md}{печати структур}.
Команда \texttt{tp} использует строку \texttt{pf} для печати всех полей
типа по текущему смещению/данному адресу:

\begin{verbatim}
[0x00000000]> "td struct foo {char* a; int b;}"
[0x00000000]> wx 68656c6c6f000c000000
[0x00000000]> wz world @ 0x00000010 ; wx 17 @ 0x00000016
[0x00000000]> px
[0x00000000]> ts foo
pf zd a b
[0x00000000]> tp foo
 a : 0x00000000 = "hello"
 b : 0x00000006 = 12
[0x00000000]> tp foo @ 0x00000010
 a : 0x00000010 = "world"
 b : 0x00000016 = 23
\end{verbatim}

Можно также заполнить структуру своими данными и распечатать ее,
используя команду \texttt{tpx}.

\begin{verbatim}
[0x00000000]> tpx foo 414243440010000000
 a : 0x00000000 = "ABCD"
 b : 0x00000005 = 16
\end{verbatim}

\hypertarget{ux442ux438ux43fux44b-ux441ux441ux44bux43bux43eux43a}{%
\subsubsection{Типы
ссылок}\label{ux442ux438ux43fux44b-ux441ux441ux44bux43bux43eux43a}}

Команда \texttt{tp} просто выполняет приведение типов. Но если надо
связать какой-то адрес или переменную с выбранным типом нужно
использовать команду \texttt{tl} для сохранения этого отношения в SDB.

\begin{verbatim}
[0x000051c0]> tl S1 = 0x51cf
[0x000051c0]> tll
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
\end{verbatim}

Причем ссылка будет показана в дизассемблированном выводе или в
визуальном режиме:

\begin{verbatim}
[0x000051c0 15% 300 /bin/ls]> pd $r @ entry0
 ;-- entry0:
 0x000051c0      xor ebp, ebp
 0x000051c2      mov r9, rdx
 0x000051c5      pop rsi
 0x000051c6      mov rdx, rsp
 0x000051c9      and rsp, 0xfffffffffffffff0
 0x000051cd      push rax
 0x000051ce      push rsp
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
 0x000051f0      lea rdi, loc._edata         ; 0x21f248
 0x000051f7      push rbp
 0x000051f8      lea rax, loc._edata         ; 0x21f248
 0x000051ff      cmp rax, rdi
 0x00005202      mov rbp, rsp
\end{verbatim}

После того как структура связана, radare2 пытается распространить
смещение структуры внутри функции, которой принадлежит текущее смещение.
Чтобы запустить этот анализ во всей программе или в любых целевых
функциях после того, как все структуры будут связаны, --- команда
\texttt{aat}:

\begin{verbatim}
[0x00000000]> aa?
| aat [fcn]           Анализировать все/заданную функцию, преобразовать immediate-ы в смещения связнных структур (смотрите tl?)
\end{verbatim}

Иногда эмуляция может быть неточной, например, как показано ниже:

\begin{verbatim}
|0x000006da  push rbp
|0x000006db  mov rbp, rsp
|0x000006de  sub rsp, 0x10
|0x000006e2  mov edi, 0x20               ; "@"
|0x000006e7  call sym.imp.malloc         ;  void *malloc(size_t size)
|0x000006ec  mov qword [local_8h], rax
|0x000006f0  mov rax, qword [local_8h]
\end{verbatim}

Возвращаемое значение \texttt{malloc} может отличаться в разных запусках
эмуляции, нужно установить подсказку (hint) для возвращаемого значения
вручную, используя команду \texttt{ahr}, потом снова запустить
\texttt{tl} или \texttt{aat}.

\begin{verbatim}
[0x000006da]> ah?
| ahr val            установить подсказку для возвращаемого значения функции
\end{verbatim}

\hypertarget{structure-immediates}{%
\subsubsection{Structure Immediates}\label{structure-immediates}}

Есть еще один важный аспект использования типов в Radare2 ---
использование \texttt{aht}, что позволяет изменять immediate-значение в
коде операции на смещение структуры. Рассмотрим простой пример
относительной (RSI) адресации:

\begin{verbatim}
[0x000052f0]> pd 1
0x000052f0      mov rax, qword [rsi + 8]    ; [0x8:8]=0
\end{verbatim}

Здесь \texttt{8} - некоторое смещение в памяти, где \texttt{rsi},
вероятно, содержит указатель структуры. Представьте, что у нас есть
следующие структуры

\begin{verbatim}
[0x000052f0]> "td struct ms { char b[8]; int member1; int member2; };"
[0x000052f0]> "td struct ms1 { uint64_t a; int member1; };"
[0x000052f0]> "td struct ms2 { uint16_t a; int64_t b; int member1; };"
\end{verbatim}

Теперь нам нужно установить правильное смещение поля структуры вместо
\texttt{8}-ки, упомянутой в инструкции. Сначала нужно перечислить
доступные типы, соответствующие этому смещению:

\begin{verbatim}
[0x000052f0]> ahts 8
ms.member1
ms1.member1
\end{verbatim}

Обратите внимание, что \texttt{ms2} не указан, так как в нем нет
элементов со смещением \texttt{8}. После перечисления доступных
вариантов связываем их с выбранным смещением:

\begin{verbatim}
[0x000052f0]> aht ms1.member1
[0x000052f0]> pd 1
0x000052f0      488b4608       mov rax, qword [rsi + ms1.member1]    ; [0x8:8]=0
\end{verbatim}

\hypertarget{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux43fux435ux440ux435ux447ux438ux441ux43bux435ux43dux438ux44fux43cux438}{%
\subsubsection{Управление
перечислениями}\label{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux43fux435ux440ux435ux447ux438ux441ux43bux435ux43dux438ux44fux43cux438}}

\begin{itemize}
\tightlist
\item
  Печать всех полей в перечислении --- команда \texttt{te}:
\end{itemize}

\begin{verbatim}
[0x00000000]> "td enum Foo {COW=1,BAR=2};"
[0x00000000]> te Foo
COW = 0x1
BAR = 0x2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поиск соответствующего члена перечисления для заданного битового поля
  и наоборот:
\end{itemize}

\begin{verbatim}
[0x00000000]> te Foo 0x1
COW
[0x00000000]> teb Foo COW
0x1
\end{verbatim}

\hypertarget{ux432ux43dux443ux442ux440ux435ux43dux43dux435ux435-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux435}{%
\subsection{Внутреннее
представление}\label{ux432ux43dux443ux442ux440ux435ux43dux43dux435ux435-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux435}}

Чтобы увидеть внутреннее представление типов, используйте команду
\texttt{tk}:

\begin{verbatim}
[0x000051c0]> tk~S1
S1=struct
struct.S1=x,y,z
struct.S1.x=int32_t,0,3
struct.S1.x.meta=4
struct.S1.y=int32_t,12,4
struct.S1.y.meta=4
struct.S1.z=int32_t,28,0
struct.S1.z.meta=0
[0x000051c0]>
\end{verbatim}

Определение примитивных типов требует понимания основных форматов
\texttt{pf}, вот список спецификаторов формата \texttt{pf??}:

\begin{verbatim}
-----------------------------------------------------------------------
| format | explanation                                                |
|---------------------------------------------------------------------|
|  b     |  byte (unsigned)                                           |
|  c     |  char (signed byte)                                        |
|  d     |  0x%%08x шестнадцатеричное значение (4 байта)              |
|  f     |  значение float (4 байта)                                  |
|  i     |  %%i значение integer (4 байта)                            |
|  o     |  0x%%08o восьмеричное значение (4 байта)                   |
|  p     |  указатель (2, 4 или 8 байт)                               |
|  q     |  quadword (8 байт)                                         |
|  s     |  32bit-указатель на строку (4 байта)                       |
|  S     |  64bit-указатель на строку (8 байт)                        |
|  t     |  UNIX timestamp (4 байта)                                  |
|  T     |  показать первых десять (Ten) байт буфера                  |
|  u     |  uleb128 (variable length)                                 |
|  w     |  word (2 байта, unsigned short в шестнадцатеричном виде)   |
|  x     |  0x%%08x шестнадцатеричное значение и флаг (fd @ addr)     |
|  X     |  показать последовательность шестнадцатеричных кодов       |
|  z     |  строка, заканчивающаяся \0                                |
|  Z     |  wide-строка, заканчивающаяся \0                           |
-----------------------------------------------------------------------
\end{verbatim}

Есть только три обязательных ключа для определения базовых типов:

\begin{verbatim}
X=type
type.X=format_specifier
type.X.size=size_in_bits
\end{verbatim}

Например, определим \texttt{UNIT} согласно спецификации в
\href{https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751\%28v=vs.85\%29.aspx\#UINT}{документации
Microsoft}. Тип \texttt{UINT} - это лишь эквивалент стандартному типу C
\texttt{unsigned\ int} (или \texttt{uint32\_t} в терминах системы TCC).
Тип определяется так:

\begin{verbatim}
UINT=type
type.UINT=d
type.UINT.size=32
\end{verbatim}

Определение некоторого типа можно дополнить необязательной строкой:

\begin{verbatim}
X.type.pointto=Y
\end{verbatim}

Она используется только в случае задания указателя, когда
\texttt{type.Х=р}. Хорошим примером выступает определение типа
\texttt{LPFILETIME}, указателя на структуру \texttt{\_FILETIME}.
Предполагая, что мы работаем только с 32-разрядной машиной Windows,
структура будет определена следующим образом:

\begin{verbatim}
LPFILETIME=type
type.LPFILETIME=p
type.LPFILETIME.size=32
type.LPFILETIME.pointto=_FILETIME
\end{verbatim}

Последнее поле не является обязательным, поскольку иногда в структурах
данных внутренности бывают скрытыми от глаз разработчиков согласно
коммерческим лицензиям (proprietrary), а у нас может не быть информации
для них четкого определения.

Есть еще одно необязательное определение:

\begin{verbatim}
type.UINT.meta=4
\end{verbatim}

Эта форма предназначена для интеграции с синтаксическим анализатором C и
содержит информацию о классе типов: \emph{целочисленный размер},
\emph{знаковый/беззнаковый} и т.д.

\hypertarget{ux441ux442ux440ux443ux43aux442ux443ux440ux44b}{%
\subsubsection{Структуры}\label{ux441ux442ux440ux443ux43aux442ux443ux440ux44b}}

Вот основные ключи для структур (всего два элемента):

\begin{verbatim}
X=struct
struct.X=a,b
struct.X.a=a_type,a_offset,a_number_of_elements
struct.X.b=b_type,b_offset,b_number_of_elements
\end{verbatim}

Первая строка используется для определения структуры, называемой
\texttt{X}, вторая строка определяет элементы \texttt{X} как значения,
разделенные запятыми. После этого просто определяем информацию о каждом
элементе.

Приведем примеры. Предположим в исходном коде есть такая структура:

\begin{verbatim}
struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
}
\end{verbatim}

Полагая, что \texttt{DWORD} определено, структура будет выглядеть так:

\begin{verbatim}
_FILETIME=struct
struct._FILETIME=dwLowDateTime,dwHighDateTime
struct._FILETIME.dwLowDateTime=DWORD,0,0
struct._FILETIME.dwHighDateTime=DWORD,4,0
\end{verbatim}

Обратите внимание, что поле количества элементов используется только в
случае массивов, по умолчанию оно равно нулю.

\hypertarget{ux44eux43dux438ux43eux43dux44b}{%
\subsubsection{Юнионы}\label{ux44eux43dux438ux43eux43dux44b}}

Юнионы определяются точно так же, как структуры, с той лишь разницей,
что вы заменяете слово \texttt{struct} на \texttt{union}.

\hypertarget{ux43fux440ux43eux442ux43eux442ux438ux43fux44b-ux444ux443ux43dux43aux446ux438ux439}{%
\subsubsection{Прототипы
функций}\label{ux43fux440ux43eux442ux43eux442ux438ux43fux44b-ux444ux443ux43dux43aux446ux438ux439}}

Представление прототипов функций является наиболее подробным и наиболее
важным среди всех определений. На самом деле, это то, что используется
непосредственно для сопоставления типов.

\begin{verbatim}
X=func
func.X.args=NumberOfArgs
func.x.arg0=Arg_type,arg_name
.
.
.
func.X.ret=Return_type
func.X.cc=calling_convention
\end{verbatim}

Все и так понятно. Определим прототип для strncasecmp в качестве примера
для архитектуры x86 и машин Linux. Согласно справке в man функция
strncasecmp определяется следующим образом:

\begin{verbatim}
int strcasecmp(const char *s1, const char *s2, size_t n);
\end{verbatim}

При преобразовании в представление sdb ее прототип будет выглядеть
следующим образом:

\begin{verbatim}
strcasecmp=func
func.strcasecmp.args=3
func.strcasecmp.arg0=char *,s1
func.strcasecmp.arg1=char *,s2
func.strcasecmp.arg2=size_t,n
func.strcasecmp.ret=int
func.strcasecmp.cc=cdecl
\end{verbatim}

Обратите внимание, что часть \texttt{.cc} является необязательной, и
если она не используется, то использоваться соглашение о вызовах по
умолчанию для вашей целевой архитектуры. Есть еще один дополнительный
необязательный ключ

\begin{verbatim}
func.x.noreturn=true/false
\end{verbatim}

Этот ключ используется для обозначения функций, из которых невозможно
вернуться в вызывающую подпрограмму, например \texttt{exit} и
\texttt{\_exit}.

\hypertarget{ux441ux43eux433ux43bux430ux448ux435ux43dux438ux44f-ux432ux44bux437ux43eux432ux430-ux444ux443ux43dux43aux446ux438ux438}{%
\section{Соглашения вызова
функции}\label{ux441ux43eux433ux43bux430ux448ux435ux43dux438ux44f-ux432ux44bux437ux43eux432ux430-ux444ux443ux43dux43aux446ux438ux438}}

Radare2 использует предположения о соглашении о вызове в процессе
анализа функции для распознавания формальных аргументов функции. На
основе предположения производится вывод типа возвращаемого значения.

\begin{verbatim}
[0x00000000]> afc?
|Usage: afc[agl?]
| afc convention  Задать вручную соглашение о вызове для текущей функции
| afc             Вывести соглашение о вызове для текущей функции
| afc=([cctype])  Выбрать/показать соглашение о вызове по умолчанию
| afcr[j]         Показать распределение регистров по параметрам
| afca            Анализировать функцию с целью определения соглащения о вызове для текущей функции
| afcf[j] [name]  Вывести тип возвращаемого значения function(arg1, arg2...), смотрите afij
| afck            Перечислить детали SDB для вызова для загруженных соглашений о вызове
| afcl            Перечислить все поддерживаемые соглашения о вызове
| afco path       Открыть профиль sdb для соглашения о вызове из файла
| afcR            Зарегистрировать телескопирование (telescoping), используя порядок соглашений о вызовах
[0x00000000]>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Вывод списка всех доступных соглашений о вызовах для текущей
  архитектуры - команда \texttt{afcl}.
\end{itemize}

\begin{verbatim}
[0x00000000]> afcl
amd64
ms
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Для отображения прототипа функции стандартной библиотеки есть команда
  \texttt{afcf}.
\end{itemize}

\begin{verbatim}
[0x00000000]> afcf printf
int printf(const char *format)
[0x00000000]> afcf fgets
char *fgets(char *s, int size, FILE *stream)
\end{verbatim}

Вся эта информация загружается через sdb в
\texttt{/libr/anal/d/cc-{[}arch{]}-{[}bits{]}.sdb}

\begin{verbatim}
default.cc=amd64

ms=cc
cc.ms.name=ms
cc.ms.arg1=rcx
cc.ms.arg2=rdx
cc.ms.arg3=r8
cc.ms.arg3=r9
cc.ms.argn=stack
cc.ms.ret=rax
\end{verbatim}

\texttt{cc.x.argi=rax} используется для задания i-го аргумента функции,
регистрации имени \texttt{rax},

\texttt{cc.x.argn=stack} означает, что все аргументы (или остальные
аргументы в случае наличия argi для любого i) будут храниться в стеке
слева направо,

\texttt{cc.x.argn=stack\_rev} то же, что \texttt{и\ cc.x.argn=stack}, но
аргументы передаются справа налево.

\hypertarget{ux432ux438ux440ux442ux443ux430ux43bux44cux43dux44bux435-ux442ux430ux431ux43bux438ux446ux44b}{%
\section{Виртуальные
таблицы}\label{ux432ux438ux440ux442ux443ux430ux43bux44cux43dux44bux435-ux442ux430ux431ux43bux438ux446ux44b}}

В radare2 есть базовая поддержка анализа виртуальных таблиц (RTTI и
др.). Самое главное, прежде чем вы начнете выполнять такой анализ, надо
проверить, что параметр \texttt{anal.cpp.abi} установлен правильно.

Все команды для работы с виртуальными таблицами находятся в пространстве
имен \texttt{av}. В настоящее время поддержка достаточно проста, она
позволяет только проверять таблицы, построенные в результате анализа.

\begin{verbatim}
|Usage: av[?jr*] Таблицы виртуальных методов C++ и RTTI
| av           поиск виртуальных таблиц в сегменте данных и печать результата
| avj          подобно av, но в виде json
| av*          подобно av, но в виде комнд r2
| avr[j@addr]  попробовать странслировать RTTI по адресу виртуальной таблицы (смотрите anal.cpp.abi)
| avra[j]      поиск виртуальных таблиц и попробовать странслировать RTTI в каждой из них
\end{verbatim}

Основные команды --- это \texttt{av} и \texttt{avr}. Команда \texttt{av}
перечисляет все найденные виртуальные таблицы в открытом файле. Если вы
недовольны результатом, можно попытаться проанализировать виртуальную
таблицу по определенному адресу с помощью \texttt{avr}. Команда
\texttt{avra} выполняет поиск и анализ всех виртуальных таблиц в
бинарном файле, как это делает r2 при открытии файла.

\hypertarget{ux441ux438ux441ux442ux435ux43cux43dux44bux435-ux432ux44bux437ux43eux432ux44b}{%
\section{Системные
вызовы}\label{ux441ux438ux441ux442ux435ux43cux43dux44bux435-ux432ux44bux437ux43eux432ux44b}}

Radare2 позволяет вручную искать ассемблерный код, похожий на операцию
системного вызова. Например, на платформе ARM они обычно представлены
инструкциями \texttt{svc}, на других архитектурах это какие-то другие
варианты, например \texttt{syscall} на x86.

\begin{verbatim}
[0x0001ece0]> /ad/ svc
...
0x000187c2   # 2: svc 0x76
0x000189ea   # 2: svc 0xa9
0x00018a0e   # 2: svc 0x82
...
\end{verbatim}

Обнаружение системных вызовов управляется \texttt{asm.os},
\texttt{asm.bits}, а также \texttt{asm.arch}. Для проверки настроек
поддержки системных вызовов используется команда \texttt{asl}. Команда
перечисляет системные вызовы, поддерживаемые вашей платформой.

\begin{verbatim}
[0x0001ece0]> asl
...
sd_softdevice_enable = 0x80.16
sd_softdevice_disable = 0x80.17
sd_softdevice_is_enabled = 0x80.18
...
\end{verbatim}

Если настроен стек ESIL командами \texttt{aei} или \texttt{aeim}, можно
использовать команду \texttt{/as} для поиска адресов детектированных
системных вызовов и их перечисления.

\begin{verbatim}
[0x0001ece0]> aei
[0x0001ece0]> /as
0x000187c2 sd_ble_gap_disconnect
0x000189ea sd_ble_gatts_sys_attr_set
0x00018a0e sd_ble_gap_sec_info_reply
...
\end{verbatim}

Для сокращения времени поиска можно
\href{../search_bytes/configurating_the_search.md}{ограничить диапазон
поиска} на сегменты кода или сегменты из
\texttt{/as\ @e:search.in=io.maps.x}.

Используя \href{emulation.md}{эмуляцию ESIL} в radare2 можно печатать
аргументы системного вызова в дизассемблировании. Чтобы включить
линейную (но очень грубую) эмуляцию, используйте переменную конфигурации
\texttt{asm.emu}:

\begin{verbatim}
[0x0001ece0]> e asm.emu=true
[0x0001ece0]> s 0x000187c2
[0x000187c2]> pdf~svc
   0x000187c2   svc 0x76  ; 118 = sd_ble_gap_disconnect
[0x000187c2]>
\end{verbatim}

В случае выполнения команды \texttt{аае} (или \texttt{аааа}, которая
вызывает \texttt{аае}) radare2 будет помещать найденные системные вызовы
в специальное пространство флагов \texttt{syscall.}, что полезно для
автоматизации:

\begin{verbatim}
[0x000187c2]> fs
0    0 * imports
1    0 * symbols
2 1523 * functions
3  420 * strings
4  183 * syscalls
[0x000187c2]> f~syscall
...
0x000187c2 1 syscall.sd_ble_gap_disconnect.0
0x000189ea 1 syscall.sd_ble_gatts_sys_attr_set
0x00018a0e 1 syscall.sd_ble_gap_sec_info_reply
...
\end{verbatim}

По пространству флагов также можно интерактивно перемещаться в режиме
HUD (\texttt{V\_}).

\begin{verbatim}
0> syscall.sd_ble_gap_disconnect
 - 0x000187b2  syscall.sd_ble_gap_disconnect
   0x000187c2  syscall.sd_ble_gap_disconnect.0
   0x00018a16  syscall.sd_ble_gap_disconnect.1
   0x00018b32  syscall.sd_ble_gap_disconnect.2
   0x0002ac36  syscall.sd_ble_gap_disconnect.3
\end{verbatim}

В режиме отладки в radare2 можно использовать \texttt{dcs} для
продолжения выполнения до следующего системного вызова. Также можно
запустить \texttt{dcs*} для отслеживания всех системных вызовов.

\begin{verbatim}
[0xf7fb9120]> dcs*
Running child until syscalls:-1
child stopped with signal 133
--> SN 0xf7fd3d5b syscall 45 brk (0xffffffda)
child stopped with signal 133
--> SN 0xf7fd28f3 syscall 384 arch_prctl (0xffffffda 0x3001)
child stopped with signal 133
--> SN 0xf7fc81b2 syscall 33 access (0xffffffda 0xf7fd8bf1)
child stopped with signal 133
\end{verbatim}

В radare2 включена функция преобразования имени системного вызова в
номер системного вызова. Можно получить и имя системного вызова для
заданного номера.

\begin{verbatim}
[0x08048436]> asl 1
exit
[0x08048436]> asl write
4
[0x08048436]> ask write
0x80,4,3,iZi
\end{verbatim}

Почитайте \texttt{as?} для получения дополнительной информации о
функции.

\hypertarget{ux44dux43cux443ux43bux44fux446ux438ux44f-esil}{%
\section{Эмуляция
ESIL}\label{ux44dux43cux443ux43bux44fux446ux438ux44f-esil}}

Одна из самых важных вещей в обратном инжиниринге --- понимание различия
между статическим и динамическим анализом. Статический анализ страдает
от проблемы комбинаторного взрыва, что невозможно решить даже самым
простым способом без хотя бы частичной эмуляции. Многие профессиональные
инструменты обратного проектирования используют эмуляцию кода в процессе
реверс-инжениринга, и radare2 здесь не исключение.

Для частичной эмуляции (или неточной полной эмуляции) radare2 использует
свой собственный язык \href{../disassembling/esil.md}{ESIL} и
виртуальную машину. Radare2 поддерживает эмуляцию для всех платформ, для
которых заданы ESIL-эмуляторы (x86/x86\_64, ARM, arm64, MIPS, powerpc,
sparc, AVR, 8051, Gameboy, \ldots). Одним из распространенных применений
такой эмуляции является расчет косвенных и условных переходов.

Чтобы увидеть ESIL-представление программы, нужно использовать команду
\texttt{ao} или включить в конфигурации при помощи переменной
\texttt{asm.esil}. Использование этого режима помогает проверить,
правильно ли понимается код программы, освоить эмуляцию ESIL:

\begin{verbatim}
[0x00001660]> pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  lea rdi, obj.__progname      ; 0x207220
│     0x00001667  push rbp
│     0x00001668  lea rax, obj.__progname      ; 0x207220
│     0x0000166f  cmp rax, rdi
│     0x00001672  mov rbp, rsp
│ .─< 0x00001675  je 0x1690
│ │   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0
│ │   0x0000167e  test rax, rax
│.──< 0x00001681  je 0x1690
│││   0x00001683  pop rbp
│││   0x00001684  jmp rax
│``─> 0x00001690  pop rbp
`     0x00001691  ret
[0x00001660]> e asm.esil=true
[0x00001660]> pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  0x205bb9,rip,+,rdi,=
│     0x00001667  rbp,8,rsp,-=,rsp,=[8]
│     0x00001668  0x205bb1,rip,+,rax,=
│     0x0000166f  rdi,rax,==,$z,zf,=,$b64,cf,=,$p,pf,=,$s,sf,=,$o,of,=
│     0x00001672  rsp,rbp,=
│ .─< 0x00001675  zf,?{,5776,rip,=,}
│ │   0x00001677  0x20595a,rip,+,[8],rax,=
│ │   0x0000167e  0,rax,rax,&,==,$z,zf,=,$p,pf,=,$s,sf,=,$0,cf,=,$0,of,=
│.──< 0x00001681  zf,?{,5776,rip,=,}
│││   0x00001683  rsp,[8],rbp,=,8,rsp,+=
│││   0x00001684  rax,rip,=
│``─> 0x00001690  rsp,[8],rbp,=,8,rsp,+=
`     0x00001691  rsp,[8],rip,=,8,rsp,+=
\end{verbatim}

Чтобы вручную настроить эмуляцию ESIL, необходимо выполнить следующую
последовательность команд:

\begin{itemize}
\tightlist
\item
  \texttt{aei} для инициализации виртуальной машины ESIL,
\item
  \texttt{aeim} для инициализации памяти виртуальной машины ESIL (стек),
\item
  \texttt{aeip} - задание начального IP-адреса виртуальной машины ESIL
  (указатель инструкций),
\item
  последовательность команд \texttt{aer} для задания начальных значений
  регистра.
\end{itemize}

При выполнении эмуляции помните, что виртуальная машина ESIL не может
эмулировать внешние или системные вызовы вместе с инструкциями SIMD.
Таким образом, наиболее распространенным сценарием использования
является эмуляция небольшого куска кода, например
шифрование/расшифрования, распаковка или вычисления. После успешной
настройки виртуальной машины ESIL можно взаимодействовать с ней как в
обычном режиме отладки. Интерфейс командной строки виртуальной машины
ESIL практически идентичен интерфейсу отладчика:

\begin{itemize}
\tightlist
\item
  \texttt{aes} сделать шаг (или клавиша \texttt{s} в визуальном режиме,
  step),
\item
  \texttt{aesi} для перешагивания через вызовы функций (step over),
\item
  \texttt{aesu\ \textless{}address\textgreater{}} - выполнить шаг до
  указанного адреса (continue),
\item
  \texttt{aesue\ \textless{}ESIL\ expression\textgreater{}} - выполнять
  шаги до тех пор, пока не будет истинным какое-либо указанное выражение
  ESIL,
\item
  \texttt{aec} продолжать до прерывания по Ctrl-C, этот редко
  используется из-за вездесущности внешних вызовов.
\end{itemize}

В визуальном режиме все горячие клавиши отладки будут работать также в
режиме эмуляции ESIL.

Наряду с обычной эмуляцией, есть возможность записи и режим
воспроизведения (R\&R):

\begin{itemize}
\tightlist
\item
  \texttt{aets} для перечисления всех текущих сессий ESIL R\&R,
\item
  \texttt{aets+} для создания новой сессии R\&R,
\item
  \texttt{aesb} - движение вперед и назад в текущей сессии ESIL R\&R.
\end{itemize}

Подробнее об этом режиме работы можете прочесть в главе
\href{../debugger/revdebug.md}{Отладка в обратном направлении}.

\hypertarget{ux44dux43cux443ux43bux44fux446ux438ux44f-ux432-ux446ux438ux43aux43bux435-ux430ux43dux430ux43bux438ux437ux430}{%
\subsection{Эмуляция в цикле
анализа}\label{ux44dux43cux443ux43bux44fux446ux438ux44f-ux432-ux446ux438ux43aux43bux435-ux430ux43dux430ux43bux438ux437ux430}}

Помимо ручного режима эмуляции, ESIL можно использовать автоматически в
цикле анализа. Например, команда \texttt{aaaa} выполняет этап эмуляции
ESIL вместе с другими. Для отключения или включения использования ESIL
есть переменная конфигурации \texttt{anal.esil}. Есть еще одна важная
настройка, хотя и довольно опасная, особенно в случае вредоносного ПО -
\texttt{emu.write}, которое позволяет виртуальной машине ESIL изменять
содержимое памяти. Эта возможность очень полезна в процессе деобфускации
или распаковки кода.

Для отображения данных в процессе эмуляции настраивается переменная
\texttt{asm.emu}. В результате radare2 будет показывать вычисляемое
значение регистра и памяти в комментариях к дизассемблированному коду:

\begin{verbatim}
[0x00001660]> e asm.emu=true
[0x00001660]> pdf
. (fcn) fcn.00001660 40
│   fcn.00001660 ();
│     ; CALL XREF from 0x00001713 (entry2.fini)
│     0x00001660  lea rdi, obj.__progname ; 0x207220 ; rdi=0x207220 -> 0x464c457f
│     0x00001667  push rbp                ; rsp=0xfffffffffffffff8
│     0x00001668  lea rax, obj.__progname ; 0x207220 ; rax=0x207220 -> 0x464c457f
│     0x0000166f  cmp rax, rdi            ; zf=0x1 -> 0x2464c45 ; cf=0x0 ; pf=0x1 -> 0x2464c45 ; sf=0x0 ; of=0x0
│     0x00001672  mov rbp, rsp            ; rbp=0xfffffffffffffff8
│ .─< 0x00001675  je 0x1690               ; rip=0x1690 -> 0x1f0fc35d ; likely
│ │   0x00001677  mov rax, qword [reloc._ITM_deregisterTMCloneTable] ; [0x206fd8:8]=0 ; rax=0x0
│ │   0x0000167e  test rax, rax           ; zf=0x1 -> 0x2464c45 ; pf=0x1 -> 0x2464c45 ; sf=0x0 ; cf=0x0 ; of=0x0
│.──< 0x00001681  je 0x1690               ; rip=0x1690 -> 0x1f0fc35d ; likely
│││   0x00001683  pop rbp                 ; rbp=0xffffffffffffffff -> 0x4c457fff ; rsp=0x0
│││   0x00001684  jmp rax                 ; rip=0x0 ..
│``─> 0x00001690  pop rbp                 ; rbp=0x10102464c457f ; rsp=0x8 -> 0x464c457f
`     0x00001691  ret                     ; rip=0x0 ; rsp=0x10 -> 0x3e0003
\end{verbatim}

Обратите внимание на комментарии с меткой \texttt{likely}, где эмуляция
ESIL предсказала переход. Помимо базовой настройки виртуальной машины
ESIL, можно изменять ее поведение с помощью других доступных параметров
в пространствах имен конфигурации \texttt{emu.} и \texttt{esil}. Для
управления ESIL, работающей с памятью и стеком, можно использовать
следующие варианты настроек:

\begin{itemize}
\tightlist
\item
  \texttt{esil.stack} для включения или отключения временного стека для
  режима \texttt{asm.emu},
\item
  \texttt{esil.stack.addr} для задания адреса стека в виртуальной машине
  ESIL (аналогично команде \texttt{aeim}),
\item
  \texttt{esil.stack.size} для установки размера стека в виртуальной
  машине ESIL (аналогично команде \texttt{aeim}),
\item
  \texttt{esil.stack.depth} ограничивает количество операций PUSH в
  стеке,
\item
  \texttt{esil.romem} определяет доступ к памяти ESIL ``только для
  чтения'',
\item
  \texttt{esil.fillstack} и \texttt{esil.stack.pattern} позволяют
  использовать различные шаблоны для заполнения стека виртуальной машины
  ESIL при инициализации,
\item
  \texttt{esil.nonull} - остановить выполнение ESIL при чтении или
  записи нулевого указателя.
\end{itemize}

\hypertarget{ux441ux438ux43cux432ux43eux43bux44b}{%
\section{Символы}\label{ux441ux438ux43cux432ux43eux43bux44b}}

Radare2 автоматически анализирует доступные разделы импорта и экспорта в
двоичном файле, он также может загружать отладочную информацию, если
таковая будет найдена. Поддерживаются два основных формата: DWARF и PDB
(для двоичных файлов Windows). Обратите внимание, что, в отличие от
многих инструментов, raide2 не использует Windows API для анализа
PDB-файлов, поэтому их можно загружать на любой другой поддерживаемой
платформе, включая Линукс или OS Х.

Отладочная информация DWARF загружается автоматически по умолчанию,
поскольку обычно она сохраняется прямо в исполняемом файле. PDB
используется по-другому, так как он хранится как отдельный двоичный
файл. Одним из распространенных сценариев является анализ файла из
дистрибутива Windows. В этом случае все файлы PDB доступны на сервере
Microsoft, который по умолчанию есть в настройках. Посмотреть все
параметры pdb в радаре2:

\begin{verbatim}
pdb.autoload = 0
pdb.extract = 1
pdb.server = https://msdl.microsoft.com/download/symbols
pdb.useragent = Microsoft-Symbol-Server/6.11.0001.402
\end{verbatim}

Используя переменную \texttt{pdb.server} можно изменить адрес, по
которому Radare2 будет загружать PDB по известному GUID, хранящемуся в
заголовке исполняемого файла. Можно использовать несколько серверов,
предоставляющих символы, разделив их URL-ы точкой с запятой:

\begin{verbatim}
e pdb.server = https://msdl.microsoft.com/download/symbols;https://symbols.mozilla.org/
\end{verbatim}

В Windows можно также использовать общие сетевые пути (UNC-пути) в
качестве серверов символов. Обычно нет особых причин изменять значение
по умолчанию \texttt{pdb.useragent}, но кто знает\ldots? Поскольку файлы
PDB хранятся на сервере в виде CAB-архивов, переменная
\texttt{pdb.extract=1} настраивает ядро на автоматическую их распаковку.
Обратите внимание, что для автоматической загрузки вам нужна утилиты
операционной системы «\emph{cabextract}» и \emph{wget/curl}.

Иногда нужно грузить символы не в radare2, а в других инструментах,
например в rabin2:

\begin{verbatim}
 -P              показать отладочную/pdb информацию
 -PP             загрузить файл pdb
\end{verbatim}

Здесь \texttt{-PP} автоматически загружает pdb для выбранного двоичного
файла, используя настройки в \texttt{pdb.*}. Флаг \texttt{-P} сбросит
дамп файла PDB, его можно открыть и посмотреть хранящихся в нем символы.
Помимо основного сценария, простого открытия файла, информацией PDB
можно дополнительно манипулировать при помощи команды \texttt{id}:

\begin{verbatim}
[0x000051c0]> id?
|Usage: id Отладочная информация
| Ражим вывода:
| '*'              Выводить в виде команд radare
| id               Строки исходного кода
| idp [file.pdb]   Загрузить информацию о файле pdb
| idpi [file.pdb]  Показать информацию о файле pdb
| idpd             Загрузить pdb-файл с удаленного сервера
\end{verbatim}

Здесь команда \texttt{idpi} делает то же самое, что и
\texttt{rabin2\ -P}. Команду \texttt{idp} также можно использовать не
только во время статического анализа, но и в режиме отладки, даже если
отладка ведется при помощи WinDbg.

Для упрощения использования PDB, особенно в процессе анализа двоичных
файлов с большим количеством связанных DLL, radare2 автоматически
загружает все необходимые PDB, нужно просто установить
\texttt{e\ pdb.autoload=true}. Затем, при открытии какого-либо файла в
режиме отладки в Windows, используя \texttt{r2\ -d\ файл.exe} или
\texttt{р2\ -d\ 2345} (присоединиться к pid 2345), все связанные
PDB-файлы будут автоматически загружены.

Загрузка информации в формате DWARF полностью автоматизирована. Не нужно
запускать какие-либо команды/изменять параметры:

\begin{verbatim}
r2 `which rabin2`
[0x00002437 8% 300 /usr/local/bin/rabin2]> pd $r
0x00002437  jne 0x2468                  ;[1]
0x00002439  cmp qword reloc.__cxa_finalize_224, 0
0x00002441  push rbp
0x00002442  mov rbp, rsp
0x00002445  je 0x2453                   ;[2]
0x00002447  lea rdi, obj.__dso_handle   ; 0x207c40 ; "@| "
0x0000244e  call 0x2360                 ;[3]
0x00002453  call sym.deregister_tm_clones ;[4]
0x00002458  mov byte [obj.completed.6991], 1 ; obj.__TMC_END__ ; [0x2082f0:1]=0
0x0000245f  pop rbp
0x00002460  ret
0x00002461  nop dword [rax]
0x00002468  ret
0x0000246a  nop word [rax + rax]
;-- entry1.init:
;-- frame_dummy:
0x00002470  push rbp
0x00002471  mov rbp, rsp
0x00002474  pop rbp
0x00002475  jmp sym.register_tm_clones  ;[5]
;-- blob_version:
0x0000247a  push rbp                    ; ../blob/version.c:18
0x0000247b  mov rbp, rsp
0x0000247e  sub rsp, 0x10
0x00002482  mov qword [rbp - 8], rdi
0x00002486  mov eax, 0x32               ; ../blob/version.c:24 ; '2'
0x0000248b  test al, al                 ; ../blob/version.c:19
0x0000248d  je 0x2498                   ;[6]
0x0000248f  lea rax, str.2.0.1_182_gf1aa3aa4d ; 0x60b8 ; "2.0.1-182-gf1aa3aa4d"
0x00002496  jmp 0x249f                  ;[7]
0x00002498  lea rax, 0x000060cd
0x0000249f  mov rsi, qword [rbp - 8]
0x000024a3  mov r8, rax
0x000024a6  mov ecx, 0x40               ; section_end.ehdr
0x000024ab  mov edx, 0x40c0
0x000024b0  lea rdi, str._s_2.1.0_git__d___linux_x86__d_git._s_n ; 0x60d0 ; "%s 2.1.0-git %d @ linux-x86-%d git.%s\n"
0x000024b7  mov eax, 0
0x000024bc  call 0x2350                 ;[8]
0x000024c1  mov eax, 0x66               ; ../blob/version.c:25 ; 'f'
0x000024c6  test al, al
0x000024c8  je 0x24d6                   ;[9]
0x000024ca  lea rdi, str.commit:_f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385_build:_2017_11_06__12:18:39 ; ../blob/version.c:26 ; 0x60f8 ; "commit: f1aa3aa4d2599c1ad60e3ecbe5f4d8261b282385 build: 2017-11-06__1
0x000024d1  call sym.imp.puts           ;[?]
0x000024d6  mov eax, 0                  ; ../blob/version.c:28
0x000024db  leave                       ; ../blob/version.c:29
0x000024dc  ret
;-- rabin_show_help:
0x000024dd  push rbp                    ; .//rabin2.c:27
\end{verbatim}

Как видите, загружаются имена функций и информация об исходной строке.

\hypertarget{ux441ux438ux433ux43dux430ux442ux443ux440ux44b}{%
\section{Сигнатуры}\label{ux441ux438ux433ux43dux430ux442ux443ux440ux44b}}

Radare2 реализует собственный формат сигнатур ``библиотечных'' функций,
позволяющий как их загружать/применять, так и создавать на лету. Они
доступны в пространстве имен команд \texttt{z}:

\begin{verbatim}
[0x00000000]> z?
Usage: z[*j-aof/cs] [args]   # Управление сигнатурами
| z            показать сигнатуры
| z.           найти сигнатуры, коотрые соответствуют текущему смещению
| zb[?][n=5]   поиск наилучшего соответствия
| z*           показать сигнатуры в формате radare
| zq           показать сигнатуры в "тихом" режиме
| zj           показать сигнатуры в формате json
| zk           показать сишнатуры в формате sdb
| z-zignature  удалить сигнатуру
| z-*          удалить все сигнатуры
| za[?]        добавить сигнатуру
| zg           сгенерировать сигнатуру (псевдоним для zaF)
| zo[?]        управление файлами сигнатур
| zf[?]        управление сигнатурами формата FLIRT
| z/[?]        поиск сигнатур
| zc[?]        сравнить текущее пространство сигнатур с другим
| zs[?]        управление пространством сигнатур
| zi           показать информацию о соответствии сигнатуре
\end{verbatim}

Для загрузки созданного файла сигнатур необходимо загрузить его из
SDB-файла с помощью команды \texttt{zo} или из сжатого SDB-файла -
\texttt{zoz}.

Для создания сигнатуры нужно сначала определить функцию, затем из нее
сигнатуру:

\begin{verbatim}
r2 /bin/ls
[0x000051c0]> aaa # this creates functions, including 'entry0'
[0x000051c0]> zaf entry0 entry
[0x000051c0]> z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]>
\end{verbatim}

Как видите, сделана новая сигнатура с именем \texttt{entry} из функции
\texttt{entry0}. Также можете представить сигнатуру в формате JSON, что
полезно для использования в сценариях:

\begin{verbatim}
[0x000051c0]> zj~{}
[
  {
    "name": "entry",
    "bytes": "31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4",
    "graph": {
      "cc": "1",
      "nbbs": "1",
      "edges": "0",
      "ebbs": "1"
    },
    "offset": 20928,
    "refs": [
    ]
  }
]
[0x000051c0]>
\end{verbatim}

Чтобы удалить эту сигнатуру, просто выполните \texttt{z-entry}.

Все созданные сигнатуры сохраняются в SDB-файл с помощью команды
\texttt{zos\ myentry}. Позже их можно применить, снова откроем файл:

\begin{verbatim}
r2 /bin/ls
 -- Войти. Взломать. Перейти куда угодно. Получить все.
[0x000051c0]> zo myentry
[0x000051c0]> z
entry:
  bytes: 31ed4989d15e4889e24883e4f050544c............48............48............ff..........f4
  graph: cc=1 nbbs=1 edges=0 ebbs=1
  offset: 0x000051c0
[0x000051c0]>
\end{verbatim}

Это означает, что сигнатуры успешно загружены из файла \texttt{myentry}
и теперь можно искать соответствующие функции:

\begin{verbatim}
[0x000051c0]> z.
[+] searching 0x000051c0 - 0x000052c0
[+] searching function metrics
hits: 1
[0x000051c0]>
\end{verbatim}

Обратите внимание, что команда \texttt{z.} просто проверяет сигнатуру по
текущему адресу. Чтобы искать сигнатуры по всему файлу, нужно выполнить
другую команду. Есть важный момент, если просто запустить ее «как есть»,
то она ничего не найдет:

\begin{verbatim}
[0x000051c0]> z/
[+] searching 0x0021dfd0 - 0x002203e8
[+] searching function metrics
hits: 0
[0x000051c0]>
\end{verbatim}

Обратите внимание на поисковый адрес --- нам нужно сначала
\href{../search_bytes/configurating_the_search.md}{настроить диапазон
поиска}:

\begin{verbatim}
[0x000051c0]> e search.in=io.section
[0x000051c0]> z/
[+] searching 0x000038b0 - 0x00015898
[+] searching function metrics
hits: 1
[0x000051c0]>
\end{verbatim}

Мы устанавливаем режим поиска в \texttt{io.section} (это был
\texttt{файл} по умолчанию) на поиск в текущей секции (при условии, что
мы все еще находимся в разделе \texttt{.text}). Теперь можно посмотреть,
что именно нашел radare2:

\begin{verbatim}
[0x000051c0]> pd 5
;-- entry0:
;-- sign.bytes.entry_0:
0x000051c0      31ed           xor ebp, ebp
0x000051c2      4989d1         mov r9, rdx
0x000051c5      5e             pop rsi
0x000051c6      4889e2         mov rdx, rsp
0x000051c9      4883e4f0       and rsp, 0xfffffffffffffff0
[0x000051c0]>
\end{verbatim}

Здесь видно комментарий \texttt{entry0}, который взят из
дизассемблирования ELF, а также \texttt{sign.bytes.entry\_0}, которая
является именно результатом совпадения сигнатуры.

Конфигурация для механизма сигнатур хранится в переменных среды в
пространстве имен \texttt{zign.}:

\begin{verbatim}
[0x000051c0]> e? zign.
       zign.autoload: Автозагрузка всех зигнатур, расположенных в ~/.local/share/radare2/zigns
          zign.bytes: Использование шаблонов байтов для сопоставления
   zign.diff.bthresh: Пороговое значение для дифференциации zign-байтов [0, 1] (см. zc?)
   zign.diff.gthresh: Порог для дифференцированных графиков zign [0, 1] (см. zc?)
          zign.graph: Использование метрик графа для сопоставления
           zign.hash: Использование хэша для сопоставления
          zign.maxsz: Максимальная длина сигнатуры
          zign.mincc: Минимальная цикломатическая сложность для сопоставления
          zign.minsz: Минимальная длина сигнатуры для сопоставления
         zign.offset: Используйте исходное смещение для сопоставления
         zign.prefix: Префикс по умолчанию для совпадений сигнатур
           zign.refs: Использолать ссылки для сопоставления
      zign.threshold: Минимальное сходство, необходимое для включения в результаты zb
          zign.types: Использование типов для сопоставления
[0x000051c0]>
\end{verbatim}

\hypertarget{ux43fux43eux438ux441ux43a-ux43bux443ux447ux448ux438ux445-ux441ux43eux432ux43fux430ux434ux435ux43dux438ux439-zb}{%
\subsection{\texorpdfstring{Поиск лучших совпадений
\texttt{zb}}{Поиск лучших совпадений zb}}\label{ux43fux43eux438ux441ux43a-ux43bux443ux447ux448ux438ux445-ux441ux43eux432ux43fux430ux434ux435ux43dux438ux439-zb}}

Часто бывает, что сигнатура должна существовать где-то в двоичном файле,
но \texttt{z/} и \texttt{z.} все еще терпят неудачу. Это часто связано с
очень незначительными различиями между сигнатурой и функцией. Например,
компилятор поменял местами две инструкции или сигнатура не для
подходящей версии функции. В этих ситуациях команды \texttt{zb}
по-прежнему могут помочь указать вам правильное направление, перечислив
примерные совпадения.

\begin{verbatim}
[0x000040a0]> zb?
Usage: zb[r?] [args]  # поиск сигнатуры, имеющей наилучшее совпадение
| zb [n]           найти n наиболее подходящих сигнатур для функции по текущему смещению
| zbr zigname [n]  поиск n наиболее похожих функций на заданную сигнатуру
\end{verbatim}

Команда \texttt{zb} (zign best) покажет пять наиболее близких сигнатур
для заданной функции. Каждая из них будет содержать оценку от 0.0 до
1.0.

\begin{verbatim}
[0x0041e390]> s sym.fclose
[0x0040fc10]> zb
0.96032  0.92400 B  0.99664 G   sym.fclose
0.65971  0.35600 B  0.96342 G   sym._nl_expand_alias
0.65770  0.37800 B  0.93740 G   sym.fdopen
0.65112  0.35000 B  0.95225 G   sym.__run_exit_handlers
0.62532  0.34800 B  0.90264 G   sym.__cxa_finalize
\end{verbatim}

В приведенном выше примере \texttt{zb} правильно связала подпись
\texttt{sym.fclose} с текущей функцией. Команды \texttt{z/} и
\texttt{z.} не сработали бы здесь, так как оценки \texttt{B}yte и
\texttt{Gh}rap меньше 1.0. Разница 30\% между результатами первого и
второго места также является хорошим показателем правильного
соответствия.

Команда \texttt{zbr} (zign best reverse) принимает имя сигнатуры и
пытается найти наиболее близко соответствующие функции. Используйте
команду анализа, например \texttt{aa}, чтобы найти сначала функции.

\begin{verbatim}
[0x00401b20]> aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x00401b20]> zo ./libc.sdb
[0x00401b20]> zbr sym.__libc_malloc 10
0.94873  0.89800 B  0.99946 G   sym.malloc
0.65245  0.40600 B  0.89891 G   sym._mid_memalign
0.59470  0.38600 B  0.80341 G   sym._IO_flush_all_lockp
0.59200  0.28200 B  0.90201 G   sym._IO_file_underflow
0.57802  0.30400 B  0.85204 G   sym.__libc_realloc
0.57094  0.35200 B  0.78988 G   sym.__calloc
0.56785  0.34000 B  0.79570 G   sym._IO_un_link.part.0
0.56358  0.36200 B  0.76516 G   sym._IO_cleanup
0.56064  0.26000 B  0.86127 G   sym.intel_check_word.constprop.0
0.55726  0.28400 B  0.83051 G   sym.linear_search_fdes
\end{verbatim}

\hypertarget{ux43aux43eux43cux430ux43dux434ux44b-ux433ux440ux430ux444ux430-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f}{%
\section{Команды графа
управления}\label{ux43aux43eux43cux430ux43dux434ux44b-ux433ux440ux430ux444ux430-ux443ux43fux440ux430ux432ux43bux435ux43dux438ux44f}}

При анализе данных обычно удобно иметь разные способы их представления,
чтобы получить новый обобщенный взгляд, позволяющий аналитику понять,
как взаимодействуют различные части программы. Представление базовых
блоков (далее в разделе, просто блоков), вызовов функций, строковых
ссылок в виде графов (графов управления) показывает очень четкое
представление этой информации. Radare2 поддерживает различные типы
графов, доступные с помощью команд, начинающихся с \texttt{ag}:

\begin{verbatim}
[0x00005000]> ag?
|Usage: ag<graphtype><format> [addr]
| Команды графов:
| aga[format]             Граф ссылок данных
| agA[format]             Глобальный граф ссылок данных
| agc[format]             Граф функций
| agC[format]             Глобальный граф вызовов функций
| agd[format] [fcn addr]  Граф различий
| agf[format]             Граф базовых блоков функции
| agi[format]             Граф импортов
| agr[format]             Граф ссылок
| agR[format]             Глобальный граф ссылок
| agx[format]             Граф перекресных ссылок
| agg[format]             Граф общего вида, настраиваемый
| ag-                     Очистить граф общего вида
| agn[?] title body       Добавить узел в настраиваемый граф
| age[?] title1 title2    Добавить дугу в настраиваемый граф

Форматы вывода:
| <blank>                 Псевдографика Ascii
| *                       Команды r2
| d                       Формат dot Graphviz-а
| g                       Формат gml (Graph Modelling Language)
| j                       JSON ('J' для форматированного дизассемблирования)
| k                       Ключ-значение SDB
| t                       Крошечный ascii-art
| v                       Интерактивный ascii-art
| w [path]                Записать в файл или показать на экране изображение (смотрите graph.gv.format и graph.web)
\end{verbatim}

Структура команд следующая:
\texttt{ag\ \textless{}graph\ type\textgreater{}\ \textless{}output\ format\textgreater{}}.
Например, \texttt{agid} отображает граф импорта в точечном формате, а
\texttt{aggj} выводит граф в формате JSON. Вот краткое описание для
каждого доступного формата вывода:

\hypertarget{ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agf}{%
\subsubsection{\texorpdfstring{Ascii Art ** (например,
\texttt{agf})}{Ascii Art ** (например, agf)}}\label{ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agf}}

Выводит граф на stdout, используя ASCII-art для представления блоков и
ребер. \emph{Предупреждение: отображение больших графов в stdout может
оказаться вычислительно дорогостоящим, r2 может перестать реагировать на
команды в течение некоторого времени.} В случае сомнений, используйте
интерактивное представление (рассматривается ниже).

\hypertarget{ux438ux43dux442ux435ux440ux430ux43aux442ux438ux432ux43dux44bux439-ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agfv}{%
\subsubsection{\texorpdfstring{Интерактивный Ascii-art (например,
\texttt{agfv})}{Интерактивный Ascii-art (например, agfv)}}\label{ux438ux43dux442ux435ux440ux430ux43aux442ux438ux432ux43dux44bux439-ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agfv}}

Отображает граф в ASCII в интерактивном представлении, аналогичном
\texttt{VV}, позволяющее перемещать экран, увеличивать/уменьшать,
\ldots{}

\hypertarget{ux43aux440ux43eux448ux435ux447ux43dux44bux439-ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agft}{%
\subsubsection{\texorpdfstring{Крошечный Ascii-art (например,
\texttt{agft})}{Крошечный Ascii-art (например, agft)}}\label{ux43aux440ux43eux448ux435ux447ux43dux44bux439-ascii-art-ux43dux430ux43fux440ux438ux43cux435ux440-agft}}

Отображает график ASCII непосредственно в stdout в этом режиме (что
аналогично достижению максимального уровня уменьшения масштаба в
интерактивном представлении).

\hypertarget{graphviz-dot-ux43dux430ux43fux440ux438ux43cux435ux440-agfd}{%
\subsubsection{\texorpdfstring{Graphviz dot (например,
\texttt{agfd})}{Graphviz dot (например, agfd)}}\label{graphviz-dot-ux43dux430ux43fux440ux438ux43cux435ux440-agfd}}

Печатает исходный код dot, представляющий граф, интерпретируемый
программами типа \href{https://graphviz.gitlab.io/download/}{graphviz}
или онлайн-вьюверами, подобными
\href{http://www.webgraphviz.com/}{этому}.

\hypertarget{json-ux43dux430ux43fux440ux438ux43cux435ux440-agfj}{%
\subsubsection{\texorpdfstring{JSON (например,
\texttt{agfj})}{JSON (например, agfj)}}\label{json-ux43dux430ux43fux440ux438ux43cux435ux440-agfj}}

Выводит строку JSON, представляющую граф.

\begin{itemize}
\item
  В случае формата \texttt{f} (блоки функции), будет отображена подробно
  информация о функции, ее дизассемблирование (используйте формат
  \texttt{J} для форматированного дизассемблирования).
\item
  Во всех остальных случаях он будет содержать только основную
  информацию об узлах графа (идентификатор, заголовок, тело и ребра).
\end{itemize}

\hypertarget{ux44fux437ux44bux43a-ux43cux43eux434ux435ux43bux438ux440ux43eux432ux430ux43dux438ux44f-ux433ux440ux430ux444ux430-ux43dux430ux43fux440ux438ux43cux435ux440-agfg}{%
\subsubsection{\texorpdfstring{Язык моделирования графа (например,
\texttt{agfg})}{Язык моделирования графа (например, agfg)}}\label{ux44fux437ux44bux43a-ux43cux43eux434ux435ux43bux438ux440ux43eux432ux430ux43dux438ux44f-ux433ux440ux430ux444ux430-ux43dux430ux43fux440ux438ux43cux435ux440-agfg}}

Выводит исходный код GML, представляющий граф, интерпретируемый,
например, программой
\href{https://www.yworks.com/products/yed/download}{yEd}

\hypertarget{ux43aux43bux44eux447-ux437ux43dux430ux447ux435ux43dux438ux435-sdb-ux43dux430ux43fux440ux438ux43cux435ux440-agfk}{%
\subsubsection{\texorpdfstring{Ключ-значение SDB (например,
\texttt{agfk})}{Ключ-значение SDB (например, agfk)}}\label{ux43aux43bux44eux447-ux437ux43dux430ux447ux435ux43dux438ux435-sdb-ux43dux430ux43fux440ux438ux43cux435ux440-agfk}}

Печатает строки ``ключ-значение'', представляющие граф, сохраненный в
sdb (строковая база данных radare2).

\hypertarget{ux43fux43eux43bux44cux437ux43eux432ux430ux442ux435ux43bux44cux441ux43aux438ux435-ux43aux43eux43cux430ux43dux434ux44b-r2-ux434ux43bux44f-ux433ux440ux430ux444ux430-ux43dux430ux43fux440ux438ux43cux435ux440-agf}{%
\subsubsection{\texorpdfstring{Пользовательские команды R2 для графа
(например,
\texttt{agf*})}{Пользовательские команды R2 для графа (например, agf*)}}\label{ux43fux43eux43bux44cux437ux43eux432ux430ux442ux435ux43bux44cux441ux43aux438ux435-ux43aux43eux43cux430ux43dux434ux44b-r2-ux434ux43bux44f-ux433ux440ux430ux444ux430-ux43dux430ux43fux440ux438ux43cux435ux440-agf}}

Печатает команды r2, которые воссоздают нужный граф. Команды для
построения графа: \texttt{agn\ {[}title{]}\ {[}body{]}} - добавление
узла и \texttt{age\ {[}title1{]}\ {[}title2{]}} - добавление ребра. Поле
\texttt{{[}body{]}} можно представлять в base64 для включения
специального форматирования (например, новых строк).

Чтобы выполнять напечатанные команды, можно добавить точку к команде
(\texttt{.agf*}).

\hypertarget{ux432ux435ux431-ux438ux437ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux43dux430ux43fux440ux438ux43cux435ux440-agfw}{%
\subsubsection{\texorpdfstring{Веб / изображение (например,
\texttt{agfw})}{Веб / изображение (например, agfw)}}\label{ux432ux435ux431-ux438ux437ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux43dux430ux43fux440ux438ux43cux435ux440-agfw}}

Radare2 преобразует график в формат dot. Программа \texttt{dot}
преобразует его в \texttt{.gif}-изображение, а затем результат можно
просмотреть в вашей операционной системе (\texttt{xdg-open},
\texttt{open}, \texttt{eog}, \texttt{xnview}, \ldots).

Расширение файла для изображения задается с помощью переменной
\texttt{конфигурации\ graph.extension}. Доступны расширения
\texttt{png,\ jpg,\ gif,\ pdf,\ ps}.

\emph{Примечание: для особенно больших графиков рекомендуемым
расширением является \texttt{svg}, так как оно будет производить
изображения гораздо меньшего размера.}

Если переменная конфигурации \texttt{graph.web} включена, radare2
попытается отобразить график с помощью браузера (\emph{эта функция
является экспериментальной и незавершенной, отключена по умолчанию.})

\hypertarget{ux441ux43aux440ux438ux43fux442ux44b}{%
\subsection{Скрипты}\label{ux441ux43aux440ux438ux43fux442ux44b}}

Radare2 предоставляет широкий набор функций для автоматизации ``буровых
работ''. Он варьируется от простой последовательности команд до вызова
скриптов/программы через IPC (межпроцессное взаимодействие), называемое
r2pipe. Как уже упоминалось несколько раз, есть возможность писать
последовательности команды, используя знак \texttt{;}.

\begin{verbatim}
[0x00404800]> pd 1 ; ao 1
           0x00404800      b827e66100     mov eax, 0x61e627      ; "tab"
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]>
\end{verbatim}

Такая форма просто запускает вторую команду после завершения первой, как
в командной строке операционной системы. Второй способ создать
последовательность команд --- использовать обычный канал
\texttt{\textbar{}}.

\begin{verbatim}
адрес ao|grep
\end{verbatim}

Обратите внимание, что \texttt{\textbar{}} может передавать вывод команд
r2 только во внешнюю команду оболочки или в другую программу. Существует
аналогичный способ перечислять команды r2 с использованием оператора
обратной кавычки \texttt{\textasciigrave{}команда\textasciigrave{}}.
Часть в кавычках подвергнется подстановке команд, а вывод будет
использоваться в качестве аргумента командной строки.

Например, мы хотим увидеть несколько байтов памяти по указанному адресу,
на который ссылаются инструкции `mov eax, addr'. Сделать это можно,
используя последовательность команд:

\begin{verbatim}
[0x00404800]> pd 1
              0x00404800      b827e66100     mov eax, 0x61e627      ; "tab"
[0x00404800]> ao
address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]> ao~ptr[1]
0x0061e627
0
[0x00404800]> px 10 @ `ao~ptr[1]`
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x0061e627  7461 6200 2e69 6e74 6572                 tab..inter
[0x00404800]>
\end{verbatim}

Можно перенаправить вывод команды r2 в файл, используя
\texttt{\textgreater{}} и \texttt{\textgreater{}\textgreater{}}.

\begin{verbatim}
[0x00404800]> px 10 @ `ao~ptr[1]` > example.txt
[0x00404800]> px 10 @ `ao~ptr[1]` >> example.txt
\end{verbatim}

Radare2 также предоставляет много команд обработки файлов типа Unix,
таких, как head, tail, cat, grep и многие другие. Одна из таких команд -
\href{https://en.wikipedia.org/wiki/Uniq}{Uniq}, которую можно
использовать для фильтрации и отображения только неповторяющегося
содержимого. Итак, чтобы создать новый файл только с уникальными
строками, можно сделать:

\begin{verbatim}
[0x00404800]> uniq file > uniq_file
\end{verbatim}

Команда \href{https://en.wikipedia.org/wiki/Head_\%28Unix\%29}{head}
может использоваться для просмотра первых N строк в файле, аналогично
\href{https://en.wikipedia.org/wiki/Tail_(Unix)}{tail}, позволяющих
видеть последние N строк.

\begin{verbatim}
[0x00404800]> head 3 foodtypes.txt
1 Protein
2 Carbohydrate
3 Fat
[0x00404800]> tail 2 foodtypes.txt
3 Shake
4 Milk
\end{verbatim}

Команда \href{https://en.wikipedia.org/wiki/Join_\%28Unix\%29}{join}
может использоваться для объединения двух разных файлов с общим первым
полем.

\begin{verbatim}
[0x00404800]> cat foodtypes.txt
1 Protein
2 Carbohydrate
3 Fat
[0x00404800]> cat foods.txt
1 Cheese
2 Potato
3 Butter
[0x00404800]> join foodtypes foods.txt
1 Protein Cheese
2 Carbohydrate Potato
3 Fat Butter
\end{verbatim}

Точно так же делается сортировка контента при помощи команды
\href{https://en.wikipedia.org/wiki/Sort_\%28Unix\%29}{sort}. Типичный
пример:

\begin{verbatim}
[0x00404800]> sort file
eleven
five
five
great
one
one
radare
\end{verbatim}

Команда \texttt{?\$?} предоставляет информацию о нескольких полезных
переменных, похожих на переменные \texttt{\$v} - ``immediate value'' - и
\texttt{\$m} - ссылка на память из оп-кода.

\hypertarget{ux438ux442ux435ux440ux430ux442ux43eux440ux44b}{%
\section{Итераторы}\label{ux438ux442ux435ux440ux430ux442ux43eux440ux44b}}

Одной из наиболее распространенных задач в автоматизации является
циклическая обработка однотипных элементов, и в radare2 есть несколько
способов выполнять такие операции.

Перебор флагов:

\begin{verbatim}
@@ flagname-regex
\end{verbatim}

Например, надо увидеть информацию о функции с помощью команды
\texttt{afi}:

\begin{verbatim}
[0x004047d6]> afi
#
offset: 0x004047d0
name: entry0
size: 42
realsz: 42
stackframe: 0
call-convention: amd64
cyclomatic-complexity: 1
bits: 64
type: fcn [NEW]
num-bbs: 1
edges: 0
end-bbs: 1
call-refs: 0x00402450 C
data-refs: 0x004136c0 0x00413660 0x004027e0
code-xrefs:
data-xrefs:
locals:0
args: 0
diff: type: new
[0x004047d6]>
\end{verbatim}

Теперь предположим, мы хотели бы видеть определенное поле из этого
текста для всех функций, найденных в результате анализа. Можем сделать
это с помощью цикла по всем флагам функций, имя которых начинается с
\texttt{fcn.}:

\begin{verbatim}
[0x004047d6]> fs functions
[0x004047d6]> afi @@ fcn.* ~name
\end{verbatim}

Эта команда извлекает поле \texttt{name} из вывода \texttt{afi} каждого
флага с именем, соответствующим регулярному выражению \texttt{fcn.*}.
Для управления популярных операций в r2 реализован специальный цикл
\texttt{@@f}, запускающий команду для каждой функции, найденной r2:

\begin{verbatim}
[0x004047d6]> afi @@f ~name
\end{verbatim}

Также можно просмотреть список смещений, используя следующий синтаксис:

\begin{verbatim}
@@=1 2 3 ... N
\end{verbatim}

Предположим, что надо увидеть информацию о коде операции для двух
смещений, текущего и текущего + 2:

\begin{verbatim}
[0x004047d6]> ao @@=$$ $$+2
address: 0x4047d6
opcode: mov rdx, rsp
prefix: 0
bytes: 4889e2
refptr: 0
size: 3
type: mov
esil: rsp,rdx,=
stack: null
family: cpu
address: 0x4047d8
opcode: loop 0x404822
prefix: 0
bytes: e248
refptr: 0
size: 2
type: cjmp
esil: 1,rcx,-=,rcx,?{,4212770,rip,=,}
jump: 0x00404822
fail: 0x004047da
stack: null
cond: al
family: cpu
[0x004047d6]>
\end{verbatim}

Обратите внимание, что используется переменная \texttt{\$\$} равная
текущему смещению. Выражение \texttt{\$\$+2} вычисляется перед циклом,
поэтому можно использовать простые арифметические выражения.

Третий способ создания циклов --- загрузка смещений из файла. Файл
должен содержать одно смещение на строку.

\begin{verbatim}
[0x004047d0]> ?v $$ > offsets.txt
[0x004047d0]> ?v $$+2 >> offsets.txt
[0x004047d0]> !cat offsets.txt
4047d0
4047d2
[0x004047d0]> pi 1 @@.offsets.txt
xor ebp, ebp
mov r9, rdx
\end{verbatim}

Radare2 также предлагает различные конструкции \texttt{foreach}. Одним
из наиболее полезных является перебор всех инструкций функции:

\begin{verbatim}
[0x004047d0]> pdf
╒ (fcn) entry0 42
│; UNKNOWN XREF from 0x00400018 (unk)
│; DATA XREF from 0x004064bf (sub.strlen_460)
│; DATA XREF from 0x00406511 (sub.strlen_460)
│; DATA XREF from 0x0040b080 (unk)
│; DATA XREF from 0x0040b0ef (unk)
│0x004047d0  xor ebp, ebp
│0x004047d2  mov r9, rdx
│0x004047d5  pop rsi
│0x004047d6  mov rdx, rsp
│0x004047d9  and rsp, 0xfffffffffffffff0
│0x004047dd  push rax
│0x004047de  push rsp
│0x004047df  mov r8, 0x4136c0
│0x004047e6  mov rcx, 0x413660      ; "AWA..AVI..AUI..ATL.%.. "
0A..AVI..AUI.
│0x004047ed  mov rdi, main          ; "AWAVAUATUH..S..H...." @
0
│0x004047f4  call sym.imp.__libc_start_main
╘0x004047f9  hlt
[0x004047d0]> pi 1 @@i
mov r9, rdx
pop rsi
mov rdx, rsp
and rsp, 0xfffffffffffffff0
push rax
push rsp
mov r8, 0x4136c0
mov rcx, 0x413660
mov rdi, main
call sym.imp.__libc_start_main
hlt
\end{verbatim}

В этом примере команда \texttt{pi\ 1} печатает все инструкции в текущей
функции (entry0). Есть и другие варианты (неполный список, смотрите
инструкции \texttt{@@?}): - \texttt{@@k\ sdbquery} - перебрать все
смещения, полученные в запросе к sdb, - \texttt{@@t} - перебрать все
нити (threads, смотрите dp), - \texttt{@@b} - перебрать все базовые
блоки текущей функции (смотрите afb), - \texttt{@@f} - перебрать все
функции (смотрите aflq).

Последний вид циклов позволяет перебирать предопределенные типы
итераторов:

\begin{itemize}
\tightlist
\item
  символы,
\item
  импорты,
\item
  реестры,
\item
  нити,
\item
  комментарии,
\item
  функции,
\item
  флаги.
\end{itemize}

Перебор делается с помощью команды \texttt{@@@}. Предыдущий пример
вывода информации о функциях также можно выполнить с помощью команды
\texttt{@@@}:

\begin{verbatim}
[0x004047d6]> afi @@@ functions ~name
\end{verbatim}

В результате удается извлечь поле \texttt{name} из вывода \texttt{afi},
при этом будет выведен огромный список названий функций. Можно выбрать,
например, только второй столбец, убрать лишнюю строку \texttt{name:} в
каждой строке:

\begin{verbatim}
[0x004047d6]> afi @@@ functions ~name[1]
\end{verbatim}

\textbf{Осторожно, @@@ несовместим с командами JSON.}

\hypertarget{ux43cux430ux43aux440ux43eux441ux44b}{%
\section{Макросы}\label{ux43cux430ux43aux440ux43eux441ux44b}}

Помимо просто последовательности команд и циклов, radare2 позволяет
записывать простые макросы, используя конструкцию:

\begin{verbatim}
[0x00404800]> (qwe; pd 4; ao)
\end{verbatim}

Эта форма определяет макрос под названием `qwe', запускающий
последовательно сначала `pd 4', затем `ao'. Вызов макроса использует
синтаксис \texttt{.(имя\_макроса)}:

\begin{verbatim}
[0x00404800]> (qwe; pd 4; ao)
[0x00404800]> .(qwe)
0x00404800  mov eax, 0x61e627      ; "tab"
0x00404805  push rbp
0x00404806  sub rax, section_end.LOAD1
0x0040480c  mov rbp, rsp

address: 0x404800
opcode: mov eax, 0x61e627
prefix: 0
bytes: b827e66100
ptr: 0x0061e627
refptr: 0
size: 5
type: mov
esil: 6415911,rax,=
stack: null
family: cpu
[0x00404800]>
\end{verbatim}

Чтобы просмотреть доступные макросы, вызовите \texttt{(*}:

\begin{verbatim}
[0x00404800]> (*
(qwe ; pd 4; ao)
\end{verbatim}

А если хотите удалить какой-то макрос, просто добавьте `-' перед
названием:

\begin{verbatim}
[0x00404800]> (-qwe)
Macro 'qwe' removed.
[0x00404800]>
\end{verbatim}

Можно создать макрос, принимающий аргументы, --- удобный механизм при
создании простых сценариев. Чтобы создать макрос, принимающий аргументы,
просто добавьте их в определение макроса.

\begin{verbatim}
[0x00404800]
[0x004047d0]> (foo x y; pd $0; s +$1)
[0x004047d0]> .(foo 5 6)
;-- entry0:
0x004047d0      xor ebp, ebp
0x004047d2      mov r9, rdx
0x004047d5      pop rsi
0x004047d6  mov rdx, rsp
0x004047d9  and rsp, 0xfffffffffffffff0
[0x004047d6]>
\end{verbatim}

Как видите, аргументы называются по индексу, начиная с 0: \$0, \$1,
\ldots{}

\hypertarget{ux43fux441ux435ux432ux434ux43eux43dux438ux43cux44b}{%
\section{Псевдонимы}\label{ux43fux441ux435ux432ux434ux43eux43dux438ux43cux44b}}

Radare2 также включает псевдонимы, помогающие сэкономить время, быстро
выполняя наиболее часто используемые команды. Они находятся в
\texttt{\$?}

Общее использование функции - \texttt{\$alias=cmd}

\begin{verbatim}
[0x00404800]> $disas=pdf
\end{verbatim}

Приведенная выше команда создаст псевдоним \texttt{disas} для
\texttt{pdf}. Следующая команда выводит разборку основной функции.

\begin{verbatim}
[0x00404800]> $disas @ main
\end{verbatim}

Помимо команд можно печатать текст.

\begin{verbatim}
[0x00404800]> $my_alias=$test input
[0x00404800]> $my_alias
test input
\end{verbatim}

Чтобы отменить определение псевдонима, используйте \texttt{\$alias=}:

\begin{verbatim}
[0x00404800]> $pmore='b 300;px'
[0x00404800]> $
$pmore
[0x00404800]> $pmore=
[0x00404800]> $
\end{verbatim}

Один \texttt{\$} в приведенном выше списке будет перечислять все
определенные псевдонимы. Также можно посмотреть команду псевдонима:

\begin{verbatim}
[0x00404800]> $pmore?
b 200; px
\end{verbatim}

Можно ли создать псевдоним, включающий другой псевдоним? Ответ --- да.

\begin{verbatim}
[0x00404800]> $pStart='s 0x0;$pmore'
[0x00404800]> $pStart
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x00000000  7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
0x00000010  0300 3e00 0100 0000 1014 0000 0000 0000  ..>.............
0x00000020  4000 0000 0000 0000 5031 0000 0000 0000  @.......P1......
0x00000030  0000 0000 4000 3800 0d00 4000 1e00 1d00  ....@.8...@.....
0x00000040  0600 0000 0400 0000 4000 0000 0000 0000  ........@.......
0x00000050  4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......
0x00000060  d802 0000 0000 0000 d802 0000 0000 0000  ................
0x00000070  0800 0000 0000 0000 0300 0000 0400 0000  ................
0x00000080  1803 0000 0000 0000 1803 0000 0000 0000  ................
0x00000090  1803 0000 0000 0000 1c00 0000 0000 0000  ................
0x000000a0  1c00 0000 0000 0000 0100 0000 0000 0000  ................
0x000000b0  0100 0000 0400 0000 0000 0000 0000 0000  ................
0x000000c0  0000 0000 0000 0000                      ........
[0x00000000]>
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-r2pipe}{%
\section{Программа
R2pipe}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-r2pipe}}

API r2pipe первоначально разработан для NodeJS, чтобы поддерживать
повторное использование веб-API r2.js из командной строки. Модуль r2pipe
позволяет взаимодействовать с процессами r2 различными методами:

\begin{itemize}
\tightlist
\item
  каналы после запуска spawn (r2 -0),
\item
  запросы http (удобный для облачных сервисов),
\item
  сокет tcp (r2 -c).
\end{itemize}

\begin{verbatim}
         pipe spawn async http tcp rap json
nodejs    x     x     x    x    x    -   x
python    x     x     -    x    x    x   x
swift     x     x     x    x    -    -   x
dotnet    x     x     x    x    -    -   -
haskell   x     x     -    x    -    -   x
java      -     x     -    x    -    -   -
golang    x     x     -    -    -    -   x
ruby      x     x     -    -    -    -   x
rust      x     x     -    -    -    -   x
vala      -     x     x    -    -    -   -
erlang    x     x     -    -    -    -   -
newlisp   x     -     -    -    -    -   -
dlang     x     -     -    -    -    -   x
perl      x     -     -    -    -    -   -
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-5}{%
\section{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-5}}

\hypertarget{python}{%
\subsection{Python}\label{python}}

\begin{verbatim}
$ pip install r2pipe
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ r2pipe}

\NormalTok{r2 }\OperatorTok{=}\NormalTok{ r2pipe.}\BuiltInTok{open}\NormalTok{(}\StringTok{"/bin/ls"}\NormalTok{)}
\NormalTok{r2.cmd(}\StringTok{\textquotesingle{}aa\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(r2.cmd(}\StringTok{"afl"}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(r2.cmdj(}\StringTok{"aflj"}\NormalTok{))  }\CommentTok{\# вычисляет JSON{-}ы и возвращает объект}
\end{Highlighting}
\end{Shaded}

\hypertarget{nodejs}{%
\subsection{NodeJS}\label{nodejs}}

Используйте команду для установки модулей привязки к r2pipe

\begin{verbatim}
$ npm install r2pipe
\end{verbatim}

Вот пример ``hello world'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{const r2pipe = require(\textquotesingle{}r2pipe\textquotesingle{});}
\NormalTok{r2pipe.open(\textquotesingle{}/bin/ls\textquotesingle{}, (err, res) =\textgreater{} \{}
\NormalTok{  if (err) \{}
\NormalTok{  throw err;}
\NormalTok{  \}}
\NormalTok{  r2.cmd (\textquotesingle{}af @ entry0\textquotesingle{}, function (o) \{}
\NormalTok{  r2.cmd ("pdf @ entry0", function (o) \{}
\NormalTok{    console.log (o);}
\NormalTok{    r.quit ()}
\NormalTok{  \});}
\NormalTok{  \});}
\NormalTok{\});}
\end{Highlighting}
\end{Shaded}

В репозитории GIT есть другие примеры и дополнительные сведения.

https://github.com/radareorg/radare2-r2pipe/blob/master/nodejs/r2pipe/README.md

\hypertarget{go}{%
\subsection{Go}\label{go}}

\begin{verbatim}
$ r2pm -i r2pipe-go
\end{verbatim}

\url{https://github.com/radare/r2pipe-go}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{package}\NormalTok{ main}

\KeywordTok{import} \OperatorTok{(}
  \StringTok{"fmt"}
  \StringTok{"github.com/radare/r2pipe{-}go"}
\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{func}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{  r2p}\OperatorTok{,}\NormalTok{ err }\OperatorTok{:=}\NormalTok{ r2pipe}\OperatorTok{.}\NormalTok{NewPipe}\OperatorTok{(}\StringTok{"/bin/ls"}\OperatorTok{)}
  \KeywordTok{if}\NormalTok{ err }\OperatorTok{!=} \OtherTok{nil} \OperatorTok{\{}
    \BuiltInTok{panic}\OperatorTok{(}\NormalTok{err}\OperatorTok{)}
  \OperatorTok{\}}
  \KeywordTok{defer}\NormalTok{ r2p}\OperatorTok{.}\NormalTok{Close}\OperatorTok{()}
\NormalTok{  buf1}\OperatorTok{,}\NormalTok{ err }\OperatorTok{:=}\NormalTok{ r2p}\OperatorTok{.}\NormalTok{Cmd}\OperatorTok{(}\StringTok{"?E Hello World"}\OperatorTok{)}
  \KeywordTok{if}\NormalTok{ err }\OperatorTok{!=} \OtherTok{nil} \OperatorTok{\{}
    \BuiltInTok{panic}\OperatorTok{(}\NormalTok{err}\OperatorTok{)}
  \OperatorTok{\}}
\NormalTok{  fmt}\OperatorTok{.}\NormalTok{Println}\OperatorTok{(}\NormalTok{buf1}\OperatorTok{)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{rust}{%
\subsection{Rust}\label{rust}}

\begin{verbatim}
$ cat Cargo.toml
...
[dependencies]
r2pipe = "*"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{\#[}\NormalTok{macro\_use}\AttributeTok{]}
\KeywordTok{extern} \KeywordTok{crate}\NormalTok{ r2pipe}\OperatorTok{;}
\KeywordTok{use} \PreprocessorTok{r2pipe::}\NormalTok{R2Pipe}\OperatorTok{;}
\KeywordTok{fn}\NormalTok{ main() }\OperatorTok{\{}
  \KeywordTok{let} \KeywordTok{mut}\NormalTok{ r2p }\OperatorTok{=} \PreprocessorTok{open\_pipe!}\NormalTok{(}\ConstantTok{Some}\NormalTok{(}\StringTok{"/bin/ls"}\NormalTok{))}\OperatorTok{.}\NormalTok{unwrap()}\OperatorTok{;}
  \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{:?\}"}\OperatorTok{,}\NormalTok{ r2p}\OperatorTok{.}\NormalTok{cmd(}\StringTok{"?e Hello World"}\NormalTok{))}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ json }\OperatorTok{=}\NormalTok{ r2p}\OperatorTok{.}\NormalTok{cmdj(}\StringTok{"ij"}\NormalTok{)}\OperatorTok{.}\NormalTok{unwrap()}\OperatorTok{;}
  \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\OperatorTok{,} \PreprocessorTok{serde\_json::}\NormalTok{to\_string\_pretty(}\OperatorTok{\&}\NormalTok{json)}\OperatorTok{.}\NormalTok{unwrap())}\OperatorTok{;}
  \PreprocessorTok{println!}\NormalTok{(}\StringTok{"ARCH \{\}"}\OperatorTok{,}\NormalTok{ json[}\StringTok{"bin"}\NormalTok{][}\StringTok{"arch"}\NormalTok{])}\OperatorTok{;}
\NormalTok{  r2p}\OperatorTok{.}\NormalTok{close()}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ruby}{%
\subsection{Ruby}\label{ruby}}

\begin{verbatim}
$ gem install r2pipe
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require} \VerbatimStringTok{\textquotesingle{}r2pipe\textquotesingle{}}
\FunctionTok{puts} \VerbatimStringTok{\textquotesingle{}r2pipe ruby api demo\textquotesingle{}}
\FunctionTok{puts} \VerbatimStringTok{\textquotesingle{}====================\textquotesingle{}}
\NormalTok{r2p }\KeywordTok{=} \DataTypeTok{R2Pipe}\AttributeTok{.new} \VerbatimStringTok{\textquotesingle{}/bin/ls\textquotesingle{}}
\FunctionTok{puts}\NormalTok{ r2p}\AttributeTok{.cmd} \VerbatimStringTok{\textquotesingle{}pi 5\textquotesingle{}}
\FunctionTok{puts}\NormalTok{ r2p}\AttributeTok{.cmd} \VerbatimStringTok{\textquotesingle{}pij 1\textquotesingle{}}
\FunctionTok{puts}\NormalTok{ r2p}\AttributeTok{.json}\NormalTok{(r2p}\AttributeTok{.cmd} \VerbatimStringTok{\textquotesingle{}pij 1\textquotesingle{}}\NormalTok{)}
\FunctionTok{puts}\NormalTok{ r2p}\AttributeTok{.cmd} \VerbatimStringTok{\textquotesingle{}px 64\textquotesingle{}}
\NormalTok{r2p}\AttributeTok{.quit}
\end{Highlighting}
\end{Shaded}

\hypertarget{perl}{%
\subsection{Perl}\label{perl}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{\#!/usr/bin/perl}

\FunctionTok{use} \FunctionTok{R2::Pipe}\NormalTok{;}
\FunctionTok{use} \KeywordTok{strict}\NormalTok{;}

\KeywordTok{my} \DataTypeTok{$r}\NormalTok{ = }\FunctionTok{R2::Pipe}\NormalTok{{-}\textgreater{}new (}\OtherTok{"}\StringTok{/bin/ls}\OtherTok{"}\NormalTok{);}
\FunctionTok{print} \DataTypeTok{$r}\NormalTok{{-}\textgreater{}}\DataTypeTok{cmd}\NormalTok{ (}\OtherTok{"}\StringTok{pd 5}\OtherTok{"}\NormalTok{).}\OtherTok{"}\CharTok{\textbackslash{}n}\OtherTok{"}\NormalTok{;}
\FunctionTok{print} \DataTypeTok{$r}\NormalTok{{-}\textgreater{}}\DataTypeTok{cmd}\NormalTok{ (}\OtherTok{"}\StringTok{px 64}\OtherTok{"}\NormalTok{).}\OtherTok{"}\CharTok{\textbackslash{}n}\OtherTok{"}\NormalTok{;}
\DataTypeTok{$r}\NormalTok{{-}\textgreater{}}\DataTypeTok{quit}\NormalTok{ ();}
\end{Highlighting}
\end{Shaded}

\hypertarget{erlang}{%
\subsection{Erlang}\label{erlang}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\#}\OperatorTok{!/}\CharTok{usr}\OperatorTok{/}\CharTok{bin}\OperatorTok{/}\CharTok{env} \CharTok{escript}
\CommentTok{\%\% {-}*{-} erlang {-}*{-}}
\CommentTok{\%\%! {-}smp enable}

\CommentTok{\%\% {-}sname hr}
\OperatorTok{{-}}\FunctionTok{mode(}\CharTok{compile}\FunctionTok{).}

\KeywordTok{{-}export}\FunctionTok{([}\CharTok{main}\OperatorTok{/}\DecValTok{1}\FunctionTok{]).}

\FunctionTok{main(}\VariableTok{\_Args}\FunctionTok{)} \OperatorTok{{-}\textgreater{}}
  \CommentTok{\%\% добавление r2pipe в modulepath, задайте расположение r2pipe\_erl}
  \VariableTok{R2pipePATH} \OperatorTok{=} \FunctionTok{filename:dirname(escript:script\_name())} \OperatorTok{++} \StringTok{"/ebin"}\FunctionTok{,}
  \CharTok{true} \OperatorTok{=} \FunctionTok{code:add\_pathz(}\VariableTok{R2pipePATH}\FunctionTok{),}

  \CommentTok{\%\% инициализация ссылки с помощью r2}
  \VariableTok{H} \OperatorTok{=} \FunctionTok{r2pipe:init(}\CharTok{lpipe}\FunctionTok{),}

  \CommentTok{\%\% вся работа идет здесь}
  \FunctionTok{io:format(}\StringTok{"\textasciitilde{}s"}\FunctionTok{,} \FunctionTok{[r2pipe:cmd(}\VariableTok{H}\FunctionTok{,} \StringTok{"i"}\FunctionTok{)]).}
\end{Highlighting}
\end{Shaded}

\hypertarget{haskell}{%
\subsection{Haskell}\label{haskell}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{R2pipe}
\KeywordTok{import} \KeywordTok{qualified} \DataTypeTok{Data.ByteString.Lazy} \KeywordTok{as} \DataTypeTok{L}

\NormalTok{showMainFunction ctx }\OtherTok{=} \KeywordTok{do}
\NormalTok{  cmd ctx }\StringTok{"s main"}
\NormalTok{  L.putStr }\OperatorTok{=\textless{}\textless{}}\NormalTok{ cmd ctx }\StringTok{"pD \textasciigrave{}fl $$\textasciigrave{}"}

\NormalTok{main }\OtherTok{=} \KeywordTok{do}
  \CommentTok{{-}{-} Запуск r2 локально}
\NormalTok{  открыть }\StringTok{"/bin/ls"} \OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ showMainFunction}
  \CommentTok{{-}{-} Соединение с r2 через HTTP (например, если "r2 {-}qc=h /bin/ls" запущен)}
\NormalTok{  открытие }\StringTok{"http://127.0.0.1:9090"} \OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ showMainFunction}
\end{Highlighting}
\end{Shaded}

\hypertarget{dotnet}{%
\subsection{Dotnet}\label{dotnet}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{.}\FunctionTok{Generic}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Diagnostics}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Linq}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Threading}\OperatorTok{.}\FunctionTok{Tasks}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ r2pipe}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ LocalExample }\OperatorTok{\{}
  \KeywordTok{class}\NormalTok{ Program }\OperatorTok{\{}
    \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
\KeywordTok{\#if}\NormalTok{ \_\_MonoCS\_\_}
      \KeywordTok{using}\OperatorTok{(}\NormalTok{IR2Pipe pipe }\OperatorTok{=} \KeywordTok{new} \FunctionTok{R2Pipe}\OperatorTok{(}\StringTok{"/bin/ls"}\OperatorTok{))} \OperatorTok{\{}
\KeywordTok{\#else}
      \KeywordTok{using} \OperatorTok{(}\NormalTok{IR2Pipe pipe }\OperatorTok{=} \KeywordTok{new} \FunctionTok{R2Pipe}\OperatorTok{(}\NormalTok{@}\StringTok{"C:\textbackslash{}Windows}\SpecialCharTok{\textbackslash{}n}\StringTok{otepad.exe"}\OperatorTok{,}
\NormalTok{        @}\StringTok{"C:}\SpecialCharTok{\textbackslash{}r}\StringTok{adare2}\SpecialCharTok{\textbackslash{}r}\StringTok{adare2.exe"}\OperatorTok{))} \OperatorTok{\{}
\KeywordTok{\#endif}
\NormalTok{        Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Hello r2! "} \OperatorTok{+}\NormalTok{ pipe}\OperatorTok{.}\FunctionTok{RunCommand}\OperatorTok{(}\StringTok{"?V"}\OperatorTok{));}
\NormalTok{        Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}}\NormalTok{ async }\OperatorTok{=}\NormalTok{ pipe}\OperatorTok{.}\FunctionTok{RunCommandAsync}\OperatorTok{(}\StringTok{"?V"}\OperatorTok{);}
\NormalTok{        Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Hello async r2!"} \OperatorTok{+}\NormalTok{ async}\OperatorTok{.}\FunctionTok{Result}\OperatorTok{);}
\NormalTok{        QueuedR2Pipe qr2 }\OperatorTok{=} \KeywordTok{new} \FunctionTok{QueuedR2Pipe}\OperatorTok{(}\NormalTok{pipe}\OperatorTok{);}
\NormalTok{        qr2}\OperatorTok{.}\FunctionTok{Enqueue}\OperatorTok{(}\KeywordTok{new} \FunctionTok{R2Command}\OperatorTok{(}\StringTok{"x"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{string}\NormalTok{ result}\OperatorTok{)} \OperatorTok{=\textgreater{}} \OperatorTok{\{}
\NormalTok{             Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Result of x:}\SpecialCharTok{\textbackslash{}n}\StringTok{ \{0\}"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);} \OperatorTok{\}));}
\NormalTok{        qr2}\OperatorTok{.}\FunctionTok{Enqueue}\OperatorTok{(}\KeywordTok{new} \FunctionTok{R2Command}\OperatorTok{(}\StringTok{"pi 10"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{string}\NormalTok{ result}\OperatorTok{)} \OperatorTok{=\textgreater{}} \OperatorTok{\{}
\NormalTok{             Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Result of pi 10:}\SpecialCharTok{\textbackslash{}n}\StringTok{ \{0\}"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);} \OperatorTok{\}));}
\NormalTok{        qr2}\OperatorTok{.}\FunctionTok{ExecuteCommands}\OperatorTok{();}
      \OperatorTok{\}}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{java}{%
\subsection{Java}\label{java}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \ImportTok{org}\OperatorTok{.}\ImportTok{radare}\OperatorTok{.}\ImportTok{r2pipe}\OperatorTok{.}\ImportTok{R2Pipe}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ Test }\OperatorTok{\{}
  \KeywordTok{public} \DataTypeTok{static} \DataTypeTok{void} \FunctionTok{main} \OperatorTok{(}\BuiltInTok{String}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{try} \OperatorTok{\{}
\NormalTok{      R2Pipe r2p }\OperatorTok{=} \KeywordTok{new} \FunctionTok{R2Pipe} \OperatorTok{(}\StringTok{"/bin/ls"}\OperatorTok{);}
      \CommentTok{// new R2Pipe ("http://cloud.rada.re/cmd/", true);}
      \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println} \OperatorTok{(}\NormalTok{r2p}\OperatorTok{.}\FunctionTok{cmd} \OperatorTok{(}\StringTok{"pd 10"}\OperatorTok{));}
      \BuiltInTok{System}\OperatorTok{.}\FunctionTok{out}\OperatorTok{.}\FunctionTok{println} \OperatorTok{(}\NormalTok{r2p}\OperatorTok{.}\FunctionTok{cmd} \OperatorTok{(}\StringTok{"px 32"}\OperatorTok{));}
\NormalTok{      r2p}\OperatorTok{.}\FunctionTok{quit}\OperatorTok{();}
    \OperatorTok{\}} \ControlFlowTok{catch} \OperatorTok{(}\BuiltInTok{Exception}\NormalTok{ e}\OperatorTok{)} \OperatorTok{\{}
      \BuiltInTok{System}\OperatorTok{.}\FunctionTok{err}\OperatorTok{.}\FunctionTok{println} \OperatorTok{(}\NormalTok{e}\OperatorTok{);}
    \OperatorTok{\}}
  \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{swift}{%
\subsection{Swift}\label{swift}}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \KeywordTok{let} \VariableTok{r2p} \OperatorTok{=}\NormalTok{ R2Pipe}\OperatorTok{(}\NormalTok{url}\OperatorTok{:}\KeywordTok{nil}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{  r2p}\OperatorTok{.}\NormalTok{cmd }\OperatorTok{(}\StringTok{"?V"}\OperatorTok{,}\NormalTok{ closure}\OperatorTok{:\{}
    \OperatorTok{(}\NormalTok{str}\OperatorTok{:}\NormalTok{String}\OperatorTok{?)} \ControlFlowTok{in}
    \ControlFlowTok{if} \KeywordTok{let} \VariableTok{s} \OperatorTok{=}\NormalTok{ str }\OperatorTok{\{}
\NormalTok{      print }\OperatorTok{(}\StringTok{"Version: }\ErrorTok{\textbackslash{}(}\StringTok{s)"}\OperatorTok{);}
\NormalTok{      exit }\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{      debugPrint }\OperatorTok{(}\StringTok{"R2PIPE. Error"}\OperatorTok{);}
\NormalTok{      exit }\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
  \OperatorTok{\});}
\NormalTok{  NSRunLoop}\OperatorTok{.}\NormalTok{currentRunLoop}\OperatorTok{().}\NormalTok{run}\OperatorTok{();}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{  print }\OperatorTok{(}\StringTok{"Needs to run from r2"}\OperatorTok{)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{vaal}{%
\subsection{Vaal}\label{vaal}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{public static int main (string[] args) \{}
\NormalTok{  MainLoop loop = new MainLoop ();}
\NormalTok{  var r2p = new R2Pipe ("/bin/ls");}
\NormalTok{  r2p.cmd ("pi 4", (x) =\textgreater{} \{}
\NormalTok{    stdout.printf ("Disassembly:\textbackslash{}n\%s\textbackslash{}n", x);}
\NormalTok{    r2p.cmd ("ie", (x) =\textgreater{} \{}
\NormalTok{      stdout.printf ("Entrypoint:\textbackslash{}n\%s\textbackslash{}n", x);}
\NormalTok{      r2p.cmd ("q");}
\NormalTok{    \});}
\NormalTok{  \});}
\NormalTok{  ChildWatch.add (r2p.child\_pid, (pid, status) =\textgreater{} \{}
\NormalTok{    Process.close\_pid (pid);}
\NormalTok{    loop.quit ();}
\NormalTok{  \});}
\NormalTok{  loop.run ();}
\NormalTok{  return 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{newlisp}{%
\subsection{NewLisp}\label{newlisp}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{load} \StringTok{"r2pipe.lsp"}\NormalTok{)}
\NormalTok{(println }\StringTok{"pd 3:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{ (r2pipe:cmd }\StringTok{"pd 3"}\NormalTok{))}
\NormalTok{(exit)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dlang}{%
\subsection{Dlang}\label{dlang}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{import}\ImportTok{ std.stdio}\OperatorTok{;}
\PreprocessorTok{import}\ImportTok{ r2pipe}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
   \FunctionTok{auto}\NormalTok{ r2 }\OperatorTok{=}\NormalTok{ r2pipe.open }\OperatorTok{();}
\NormalTok{   writeln }\OperatorTok{(}\StringTok{"Hello "}\OperatorTok{\textasciitilde{}}\NormalTok{ r2.cmd}\OperatorTok{(}\StringTok{"?e World"}\OperatorTok{));}
\NormalTok{   writeln }\OperatorTok{(}\StringTok{"Hello "}\OperatorTok{\textasciitilde{}}\NormalTok{ r2.cmd}\OperatorTok{(}\StringTok{"?e Works"}\OperatorTok{));}

   \BuiltInTok{string}\NormalTok{ uri }\OperatorTok{=}\NormalTok{ r2.cmdj}\OperatorTok{(}\StringTok{"ij"}\OperatorTok{)[}\StringTok{"core"}\OperatorTok{][}\StringTok{"uri"}\OperatorTok{]}\NormalTok{.str}\OperatorTok{;}
\NormalTok{   writeln }\OperatorTok{(}\StringTok{"Uri: "}\OperatorTok{,}\NormalTok{uri}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux43eux442ux43bux430ux434ux447ux438ux43a}{%
\section{Отладчик}\label{ux43eux442ux43bux430ux434ux447ux438ux43a}}

Отладчики реализуются при помощи плагинов ввода-вывода. Поэтому radare2
может обрабатывать различные типы URI, порождая, присоединяясь и
управляя процессами. Полный список плагинов доступен при использовании
флага \texttt{r2\ -L} при запуске. Плагины с буквой ``d'' в первом
столбце (``rwd'') таблицы поддерживают отладку. Например:

\begin{verbatim}
r_d  debug       Отладить программу или процесс по pid. dbg:///bin/ls, dbg://1388 (LGPL3)
rwd  gdb         Подсоединиться к серверу gdb, 'qemu -s', gdb://localhost:1234 (LGPL3)
\end{verbatim}

Существуют разные бэкенды для многих целевых архитектур и операционных
систем, например, GNU/Linux, Windows, MacOS X, (Net, Free, Open)BSD и
Solaris.

Память процесса обрабатывается как обычный файл. Все отображаемые
страницы памяти отлаживаемой программы и ее библиотек читаются и
интерпретируются как код или структуры данных.

Связь между radare и уровнем ввода-вывода отладчика обрамлена в вызовы
\texttt{system()}, принимающий строку в качестве аргумента и выполняющий
ее как команду. Затем ответ буферизуется в консоли вывода, его
содержимое может быть дополнительно обработано скриптом. Доступ к
системе ввода-вывода осуществляется с помощью \texttt{=!}. Большинство
подключаемых модулей ввода-вывода снабжены инструкциями, доступными при
помощи \texttt{=!?} и \texttt{=!help}. Например:

\begin{verbatim}
$ r2 -d /bin/ls
...
[0x7fc15afa3cc0]> =!help
Usage: =!cmd args
 =!ptrace   - использовать ptrace io
 =!mem      - использовать /proc/pid/mem io, если возможно
 =!pid      - показать pid
 =!pid <#>  - выбрать новый pid
\end{verbatim}

Как правило, команды отладчика переносимы между архитектурами и
операционными системами. Radare пытается поддерживать одну и ту же
функциональность для всех целевых архитектур и операционных систем, но
некоторые вещи приходится решать отдельно. Они включают внедрение
шелл-кодов и обработку исключений. Например, в архитектурах MIPS нет
аппаратной поддержки пошагового запуска инструкций. В этом случае
radare2 предоставляет собственную реализацию пошагового выполнения,
используя сочетание анализа кода и программных точек останова.

Базовая справка по отладчику доступна по команде `d?':

\begin{verbatim}
Usage: d   # Команды отладчика
| db[?]                    Управление точками останова
| dbt[?]                   Показать трассировку стека, учитывая значения в dbg.btdepth и dbg.btalgo
| dc[?]                    Продолжить выполнение (c)
| dd[?]                    Файловые дескрипторы (!fd в r1)
| de[-sc] [perm] [rm] [e]  Отладить при помощи ESIL (смотрите de?)
| dg <file>                Сгенерировать core-файл (WIP)
| dH [handler]             Трансплантировать процесс на новый обработчик
| di[?]                    Показать информацию о механизме отладчика (смотрите dh)
| dk[?]                    Перечислить, отправить, получить, задать обработчик сигнала у дочернего процесса
| dL[?]                    Перечислить или установить обработчик отладчика
| dm[?]                    Показать карты памяти
| do[?]                    Открыть процесс (перезагрузить, псевдоним для 'oo')
| doo[args]                Открыть в режиме отладки с аргументами (псевдоним для 'ood')
| doof[file]               Открыть в режиме отладки из файла (псевдоним для 'oodf')
| doc                      Закрыть сессию отладки
| dp[?]                    Перечислить, присоединиться к процессу или нити по идентификатору
| dr[?]                    Регистры процессора
| ds[?]                    Сделать шаг отладки (step, step over), исходный код
| dt[?]                    Показать трассировку инструкций
| dw <pid>                 Блокировать командную строку, пока процесс не завершился
| dx[?]                    Добавить и запустить код в процесс (смотрите gs)
\end{verbatim}

Чтобы перезапустить сеанс отладки, можно ввести \texttt{oo} или
\texttt{оо+} в зависимости от задачи.

\begin{verbatim}
oo                 заново открыть текущий файл (kill+fork в отладчике)
oo+                заново открыть текущий файл в режиме перезаписи
\end{verbatim}

\hypertarget{ux43dux430ux447ux430ux43bux43e-ux440ux430ux431ux43eux442ux44b}{%
\section{Начало
работы}\label{ux43dux430ux447ux430ux43bux43e-ux440ux430ux431ux43eux442ux44b}}

\hypertarget{ux43dux435ux431ux43eux43bux44cux448ux430ux44f-ux441ux435ux441ux441ux438ux44f-ux432-ux43eux442ux43bux430ux434ux447ux438ux43aux435-radeone2}{%
\subsection{Небольшая сессия в отладчике
Radeone2}\label{ux43dux435ux431ux43eux43bux44cux448ux430ux44f-ux441ux435ux441ux441ux438ux44f-ux432-ux43eux442ux43bux430ux434ux447ux438ux43aux435-radeone2}}

\begin{itemize}
\item
  \texttt{r2\ -d\ /bin/ls}: открывает radare2 с файлом \texttt{/bin/ls}
  в режиме отладчика, используя встроенный отладчик, при этом программа
  сразу останавливается; запустится командная строка radare2;
\item
  \texttt{db\ flag}: установить точку останова на флаг, где флаг - это
  либо адрес, либо имя функции;
\item
  \texttt{db\ -\ flag}: удалить точку останова на флаге, где флаг - это
  либо адрес, либо имя функции;
\item
  \texttt{db}: показать список точек останова;
\item
  \texttt{dc}: запуск программы;
\item
  \texttt{dr}: показать состояние регистров;
\item
  \texttt{drr}: показать ссылки из регистров (telescoping) (как peda);
\item
  \texttt{ds}: выполнить инструкцию, войдя в нее, если можно (step
  into);
\item
  \texttt{dso}: выполнить инструкцию без входа внутрь (step over);
\item
  \texttt{dbt}: показать трассировку стека;
\item
  \texttt{dm}: показать карты памяти;
\item
  \texttt{dk\ \textless{}signal\textgreater{}}: отправить сигнал KILL
  дочернему процессу;
\item
  \texttt{ood}: переоткрыть в режиме отладки;
\item
  \texttt{ood\ arg1\ arg2}: переоткрыть в режиме отладки с параметрами
  arg1 и arg2.
\end{itemize}

\hypertarget{ux43fux435ux440ux435ux445ux43eux434-ux441-ida-gdb-ux438-windbg}{%
\section{Переход с IDA, GDB и
WinDBG}\label{ux43fux435ux440ux435ux445ux43eux434-ux441-ida-gdb-ux438-windbg}}

\hypertarget{ux43aux430ux43a-ux437ux430ux43fux443ux441ux442ux438ux442ux44c-ux43fux440ux43eux433ux440ux430ux43cux43cux443-ux441-ux43fux43eux43cux43eux449ux44cux44e-ux43eux442ux43bux430ux434ux447ux438ux43aux430}{%
\subsection{Как запустить программу с помощью
отладчика}\label{ux43aux430ux43a-ux437ux430ux43fux443ux441ux442ux438ux442ux44c-ux43fux440ux43eux433ux440ux430ux43cux43cux443-ux441-ux43fux43eux43cux43eux449ux44cux44e-ux43eux442ux43bux430ux434ux447ux438ux43aux430}}

\hypertarget{section}{%
\subsection{}\label{section}}

\texttt{r2\ -d\ /bin/ls} - запуск в режиме отладки =\textgreater{}
{[}\href{http://asciinema.org/a/12022}{видео}{]}.

\hypertarget{ux43aux430ux43a-ux43fux440ux438ux441ux43eux435ux434ux438ux43dux438ux442ux44cux441ux44fux43eux442ux441ux43eux435ux434ux438ux43dux438ux442ux44cux441ux44f-ux43eux442-ux438ux441ux43fux43eux43bux43dux44fux44eux449ux435ux433ux43eux441ux44f-ux43fux440ux43eux446ux435ux441ux441ux430-gdb--p}{%
\subsection{Как присоединиться/отсоединиться от исполняющегося процесса?
(gdb
-p)}\label{ux43aux430ux43a-ux43fux440ux438ux441ux43eux435ux434ux438ux43dux438ux442ux44cux441ux44fux43eux442ux441ux43eux435ux434ux438ux43dux438ux442ux44cux441ux44f-ux43eux442-ux438ux441ux43fux43eux43bux43dux44fux44eux449ux435ux433ux43eux441ux44f-ux43fux440ux43eux446ux435ux441ux441ux430-gdb--p}}

\hypertarget{section-1}{%
\subsection{}\label{section-1}}

\texttt{r2\ -d\ \textless{}pid\textgreater{}} - присоединившихся к
процессу,

\texttt{r2\ ptrace://pid} - подсоединиться к процессу, но только для io
(не используется бэкенд отладчика),

\texttt{{[}0x7fff6ad90028{]}\textgreater{}\ o-225} - закрыть fd=225
(перечень из \texttt{o\textasciitilde{}{[}1{]}:0}),

\texttt{r2\ -D\ gdb\ gdb://localhost:1234} - подключиться к серверу gdb.

\hypertarget{ux43aux430ux43a-ux443ux441ux442ux430ux43dux43eux432ux438ux442ux44c-ux430ux440ux433ux443ux43cux435ux43dux442ux44bux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-ux441ux440ux435ux434ux44bux437ux430ux433ux440ux443ux437ux438ux442ux44c-ux434ux438ux43dux430ux43cux438ux447ux435ux441ux43aux443ux44e-ux431ux438ux431ux43bux438ux43eux442ux435ux43aux443-ux432-ux441ux435ux430ux43dux441ux435-ux43eux442ux43bux430ux434ux43aux438-radare}{%
\subsection{Как установить аргументы/переменные среды/загрузить
динамическую библиотеку в сеансе отладки
radare}\label{ux43aux430ux43a-ux443ux441ux442ux430ux43dux43eux432ux438ux442ux44c-ux430ux440ux433ux443ux43cux435ux43dux442ux44bux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-ux441ux440ux435ux434ux44bux437ux430ux433ux440ux443ux437ux438ux442ux44c-ux434ux438ux43dux430ux43cux438ux447ux435ux441ux43aux443ux44e-ux431ux438ux431ux43bux438ux43eux442ux435ux43aux443-ux432-ux441ux435ux430ux43dux441ux435-ux43eux442ux43bux430ux434ux43aux438-radare}}

Используйте \texttt{rarun2} (\texttt{libpath=\$PWD:/tmp/lib},
\texttt{arg2=hello}, \texttt{setenv=FOO=BAR} \ldots), инструкции -
\texttt{rarun2\ -h} / \texttt{man\ rarun2}.

\hypertarget{ux43aux430ux43a-ux437ux430ux43fux443ux441ux43aux430ux442ux44c-ux441ux43aux440ux438ux43fux442ux44b-ux432-radare2}{%
\subsection{Как запускать скрипты в radare2
?}\label{ux43aux430ux43a-ux437ux430ux43fux443ux441ux43aux430ux442ux44c-ux441ux43aux440ux438ux43fux442ux44b-ux432-radare2}}

\texttt{r2\ -i\ \textless{}scriptfile\textgreater{}\ ...} - запуск
скрипта \textbf{после} загрузки файла =\textgreater{}
{[}\href{http://asciinema.org/a/12020}{video}{]},

\texttt{r2\ -I\ \textless{}scriptfile\textgreater{}\ ...} - запуск
скрипта \textbf{до} загрузки файла,

\texttt{r2\ -c\ \$@\ \textbar{}\ awk\ \$@} - пропустить через awk для
получения asm-кода функции =\textgreater{}
{[}\href{http://sprunge.us/dEOK}{link}{]},

\texttt{{[}0x80480423{]}\textgreater{}\ .\ scriptfile} -
интерпретировать файл =\textgreater{}
{[}\href{http://asciinema.org/a/12017}{video}{]},

\texttt{{[}0x80480423{]}\textgreater{}\ \#!c} - вход в C-шный repl (см.
\texttt{\#!} перечень доступных плагинов RLang) =\textgreater{}
{[}\href{http://asciinema.org/a/12019}{video}{]}, все должно быть
сделано в одной строке, можно передать файл.c в качестве аргумента.

Если нужен \texttt{\#!python} и другие варианты, просто соберите модуль
\href{https://github.com/radareorg/radare2-bindings}{radare2-bindings}.

\hypertarget{ux43aux430ux43a-ux43fux43eux43aux430ux437ux430ux442ux44c-ux438ux441ux445ux43eux434ux43dux44bux439-ux43aux43eux434-ux43fux43eux434ux43eux431ux43dux43e-gdb}{%
\subsection{Как показать исходный код подобно
gdb?}\label{ux43aux430ux43a-ux43fux43eux43aux430ux437ux430ux442ux44c-ux438ux441ux445ux43eux434ux43dux44bux439-ux43aux43eux434-ux43fux43eux434ux43eux431ux43dux43e-gdb}}

\texttt{CL\ @\ sym.main} - данная функция еще недостаточно
стабилизирована.

\hypertarget{ux441ux43eux447ux435ux442ux430ux43dux438ux44f-ux43aux43bux430ux432ux438ux448}{%
\section{сочетания
клавиш}\label{ux441ux43eux447ux435ux442ux430ux43dux438ux44f-ux43aux43bux430ux432ux438ux448}}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.2286}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.2571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.0714}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.0714}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Команда
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
IDA Pro
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Программа radare2
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
r2 (визуальный режим)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
GDB
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
WinDbg
\end{minipage} \\
\midrule
\endhead
\textbf{Анализ} & & & & & \\
Анализ всех данных и кода & Автоматически запускается при открытии
бинарника & \texttt{aaa} или \texttt{-A} (\texttt{aaaa} или \texttt{-AA}
для запуска новых экспериментальных видов анализа) & отсутствует &
отсутствует & отсутствует \\
\textbf{Управление интерфейсом} & & & & & \\
переход по внешней ссылке & \texttt{x} & \texttt{axt} & \texttt{x} &
отсутствует & отсутствует \\
переход с внешней ссылки & \texttt{ctrl\ +\ j} & \texttt{axf} &
\texttt{X} & отсутствует & отсутствует \\
xref в граф & ? & \texttt{agt\ {[}offset{]}} & ? & отсутствует &
отсутствует \\
xref из графа & ? & \texttt{agf\ {[}offset{]}} & ? & отсутствует &
отсутствует \\
список функций & \texttt{alt\ +\ 1} & \texttt{afl;is} & \texttt{t} &
отсутствует & отсутствует \\
Листинг & \texttt{alt\ +\ 2} & \texttt{pdf} & \texttt{p} & отсутствует &
отсутствует \\
режим hex & \texttt{alt\ +\ 3} & \texttt{pxa} & \texttt{P} & отсутствует
& отсутствует \\
импорты & \texttt{alt\ +\ 6} & \texttt{ii} & \texttt{:ii} & отсутствует
& отсутствует \\
экспорты & \texttt{alt\ +\ 7} & \texttt{is\textasciitilde{}FUNC} & ? &
отсутствует & отсутствует \\
переход по jmp/call & \texttt{enter} & \texttt{s\ offset} &
\texttt{enter} или \texttt{0}-\texttt{9} & отсутствует & отсутствует \\
отмена seek & \texttt{esc} & \texttt{s-} & \texttt{u} & отсутствует &
отсутствует \\
вернуть прежний seek & \texttt{ctrl+enter} & \texttt{s+} & \texttt{U} &
отсутствует & отсутствует \\
показать граф управления & \texttt{space} & \texttt{agv} & \texttt{V} &
отсутствует & отсутствует \\
\textbf{Правка} & & & & & \\
переименование & \texttt{n} & \texttt{afn} & \texttt{dr} & отсутствует &
отсутствует \\
режим графа управления & \texttt{space} & \texttt{agv} & \texttt{V} &
отсутствует & отсутствует \\
определить как блок данных & \texttt{d} & \texttt{Cd\ {[}size{]}} &
\texttt{dd},\texttt{db},\texttt{dw},\texttt{dW} & отсутствует &
отсутствует \\
определить как блок кода & \texttt{c} & \texttt{C-\ {[}size{]}} &
\texttt{d-} or \texttt{du} & отсутствует & отсутствует \\
определить как неопределеный блок & \texttt{u} & \texttt{C-\ {[}size{]}}
& \texttt{d-} or \texttt{du} & отсутствует & отсутствует \\
определить как строку & \texttt{A} & \texttt{Cs\ {[}размер{]}} &
\texttt{ds} & отсутствует & отсутствует \\
определить как структуру & \texttt{Alt+Q} & \texttt{Cf\ {[}размер{]}} &
\texttt{dF} & отсутствует & отсутствует \\
\textbf{Отладчик} & & & & & \\
начать / продолжить процесс & \texttt{F9} & \texttt{dc} & \texttt{F9} &
\texttt{r} и \texttt{c} & \texttt{g} \\
завершить процесс & \texttt{Ctrl+F2} & \texttt{dk\ 9} & ? &
\texttt{kill} & \texttt{q} \\
отсоединится & \texttt{?} & \texttt{o-} & ? & \texttt{detach} & \\
step into & \texttt{F7} & \texttt{ds} & \texttt{s} & \texttt{n} &
\texttt{t} \\
step into 4 инструкции & ? & \texttt{ds\ 4} & F7 & \texttt{n\ 4} &
\texttt{t\ 4} \\
step over & \texttt{F8} & \texttt{dso} & \texttt{S} & \texttt{s} &
\texttt{p} \\
step until указанный адрес & ? &
\texttt{dsu\ \textless{}addr\textgreater{}} & ? & \texttt{s} &
\texttt{g\ \textless{}addr\textgreater{}} \\
исполнять до оператора return & \texttt{Ctrl+F7} & \texttt{dcr} & ? &
\texttt{finish} & \texttt{gu} \\
выполнять до курсора & \texttt{F4} &
\href{https://github.com/radareorg/radare2/issues/249}{\#249} &
\href{https://github.com/radareorg/radare2/issues/249}{\#249} &
отсутствует & отсутствует \\
показать стек & \texttt{?} & \texttt{dbt} & ? & \texttt{bt} & \\
показать регистр & в окне регистров & \texttt{dr\ all} & автоматом в
визуальном режиме & \texttt{info\ registers} & \texttt{r} \\
распечатать eax & в окне регистров & \texttt{dr?eax} & автоматом в
визуальном режиме & \texttt{info\ registers\ eax} & \texttt{r\ rax} \\
показать старое состояние всех регистров & ? & \texttt{dro} & ? & ? &
? \\
показать что по function addr + N & ? & \texttt{afi\ \$\$} - показать
информацию о функции в текущем смещении (\texttt{\$\$}) & ? & ? & ? \\
отображать состояние кадра & ? & \texttt{pxw\ rbp-rsp@rsp} & ? &
\texttt{i\ f} & ? \\
исполнять до тех пор, пока условие не станет истинным & ? & \texttt{dsi}
& ? & ? & ? \\
присвоить значение регистру & ? & \texttt{dr\ rip=0x456} & ? &
\texttt{set\ \$rip=0x456} & \texttt{r\ rip=456} \\
\textbf{Дизассемблирование} & & & & & \\
дизассемблирование далее & отсутствует & \texttt{pd} & \texttt{Vp} &
\texttt{disas} & \texttt{uf}, \texttt{u} \\
дизассемблировать N инструкций & отсутствует & \texttt{pd\ X} & Vp & x/i
& \texttt{u\ \textless{}addr\textgreater{}\ LX} \\
дизассемблировать N в обратном направлении & отсутствует &
\texttt{pd\ -X} & \texttt{Vp} &
\texttt{disas\ \textless{}a-o\textgreater{}\ \textless{}a\textgreater{}}
& \texttt{ub} \\
\textbf{Информация о секциях} & & & & & \\
секции/регионы & Menu sections & \texttt{iS} или \texttt{S} (добавить j
для json) & отсутствует & maint info sections & !address \\
\textbf{Загрузка файла символов} & & & & & \\
секции/регионы & \texttt{pdb\ menu} & \texttt{asm.dwarf.file},
\texttt{pdb.XX}) & отсутствует & add-symbol-file & r \\
\textbf{Стек} & & & & & \\
стек & отсутствует & \texttt{dbt} & отсутствует & \texttt{bt} &
\texttt{k} \\
стек в Json & отсутствует & \texttt{dbtj} & отсутствует & & \\
частичное отображение стека (внутренняя часть) & отсутствует &
\texttt{dbt} (\texttt{dbg.btdepth} \texttt{dbg.btalgo}) & отсутствует &
bt & k  \\
частичное отображение стека (внешняя часть) & отсутствует & \texttt{dbt}
(\texttt{dbg.btdepth} \texttt{dbg.btalgo}) & отсутствует & bt - & \\
стеки всех нитей & отсутствует & \texttt{dbt@t} & отсутствует &
\texttt{thread\ apply\ all\ bt} & \texttt{\textasciitilde{}*\ k} \\
\textbf{Точки останова} & & & & & \\
список точек останова & \texttt{Ctrl+Alt+B} & \texttt{db} & ? &
\texttt{info\ breakpoints} & \texttt{bl} \\
добавление точки останова & \texttt{F2} & \texttt{db\ {[}offset{]}} &
\texttt{F2} & \texttt{break} & \texttt{bp} \\
\textbf{Нити} & & & & & \\
Переключится в нить & Thread menu & \texttt{dp} & отсутствует &
\texttt{thread\ \textless{}N\textgreater{}} &
\texttt{\textasciitilde{}\textless{}N\textgreater{}s} \\
\textbf{Фремы стека} & & & & & \\
номера фреймов & отсутствует & \texttt{?} & отсутствует &
\texttt{any\ bt\ command} & \texttt{kn} \\
выбор фрейма & отсутствует & \texttt{?} & отсутствует & \texttt{frame} &
\texttt{.frame} \\
\textbf{Формальные/Локальные переменные} & & & & & \\
отображение формальных параметров & отсутствует & \texttt{afv} &
отсутствует & \texttt{info\ args} & \texttt{dv\ /t\ /i\ /V} \\
отображение локальных параметров & отсутствует & \texttt{afv} &
отсутствует & \texttt{info\ locals} & \texttt{dv\ /t\ /i\ /V} \\
сохранить параметры/локальные объекты в json & отсутствует &
\texttt{afvj} & отсутствует & \texttt{info\ locals} &
\texttt{dv\ /t\ /i\ /V} \\
список адресов, где есть доступ к переменным (R/W) & отсутствует &
\texttt{afvR/afvW} & отсутствует & \texttt{?} & \texttt{?} \\
\textbf{Поддержание проекта} & & & & & \\
открыть проект & & \texttt{Po\ {[}file{]}} & & ? & \\
сохранить проект & automatic & \texttt{Ps\ {[}file{]}} & & ? & \\
информация о проекте & & \texttt{Pi\ {[}file{]}} & & ? & \\
\textbf{Разное} & & & & & \\
Дамп массива в виде символов & отсутствует & \texttt{pc?} (json, C,
char, etc.) & Vpppp & x/bc & db \\
настройки & option menu & \texttt{e?} & \texttt{e} & & \\
поиск & search menu & \texttt{/?} & выбор зоны курсором \texttt{c} затем
\texttt{/} & & \texttt{s} \\
\bottomrule
\end{longtable}

\hypertarget{ux44dux43aux432ux438ux432ux430ux43bux435ux43dux442-ux43aux43eux43cux430ux43dux434ux44b-gdb-set-follow-fork-mode}{%
\subsection{Эквивалент команды gdb
``set-follow-fork-mode''}\label{ux44dux43aux432ux438ux432ux430ux43bux435ux43dux442-ux43aux43eux43cux430ux43dux434ux44b-gdb-set-follow-fork-mode}}

Делается с помощью двух команд:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{dcf} - пока не произойдет форк,
\item
  затем используйте \texttt{dp} - выбор процесса для отладки.
\end{enumerate}

\hypertarget{ux43eux431ux449ux438ux435-ux444ux443ux43dux43aux446ux438ux438}{%
\section{Общие
функции}\label{ux43eux431ux449ux438ux435-ux444ux443ux43dux43aux446ux438ux438}}

\begin{itemize}
\tightlist
\item
  r2 принимает подписи FLIRT,
\item
  r2 подключается к GDB, LLVM и WinDbg,
\item
  r2 может писать/исправлять загруженный файл,
\item
  в r2 встроены fortune {[}s{]}, пасхальные {[}/s{]} и стальные яйца,
\item
  r2 выполняет загрузку слепков (core dump) файлов ELF и MDMP (минидампы
  Windows).
\end{itemize}

\hypertarget{ux440ux435ux433ux438ux441ux442ux440ux44b}{%
\section{Регистры}\label{ux440ux435ux433ux438ux441ux442ux440ux44b}}

Регистры являются частью среды пользователя, они хранятся в одной из
структур среды (контексте), используемой планировщиком. Эту структуру
можно изменять для получения и установки значений регистров, и,
например, на хостах Intel можно напрямую манипулировать даже аппаратными
регистрами DR0-DR7 для установки аппаратных точек останова.

Есть разные команды для получения значений регистров. Для регистров
общего назначения используют

\begin{verbatim}
[0x4A13B8C0]> dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f20bf5df630
rsp = 0x7fff515923c0

[0x7f0f2dbae630]> dr rip ; get value of 'rip'
0x7f0f2dbae630

[0x4A13B8C0]> dr rip = esp   ; set 'rip' as esp
\end{verbatim}

Взаимодействие между плагином и ядром осуществляется командами,
возвращающими инструкции radare. Это используется, например, для
установки флагов в ядре и значений регистров.

\begin{verbatim}
[0x7f0f2dbae630]> dr*      ; Добавление '*' покажет команды radare
f r15 1 0x0
f r14 1 0x0
f r13 1 0x0
f r12 1 0x0
f rbp 1 0x0
f rbx 1 0x0
f r11 1 0x0
f r10 1 0x0
f r9 1 0x0
f r8 1 0x0
f rax 1 0x0
f rcx 1 0x0
f rdx 1 0x0
f rsi 1 0x0
f rdi 1 0x0
f oeax 1 0x3b
f rip 1 0x7fff73557940
f rflags 1 0x200
f rsp 1 0x7fff73557940

[0x4A13B8C0]> .dr*  ; include common register values in flags
\end{verbatim}

Старая копия регистров сохраняется на все время отладки, она позволяет
отслеживать изменения, сделанные во время выполнения анализируемой
программы. Доступ к копии можно получить с помощью \texttt{oregs}.

\begin{verbatim}
[0x7f1fab84c630]> dro
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x00000000
oeax = 0x0000003b
rip = 0x7f1fab84c630
rflags = 0x00000200
rsp = 0x7fff386b5080
\end{verbatim}

Текущее состояние регистров

\begin{verbatim}
[0x7f1fab84c630]> dr
r15 = 0x00000000
r14 = 0x00000000
r13 = 0x00000000
r12 = 0x00000000
rbp = 0x00000000
rbx = 0x00000000
r11 = 0x00000000
r10 = 0x00000000
r9 = 0x00000000
r8 = 0x00000000
rax = 0x00000000
rcx = 0x00000000
rdx = 0x00000000
rsi = 0x00000000
rdi = 0x7fff386b5080
oeax = 0xffffffffffffffff
rip = 0x7f1fab84c633
rflags = 0x00000202
rsp = 0x7fff386b5080
\end{verbatim}

Значения, хранящиеся в eax, oeax и eip, изменились.

Если надо сохранять и восстанавливать значения регистров, сбрасывайте их
дамп командой 'dr*' на диск, а затем можно снова проинтерпретировать
его:

\begin{verbatim}
[0x4A13B8C0]> dr* > regs.saved ; сохранить регистры
[0x4A13B8C0]> drp regs.saved ; восстановить их
\end{verbatim}

Аналогичным образом меняются EFLAGS. Например, установка выбранных
флагов:

\begin{verbatim}
[0x4A13B8C0]> dr eflags = pst
[0x4A13B8C0]> dr eflags = azsti
\end{verbatim}

Получение информации об изменении регистров - команда \texttt{drd} (diff
registers):

\begin{verbatim}
[0x4A13B8C0]> drd
oeax = 0x0000003b was 0x00000000 delta 59
rip = 0x7f00e71282d0 was 0x00000000 delta -418217264
rflags = 0x00000200 was 0x00000000 delta 512
rsp = 0x7fffe85a09c0 was 0x00000000 delta -396752448
\end{verbatim}

\hypertarget{ux43aux430ux440ux442ux44b-ux43fux430ux43cux44fux442ux438}{%
\section{Карты
памяти}\label{ux43aux430ux440ux442ux44b-ux43fux430ux43cux44fux442ux438}}

Понимание и манипулирование картами памяти отлаживаемой программы важна
для многих задач реверс-инжениринга. Radare2 предлагает богатый набор
команд просмотра и изменения карт памяти в двоичном файле. Он включает в
себя перечисление карт памяти отлаживаемого двоичного файла, удаление
карт памяти, обработку загруженных библиотек и многое другое.

Посмотрим на инструкцию команды \texttt{dm}, отвечающей за просмотр и
изменение карт памяти:

\begin{verbatim}
[0x55f2104cf620]> dm?
Usage: dm   # Команды управления картами памяти
| dm                               Перечислить карты памяти процесса
| dm address size                  Выделить <size> байт по <address>-у (где угодно, если адрес = -1) в дочернем процессе
| dm=                              Перечислить карты памяти процесса в виде  ascii-art
| dm.                              Показать название карты, содержащей текущий адрес
| dm*                              Перечислить карты памятив в ыормате команд  radare
| dm- address                      Освободить карту памяти по <address>-у
| dmd[a] [file]                    Сделать дамп текущего (всех) регионов отладочной карты в файл (from-to.dmp) (смотрите Sd)
| dmh[?]                           Показать карту кучи (heap)
| dmi [addr|libname] [symname]     Перечислить символы ы библиотеке
| dmi* [addr|libname] [symname]    Перечислить символы ы библиотеке в формате команд radare
| dmi.                             Список ближайших к текущему адресу символов
| dmiv                             Показать адреса заданного сивола указанной библиотеки
| dmj                              Перечислить карты памяти в формате JSON
| dml <file>                       Загрузить содержимое файла в текущий регион карты памяти
| dmm[?][j*]                       Перечислить модули (библиотеки, двоичные файлы в памяти)
| dmp[?] <address> <size> <perms>  Изменить страницу по <address>-у: изменить <size>, защиту <perms>
| dms[?] <id> <mapaddr>            Сделать снимок памяти
| dms- <id> <mapaddr>              Восстановить из снимка памяти
| dmS [addr|libname] [sectname]    Перечислить секции заданной библиотеки
| dmS* [addr|libname] [sectname]   Перечислить секции заданной библиотеки в формате команд radare
| dmL address size                 Выделить <size> байт по <address>-у и объявить результат huge-страницей
\end{verbatim}

В этой главе рассмотрим только наиболее полезные команды группы
\texttt{dm}, используя простые примеры. Будем использовать программу
\texttt{helloworld} для Linux, для других видов архитектур все будет
выглядеть аналогично.

Сначала откройте программу в режиме отладки:

\begin{verbatim}
$ r2 -d helloworld
Process with PID 20304 started...
= attach 20304 20304
bin.baddr 0x56136b475000
Using 0x56136b475000
asm.bits 64
[0x7f133f022fb0]>
\end{verbatim}

\begin{quote}
Обратите внимание, что мы подставили «helloworld» в radare2 без «./».
Программа radare2 сначала попытается найти бинарик в текущем каталоге, а
затем в \$PATH. Это несколько противоречит идеям UNIX, но делает ее
удобной для пользователей Windows.
\end{quote}

Воспользуемся \texttt{dm} и распечатаем карты памяти открытого двоичного
файла:

\begin{verbatim}
[0x7f133f022fb0]> dm
0x0000563a0113a000 - usr   4K s r-x /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.r_x
0x0000563a0133a000 - usr   8K s rw- /tmp/helloworld /tmp/helloworld ; map.tmp_helloworld.rw
0x00007f133f022000 * usr 148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
0x00007f133f246000 - usr   8K s rw- /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.rw
0x00007f133f248000 - usr   4K s rw- unk0 unk0 ; map.unk0.rw
0x00007fffd25ce000 - usr 132K s rw- [stack] [stack] ; map.stack_.rw
0x00007fffd25f6000 - usr  12K s r-- [vvar] [vvar] ; map.vvar_.r
0x00007fffd25f9000 - usr   8K s r-x [vdso] [vdso] ; map.vdso_.r_x
0xffffffffff600000 - usr   4K s r-x [vsyscall] [vsyscall] ; map.vsyscall_.r_x
\end{verbatim}

Для тех из вас, кто предпочитает более наглядный способ, можно
использовать \texttt{dm=}, карты памяти отобразятся при помощи
ASCII-art. Это удобно, если надо посмотреть расположение карт в
оперативной памяти.

Для печати названия карты памяти для текущего смещения используйте
\texttt{dm.} :

\begin{verbatim}
[0x7f133f022fb0]> dm.
0x00007f947eed9000 # 0x00007f947eefe000 * usr   148K s r-x /usr/lib/ld-2.27.so /usr/lib/ld-2.27.so ; map.usr_lib_ld_2.27.so.r_x
\end{verbatim}

Используя \texttt{dmm} можно «Получить список модулей (библиотек,
двоичных файлов, загруженных в память)» - удобная команда для просмотра
перечня загруженных модулей.

\begin{verbatim}
[0x7fa80a19dfb0]> dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa80a19d000 /usr/lib/ld-2.27.so
\end{verbatim}

\begin{quote}
Обратите внимание, что формат вывода команды \texttt{dm} и конкретно
\texttt{dmm} будет разный для различных операционных систем и двоичных
файлов.
\end{quote}

Вместе с нашим бинарным файлом \texttt{helloworld} загружена
динамическая библиотека \texttt{ld-2.27.so}. И мы пока не видим
\texttt{libc}: radare2 останавливает исполнение перед загрузкой
\texttt{libc} в память. Используем \texttt{dcu} (\textbf{d}ebug
\textbf{c}ontinue \textbf{u}ntil) и выполним программу до ее точки
входа, помеченной radar-ом как \texttt{entry0}.

\begin{verbatim}
[0x7fa80a19dfb0]> dcu entry0
Continue until 0x55ca23a4a520 using 1 bpsize
hit breakpoint at: 55ca23a4a518
[0x55ca23a4a520]> dmm
0x55ca23a4a000 /tmp/helloworld
0x7fa809de1000 /usr/lib/libc-2.27.so
0x7fa80a19d000 /usr/lib/ld-2.27.so
\end{verbatim}

Теперь \texttt{libc-2.27.so} тоже загрузился, отлично!

Говоря о \texttt{libc}, популярной задачей для бинарного эксплоита
является поиск адреса определенного символа в библиотеке. Имея эту
информацию, можно создать эксплойт, использующий ROP. Адрес можно
получить при помощи команды \texttt{dmi}. Попробуем найти адрес
\href{http://man7.org/linux/man-pages/man3/system.3.html}{\texttt{system()}}
в загруженном\texttt{libc}: выполним следующую команду:

\begin{verbatim}
[0x55ca23a4a520]> dmi libc system
514 0x00000000 0x7fa809de1000  LOCAL  FILE    0 system.c
515 0x00043750 0x7fa809e24750  LOCAL  FUNC 1221 do_system
4468 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
5841 0x001285a0 0x7fa809f095a0 LOCAL  FUNC  100 svcerr_systemerr
6427 0x00043d10 0x7fa809e24d10  WEAK  FUNC   45 system
7094 0x00043d10 0x7fa809e24d10 GLBAL  FUNC   45 system
7480 0x001285a0 0x7fa809f095a0 GLBAL  FUNC  100 svcerr_systemerr
\end{verbatim}

Подобно команде \texttt{dm.}, используя \texttt{dmi.} получим ближайший
символ к текущему адресу.

Еще одна полезная команда --- вывод списка секций динамической
библиотеки. В следующем примере перечислены секции \texttt{ld-2.27.so}:

\begin{verbatim}
[0x55a7ebf09520]> dmS ld-2.27
[Sections]
00 0x00000000     0 0x00000000     0 ---- ld-2.27.so.
01 0x000001c8    36 0x4652d1c8    36 -r-- ld-2.27.so..note.gnu.build_id
02 0x000001f0   352 0x4652d1f0   352 -r-- ld-2.27.so..hash
03 0x00000350   412 0x4652d350   412 -r-- ld-2.27.so..gnu.hash
04 0x000004f0   816 0x4652d4f0   816 -r-- ld-2.27.so..dynsym
05 0x00000820   548 0x4652d820   548 -r-- ld-2.27.so..dynstr
06 0x00000a44    68 0x4652da44    68 -r-- ld-2.27.so..gnu.version
07 0x00000a88   164 0x4652da88   164 -r-- ld-2.27.so..gnu.version_d
08 0x00000b30  1152 0x4652db30  1152 -r-- ld-2.27.so..rela.dyn
09 0x00000fb0 11497 0x4652dfb0 11497 -r-x ld-2.27.so..text
10 0x0001d0e0 17760 0x4654a0e0 17760 -r-- ld-2.27.so..rodata
11 0x00021640  1716 0x4654e640  1716 -r-- ld-2.27.so..eh_frame_hdr
12 0x00021cf8  9876 0x4654ecf8  9876 -r-- ld-2.27.so..eh_frame
13 0x00024660  2020 0x46751660  2020 -rw- ld-2.27.so..data.rel.ro
14 0x00024e48   336 0x46751e48   336 -rw- ld-2.27.so..dynamic
15 0x00024f98    96 0x46751f98    96 -rw- ld-2.27.so..got
16 0x00025000  3960 0x46752000  3960 -rw- ld-2.27.so..data
17 0x00025f78     0 0x46752f80   376 -rw- ld-2.27.so..bss
18 0x00025f78    17 0x00000000    17 ---- ld-2.27.so..comment
19 0x00025fa0    63 0x00000000    63 ---- ld-2.27.so..gnu.warning.llseek
20 0x00025fe0 13272 0x00000000 13272 ---- ld-2.27.so..symtab
21 0x000293b8  7101 0x00000000  7101 ---- ld-2.27.so..strtab
22 0x0002af75   215 0x00000000   215 ---- ld-2.27.so..shstrtab
\end{verbatim}

\hypertarget{ux43aux443ux447ux430}{%
\section{Куча}\label{ux43aux443ux447ux430}}

Команды radare2-а семейства \texttt{dm} отображают карту кучи (heap map)
- полезная функция при проверке кучи и ее содержимого. Выполнение
команды \texttt{dmh} показывает карту кучи:

\begin{verbatim}
[0x7fae46236ca6]> dmh
  Malloc chunk @ 0x55a7ecbce250 [size: 0x411][allocated]
  Top chunk @ 0x55a7ecbce660 - [brk_start: 0x55a7ecbce000, brk_end: 0x55a7ecbef000]
\end{verbatim}

Просмотр компоновки кучи в виде графа:

\begin{verbatim}
[0x7fae46236ca6]> dmhg
Heap Layout
    .────────────────────────────────────.
    │    Malloc chunk @ 0x55a7ecbce000   │
    │ size: 0x251                        │
    │  fd: 0x0, bk: 0x0                  │
    `────────────────────────────────────'
        │
    .───'
    │
    │
  .─────────────────────────────────────────────.
  │    Malloc chunk @ 0x55a7ecbce250            │
  │ size: 0x411                                 │
  │  fd: 0x57202c6f6c6c6548, bk: 0xa21646c726f  │
  `─────────────────────────────────────────────'
      │
  .───'
  │
  │
.────────────────────────────────────────────────────.
│  Top chunk @ 0x55a7ecbce660                        │
│ [brk_start:0x55a7ecbce000, brk_end:0x55a7ecbef000] │
`────────────────────────────────────────────────────'
\end{verbatim}

В разделе \texttt{dmh} находятся команды для отображения информации о
куче, полный список команд выводится так - \texttt{dmh?}.

\begin{verbatim}
[0x00000000]> dmh?
|Usage:  dmh # Куча, отображение памяти
| dmh                 Перечислить куски в сегменте кучи
| dmh [malloc_state]  Перечислить куски в области (arena)
| dmha                Перечислить все экземпляры malloc_state в приложении
| dmhb                Показать все найденные двунаправленные списки кусков в main_arena-е
| dmhb [bin_num|bin_num:malloc_state]
|                     Показать все найденные двунаправленные списки кусков в конкретной области
| dmhbg [bin_num]     Показать граф двунаправленных списков кусков в main_arena [в разработке]
| dmhc @[chunk_addr]  Показать структуру malloc_chunk для заданного malloc-куска
| dmhf                Показать все найденные fastbin-ы в main_arena fastbinY-е
| dmhf [fastbin_num|fastbin_num:malloc_state]
|                     Показать найденные двунаправленные списки в fastbinY-е из конкретной области
| dmhg                Показать граф сегмента кучи
| dmhg [malloc_state] Показать граф конкретной области
| dmhi @[malloc_state]Показать heap_info-структуры для заданной области
| dmhm                Показать все элементы структуры malloc_state основной нити (main_arena)
| dmhm [malloc_state] Перечислить все malloc_state-ы конкретной области
| dmht                Показать все найденные thead cache bins в tcache-е main_arena-ы
| dmh?                Показать инструкцию по построению карты кучи
\end{verbatim}

Чтобы напечатать безопасные (safe-linked) списки (glibc \textgreater=
2.32) с разыменованными указателями, переменная
\texttt{dbg.glibc.demangle} должна равняться истине.

\hypertarget{ux444ux430ux439ux43bux44b}{%
\section{Файлы}\label{ux444ux430ux439ux43bux44b}}

Отладчик radare2 позволяет составлять список файловых дескрипторов
исследуемого процесса, а также манипулировать ими. Это полезная функция,
отсутствующая в других отладчиках, ее возможности похожи на инструмент
командной строки lsof, но есть и дополнительные функции для изменения
смещения, закрытия или дублирования дескрипторов. В любой момент можно
заменить дескрипторы файлов, например stdio, на сетевые сокеты,
созданные r2, или заменить существующее сетевое сокетное соединение с
целью его перехвата. Функция также доступна в r2frida при использовании
команды dd с бэкслешем в качестве префикса. Программа r2 предоставляет
дополнительные инструкции --- комбинация dd?.

\hypertarget{ux43eux442ux43bux430ux434ux43aux430-ux432-ux43eux431ux440ux430ux442ux43dux43eux43c-ux43dux430ux43fux440ux430ux432ux43bux435ux43dux438ux438}{%
\section{Отладка в обратном
направлении}\label{ux43eux442ux43bux430ux434ux43aux430-ux432-ux43eux431ux440ux430ux442ux43dux43eux43c-ux43dux430ux43fux440ux430ux432ux43bux435ux43dux438ux438}}

Radare2 включает функцию реверс-отладки - перебор адресов инструкций
программы в обратном направлении (reverse-next, reverse-continue).
Сначала надо сохранить состояние программы в нужный момент. Синтаксис
команды, начинающей запись:

\begin{verbatim}
[0x004028a0]> dts+
\end{verbatim}

Команды \texttt{dts} используются для записи состояний программ и
управления ими. После записи состояний можно устанавливать смещения
счетчика инструкций вперед и назад в любые точки после точки начала
записи. Таким образом, можно попробовать сделать один шаг назад:

\begin{verbatim}
[0x004028a0]> 2dso
[0x004028a0]> dr rip
0x004028ae
[0x004028a0]> dsb
continue until 0x004028a2
hit breakpoint at: 4028a2
[0x004028a0]> dr rip
0x004028a2
\end{verbatim}

При запуске \texttt{dsb} обратный отладчик восстанавливает предыдущее
записанное состояние и запускает программу с этого состояния до нужной
точки. Можно попробовать продолжить в обратном направлении:

\begin{verbatim}
[0x004028a0]> db 0x004028a2
[0x004028a0]> 10dso
[0x004028a0]> dr rip
0x004028b9
[0x004028a0]> dcb
[0x004028a0]> dr rip
0x004028a2
\end{verbatim}

Команда \texttt{dcb} устанавливает счетчик программ на последнюю точку
останова. Как только точка останова установлена, можно вернуться к ней в
любое время. Просмотр списка записей состояний программы - \texttt{dts}:

\begin{verbatim}
[0x004028a0]> dts
session: 0   at:0x004028a0   ""
session: 1   at:0x004028c2   ""
\end{verbatim}

ПРИМЕЧАНИЕ: Записи состояний можно сохранять в любое время. Они
представлены в diff-формате, что позволяет сохранять только изменения
памяти в сравнении с предыдущими версиями. Это экономит место в памяти,
не надо хранить весь дамп.

Можно добавлять комментарии:

\begin{verbatim}
[0x004028c2]> dtsC 0 program start
[0x004028c2]> dtsC 1 decryption start
[0x004028c2]> dts
session: 0   at:0x004028a0   "program start"
session: 1   at:0x004028c2   "decryption start"
\end{verbatim}

Можно делать заметки для каждой записи - ассоциировать с информацией в
уме. Команды \texttt{dsb} и \texttt{dcb} восстанавливают состояние
программы из последней записи при наличии списка таких записей.

Записи программ экспортируются в файлы и импортируются из них.
Экспорт/импорт записей в/из файла:

\begin{verbatim}
[0x004028c2]> dtst records_for_test
Session saved in records_for_test.session and dump in records_for_test.dump
[0x004028c2]> dtsf records_for_test
session: 0, 0x4028a0 diffs: 0
session: 1, 0x4028c2 diffs: 0
\end{verbatim}

Кроме того, можно выполнять реверс-отладку в режиме ESIL. В режиме ESIL
состоянием программы можно управлять при помощи команд \texttt{aets}.

\begin{verbatim}
[0x00404870]> aets+
\end{verbatim}

Шаг назад - \texttt{aesb}:

\begin{verbatim}
[0x00404870]> aer rip
0x00404870
[0x00404870]> 5aeso
[0x00404870]> aer rip
0x0040487d
[0x00404870]> aesb
[0x00404870]> aer rip
0x00404879
\end{verbatim}

В дополнение к собственным возможностям реверс-отладки в radare2, также
можно использовать протокол gdb для реверс-отладки на удаленном сервере
(gdbserver), если сервер поддерживает эту функцию. Команды
\texttt{=!dsb} и \texttt{=!dcb} заменяют собой команды \texttt{dsb} и
\texttt{dcb} для этой цели, изучайте раздел
\href{remote_gdb.md}{удаленной отладки}.

\hypertarget{ux441ux43eux43eux431ux449ux435ux43dux438ux44f-windows}{%
\section{Сообщения
Windows}\label{ux441ux43eux43eux431ux449ux435ux43dux438ux44f-windows}}

В Windows во время отладки можно использовать \texttt{dbW}, задавая
точку останова в обработчике сообщений для определенного окна.

Получение списка активных окон процесса - \texttt{dW}:

\begin{verbatim}
[0x7ffe885c1164]> dW
.----------------------------------------------------.
| Handle      | PID   | TID    | Class Name          |
)----------------------------------------------------(
| 0x0023038e  | 9432  | 22432  | MSCTFIME UI         |
| 0x0029049e  | 9432  | 22432  | IME                 |
| 0x002c048a  | 9432  | 22432  | Edit                |
| 0x000d0474  | 9432  | 22432  | msctls_statusbar32  |
| 0x00070bd6  | 9432  | 22432  | Notepad             |
`----------------------------------------------------'
\end{verbatim}

Установка точки останова с заданным типом сообщения и именем класса окна
или его дескриптором:

\begin{verbatim}
[0x7ffe885c1164]> dbW WM_KEYDOWN Edit
Breakpoint set.
\end{verbatim}

или

\begin{verbatim}
[0x7ffe885c1164]> dbW WM_KEYDOWN 0x002c048a
Breakpoint set.
\end{verbatim}

Если вы не уверены, в какое окно следует поместить точку останова,
используйте \texttt{dWi}, и указывайте окно при помощи мыши:

\begin{verbatim}
[0x7ffe885c1164]> dWi
Move cursor to the window to be identified. Ready? y
Try to get the child? y
.--------------------------------------------.
| Handle      | PID   | TID    | Class Name  |
)--------------------------------------------(
| 0x002c048a  | 9432  | 22432  | Edit        |
`--------------------------------------------'
\end{verbatim}

\hypertarget{ux432ux43eux437ux43cux43eux436ux43dux43eux441ux442ux438-ux443ux434ux430ux43bux435ux43dux43dux43eux433ux43e-ux434ux43eux441ux442ux443ux43fux430}{%
\section{Возможности удаленного
доступа}\label{ux432ux43eux437ux43cux43eux436ux43dux43eux441ux442ux438-ux443ux434ux430ux43bux435ux43dux43dux43eux433ux43e-ux434ux43eux441ux442ux443ux43fux430}}

Radare, как правило, запускается локально, но можно запускать серверный
процесс и контролировать его локальным radare2. Реализация управления
использует подсистему ввода-вывода radare, которая абстрагирует доступ к
system(), cmd() и все основные операции ввода-вывода для работы по сети.

Справка по командам, используемым для организации удаленного доступа к
radare:

\begin{verbatim}
[0x00405a04]> =?
Usage:  =[:!+-=ghH] [...]   # Cоединиться с другим процессом r2

команды удаленного доступа:
| =                             пересилить все открытые соединения
| =<[fd] cmd                    послать вывод локальной команды на удаленный fd
| =[fd] cmd                     запустить команду на удаленном 'fd' (по умолчанию - последний открытый)
| =! cmd                        запустить команду через r_io_system
| =+ [proto://]host:port        соединиться с удаленным host:port (*rap://, raps://, tcp://, udp://, http://)
| =-[fd]                        удалить все хосты или 'fd'
| ==[fd]                        открыть удаленную сессию с хостом 'fd', 'q' -выход
| =!=                           запретить режим удаленной командной строки
| !=!                           установка режима удаленной командной строки

серверы:
| .:9000                        запуск одного серыера (echo x|nc ::1 9090 или curl ::1:9090/cmd/x)
| =:port                        запуск rap-сервера (o rap://9999)
| =g[?]                         запуск gdbserver-а
| =h[?]                         запуск http-вебсервера
| =H[?]                         запуск http-вебсервера вместе с браузером

другие:
| =&:port                       запуск rap-сервера в фоновом режиме (аналогично '&_=h')
| =:host:port cmd               запуск команды 'cmd' на удаленном сервере

примеры:
| =+tcp://localhost:9090/       соединиться:  r2 -c.:9090 ./bin
| =+rap://localhost:9090/       соединиться: r2 rap://:9090
| =+http://localhost:9090/cmd/  соединиться: r2 -c'=h 9090' bin
| o rap://:9090/                запуск rap-сервера на tcp-порту 9090
\end{verbatim}

Инструкции по удаленным возможностям radare2 отображаются списком
поддерживаемых плагинов ввода-вывода: \texttt{radare2\ -L}.

Типичный удаленный сеанс выглядит следующим образом:

На удаленном хосте 1:

\begin{verbatim}
$ radare2 rap://:1234
\end{verbatim}

На удаленном хосте 2:

\begin{verbatim}
$ radare2 rap://:1234
\end{verbatim}

На локальном хосте:

\begin{verbatim}
$ radare2 -
\end{verbatim}

Добавление хостов

\begin{verbatim}
[0x004048c5]> =+ rap://<host1>:1234//bin/ls
Connected to: <host1> at port 1234
waiting... ok

[0x004048c5]> =
0 - rap://<host1>:1234//bin/ls
\end{verbatim}

Можно открывать удаленные файлы в режиме отладки (или с помощью любого
подключаемого модуля ввода-вывода), указывая URI при добавлении хостов:

\begin{verbatim}
[0x004048c5]> =+ =+ rap://<host2>:1234/dbg:///bin/ls
Connected to: <host2> at port 1234
waiting... ok
0 - rap://<host1>:1234//bin/ls
1 - rap://<host2>:1234/dbg:///bin/ls
\end{verbatim}

Выполнение команд на хосте 1:

\begin{verbatim}
[0x004048c5]> =0 px
[0x004048c5]> = s 0x666
\end{verbatim}

Открыть сеанс связи с хостом 2:

\begin{verbatim}
[0x004048c5]> ==1
fd:6> pi 1
...
fd:6> q
\end{verbatim}

Удаление узлов и закрытие подключения:

\begin{verbatim}
[0x004048c5]> =-
\end{verbatim}

Можно также перенаправлять вывод radare на TCP- или UDP-сервер,
например, при помощи \texttt{nc\ -l}. Сначала добавьте сервер при помощи
`=+ tcp://' или `=+ udp://', затем можно перенаправить выходные данные
команды на сервер:

\begin{verbatim}
[0x004048c5]> =+ tcp://<host>:<port>/
Connected to: <host> at port <port>
5 - tcp://<host>:<port>/
[0x004048c5]> =<5 cmd...
\end{verbatim}

Команда \texttt{=\textless{}} отправит вывод команды \texttt{cmd} на
удаленное подключение с номером N или на последнее подключение, если
идентификатор не указан.

\hypertarget{ux43eux442ux43bux430ux434ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-gdbserver-ux430}{%
\section{Отладка при помощи
gdbserver-а}\label{ux43eux442ux43bux430ux434ux43aux430-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-gdbserver-ux430}}

Radare2 позволяет удаленно отлаживать по протоколу gdb. Запускаем
gdbserver и подключаемся к нему с помощью radare2. Синтаксис
подключения:

\begin{verbatim}
$ r2 -d gdb://<host>:<port>
\end{verbatim}

Обратите внимание, что следующая команда делает то же самое, r2
использует подключаемый модуль отладки, указанный в uri, если такой
есть.

\begin{verbatim}
$ r2 -D gdb gdb://<host>:<port>
\end{verbatim}

Плагин отладки можно изменить во время выполнения с помощью команд
\texttt{dL} и \texttt{Ld}.

Если gdbserver работает в расширенном режиме, можно подключиться прямо к
процессу на хосте:

\begin{verbatim}
$ r2 -d gdb://<host>:<port>/<pid>
\end{verbatim}

Также возможно начать отладку после анализа файла с помощью команды
\texttt{doof}, которая перебазирует (rebase) данные текущего сеанса при
открытии gdb.

\begin{verbatim}
[0x00404870]> doof gdb://<host>:<port>/<pid>
\end{verbatim}

После подключения можно использовать стандартные команды отладки r2.

Radare2 еще не умеет загружать символы из gdbserver, копия двоичного
файла должна быть локально представлена для загрузки символов. В случае,
если символы не загружены даже если двоичный файл присутствует, можно
попробовать указать путь с помощью \texttt{e\ dbg.exe.path}:

\begin{verbatim}
$ r2 -e dbg.exe.path=<path> -d gdb://<host>:<port>
\end{verbatim}

Если символы загружаются по неправильному базовому адресу, можно
попробовать указать и базовый адрес \texttt{e\ bin.baddr}:

\begin{verbatim}
$ r2 -e bin.baddr=<baddr> -e dbg.exe.path=<path> -d gdb://<host>:<port>
\end{verbatim}

Обычно gdbserver сообщает максимальный поддерживаемый размер пакета. В
противном случае radare2 использует разумные значения по умолчанию.
Можно указать максимальный размер пакета в переменной окружения
\texttt{R2\_GDB\_PKTSZ}. Можно узнать и установить максимальный размер
пакета во время сеанса с плагином ввода-вывода, \texttt{=!}.

\begin{verbatim}
$ export R2_GDB_PKTSZ=512
$ r2 -d gdb://<host>:<port>
= attach <pid> <tid>
Assuming filepath <path/to/exe>
[0x7ff659d9fcc0]> =!pktsz
packet size: 512 bytes
[0x7ff659d9fcc0]> =!pktsz 64
[0x7ff659d9fcc0]> =!pktsz
packet size: 64 bytes
\end{verbatim}

Плагин ввода-вывода gdb предоставляет полезные команды, которые могут не
подходить ни для одной стандартной команды rdare2. Получить список этих
команд можно с помощью \texttt{=!?}. (Напомним, \texttt{=!} получает
доступ к базовому плагину ввода-вывода \texttt{system()}).

\begin{verbatim}
[0x7ff659d9fcc0]> =!?
Usage: =!cmd args
 =!pid             - показать pid
 =!pkt s           - послать пакет 's'
 =!monitor cmd     - закодировать в шестнадцатеричный вид команду монитора и передать ее интерпретатору
 =!rd              - показать, есть ли возможность выполнять отладку в обратном направлении
 =!dsb             - шаг назад
 =!dcb             - продолжить в обратном направлении
 =!detach [pid]    - отсоединиться от удаленного или локального процесса по pid
 =!inv.reg         - сбросить кэш регистров
 =!pktsz           - показать размер максимального использованного пакета
 =!pktsz bytes     - установить размер максимального пакета в байтах
 =!exec_file [pid] - показать файл, который был запущен в текущем или заданным по pid процессе
\end{verbatim}

Заметим, что \texttt{=!dsb} и \texttt{=!dcb} доступны только в
специальных реализациях gdbserver, таких, как
\href{https://github.com/mozilla/rr}{rr Мозиллы}, gdbserver по умолчанию
не включает поддержку удаленной реверс-отладки. Используйте
\texttt{=!rd}, чтобы посмотреть доступные возможности реверс-отладки.

Если есть интерес в отладке взаимодействия radare2-а с сервером
gdbserver, полезно использовать \texttt{=!monitor\ set\ remote-debug\ 1}
для включения журналирования пакетов протокола управления формата gdb
консоли gdbserver-а, также \texttt{=!monitor\ set\ debug\ 1} - вывод
сообщений отладки, приходящих от gdbserver от его консоли.

Radare2 также реализует собственный gdbserver:

\begin{verbatim}
$ r2 -
[0x00000000]> =g?
|Usage:  =[g] [...] # сервер gdb
| gdbserver:
| =g port file [args]   взаимодействуя через 'port', отлаживать 'file', используя gdbserver
| =g! port file [args]  то же, что выше, но с выдачей сообщений протокола отладки (например, gdbserver --remote-debug)
\end{verbatim}

Запускать его так:

\begin{verbatim}
$ r2 -
[0x00000000]> =g 8000 /bin/radare2 -
\end{verbatim}

А затем подключайтесь к нему, как к любому gdbserver. Например, при
помощи radare2:

\begin{verbatim}
$ r2 -d gdb://localhost:8000
\end{verbatim}

\hypertarget{ux43eux442ux43bux430ux434ux43aux430-ux432-ux440ux435ux436ux438ux43cux435-ux44fux434ux440ux430-ux441-windbg-kd}{%
\section{Отладка в режиме ядра с WinDBG
KD}\label{ux43eux442ux43bux430ux434ux43aux430-ux432-ux440ux435ux436ux438ux43cux435-ux44fux434ux440ux430-ux441-windbg-kd}}

Поддержка интерфейса WinDBG KD в r2 позволяет подключаться к работающей
виртуальной машине Windows и отлаживать ее ядро через последовательный
порт или сетавое соединение.

Также можно использовать удаленный интерфейса GDB для подключения и
отладки ядер Windows вне зависимости от инструментов Windows.

Имейте в виду, что поддержка WinDBG KD все еще находится в стадии
разработки, сейчас это базовая реализация, которая со временем станет
лучше.

\hypertarget{ux43dux430ux441ux442ux440ux43eux439ux43aux430-kd-ux432-windows}{%
\subsection{Настройка KD в
Windows}\label{ux43dux430ux441ux442ux440ux43eux439ux43aux430-kd-ux432-windows}}

\begin{quote}
Пошаговое руководство см. в
\href{https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd}{документации
корпорации Майкрософт}.
\end{quote}

\hypertarget{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux44bux439-ux43fux43eux440ux442}{%
\subsubsection{Последовательный
порт}\label{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux44bux439-ux43fux43eux440ux442}}

Подключение KD через последовательный порт в Windows Vista и выше
осуществляется следующим образом:

\begin{verbatim}
bcdedit /debug on
bcdedit /dbgsettings serial debugport:1 baudrate:115200
\end{verbatim}

Так это делается для Windows XP: Открыть boot.ini и добавить /debug
/debugport=COM1 /baudrate=115200:

\begin{verbatim}
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Debugging with Cable" /fastdetect /debug /debugport=COM1 /baudrate=57600
\end{verbatim}

В случае VMWare:

\begin{verbatim}
    Virtual Machine Settings -> Add -> Serial Port
    Device Status:
    [v] Connect at power on
    Connection:
    [v] Use socket (named pipe)
    [_/tmp/winkd.pipe________]
    From: Server To: Virtual Machine
\end{verbatim}

Настройка машины VirtualBox:

\begin{verbatim}
    Preferences -> Serial Ports -> Port 1

    [v] Enable Serial Port
    Port Number: [_COM1_______[v]]
    Port Mode:   [_Host_Pipe__[v]]
                 [v] Create Pipe
    Port/File Path: [_/tmp/winkd.pipe____]
\end{verbatim}

Создание виртуальной машины при помощи qemu:

\begin{verbatim}
$ qemu-system-x86_64 -chardev socket,id=serial0,\
     path=/tmp/winkd.pipe,nowait,server \
     -serial chardev:serial0 -hda Windows7-VM.vdi
\end{verbatim}

\hypertarget{ux441ux435ux442ux44c}{%
\subsubsection{Сеть}\label{ux441ux435ux442ux44c}}

Подключение KD по сети (KDNet) в Windows 7 или более поздней версии
выглядит следующим образом:

\begin{verbatim}
bcdedit /debug on
bcdedit /dbgsettings net hostip:w.x.y.z port:n
\end{verbatim}

Начиная с Windows 8, принудительно выполнить отладку в каждой загрузке
невозможно, но всегда можно входить в расширенные параметры загрузки и
там включать отладку ядра:

\begin{verbatim}
bcedit /set {globalsettings} advancedoptions true
\end{verbatim}

\hypertarget{ux43fux43eux434ux43aux43bux44eux447ux435ux43dux438ux435-ux43a-ux438ux43dux442ux435ux440ux444ux435ux439ux441ux443-kd-ux43dux430-r2}{%
\subsection{Подключение к интерфейсу KD на
r2}\label{ux43fux43eux434ux43aux43bux44eux447ux435ux43dux438ux435-ux43a-ux438ux43dux442ux435ux440ux444ux435ux439ux441ux443-kd-ux43dux430-r2}}

\hypertarget{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux44bux439-ux43fux43eux440ux442-1}{%
\subsubsection{Последовательный
порт}\label{ux43fux43eux441ux43bux435ux434ux43eux432ux430ux442ux435ux43bux44cux43dux44bux439-ux43fux43eux440ux442-1}}

Radare2 использует плагин ввода-вывода \texttt{winkd} для подключения к
файлу сокета, создаваемому virtualbox-ом или qemu. Для плагина отладчика
\texttt{winkd} нужно также указать x86-32. (поддерживаются 32- и
64-разрядная отладка)

\begin{verbatim}
$ r2 -a x86 -b 32 -D winkd winkd:///tmp/winkd.pipe
\end{verbatim}

В Windows надо запустить следующую строку:

\begin{verbatim}
$ radare2 -D winkd winkd://\\.\pipe\com_1
\end{verbatim}

\hypertarget{ux441ux435ux442ux44c-1}{%
\subsubsection{Сеть}\label{ux441ux435ux442ux44c-1}}

\begin{verbatim}
$ r2 -a x86 -b 32 -d winkd://<hostip>:<port>:w.x.y.z
\end{verbatim}

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-kd}{%
\subsection{Использование
KD}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-kd}}

При подключении к интерфейсу KD r2 отправит пакет разрыва для прерывания
выполнения целевого процесса:

\begin{verbatim}
[0x828997b8]> pd 20
    ;-- eip:
    0x828997b8    cc           int3
    0x828997b9    c20400       ret 4
    0x828997bc    cc           int3
    0x828997bd    90           nop
    0x828997be    c3           ret
    0x828997bf    90           nop
\end{verbatim}

Чтобы пропустить это прерывание, нужно изменить eip и запустить `dc'
дважды:

\begin{verbatim}
dr eip=eip+1
dc
dr eip=eip+1
dc
\end{verbatim}

Теперь виртуальная машина Windows снова будет интерактивной. Нам нужно
будет убить r2 и присоединить его еще раз, чтобы перейти к управлению
ядром.

Команда \texttt{dp} используется для перечисления всех процессов, а
\texttt{dpa} или \texttt{dp=} для присоединения к процессу. Будет
отображены базовые адреса процессов в карте физической памяти.

\hypertarget{windbg-ux431ux44dux43aux435ux43dux434-ux434ux43bux44f-windows-dbgeng}{%
\section{WinDBG бэкенд для Windows
(DbgEng)}\label{windbg-ux431ux44dux43aux435ux43dux434-ux434ux43bux44f-windows-dbgeng}}

В Windows radare2 может использовать \texttt{DbgEng.dll} в качестве
серверной части отладки, позволяя ему использовать возможности WinDBG,
включая поддержку файлов дампа памяти, отладку режимов пользователя и
ядра локально и удаленно.

Можно использовать DLL-библиотеки отладки, включенные в Windows, или
загрузить последние версии со
\href{https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools}{страницы
загрузки} Майкрософт, что рекомендуется сделать.

\begin{quote}
Использовать библиотеки DLL из папки приложения \texttt{WinDbg\ Preview}
Microsoft Store напрямую \textbf{нельзя}, поскольку они не помечены как
исполняемые для обычных пользователей.
\end{quote}

\begin{quote}
radare2 попытается сначала загрузить \texttt{dbgeng.dll} из директория,
указанного в переменной среды \texttt{\_NT\_DEBUGGER\_EXTENSION\_PATH},
перед тем как использовать путь поиска библиотек Windows по умолчанию.
\end{quote}

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430}{%
\subsection{Использование
плагина}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430}}

Чтобы использовать плагин \texttt{windbg} задавайте те же параметры
командной строки, что и для \texttt{WinDBG} или \texttt{kd} (см.
\href{https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/windbg-command-line-options}{документацию}
Microsoft), добавляя кавычки и экранируя ``"-ами при необходимости:

\begin{verbatim}
> r2 -d "windbg://-remote tcp:server=Server,port=Socket"
\end{verbatim}

\begin{verbatim}
> r2 -d "windbg://MyProgram.exe \"my arg\""
\end{verbatim}

\begin{verbatim}
> r2 -d "windbg://-k net:port=<n>,key=<MyKey>"
\end{verbatim}

\begin{verbatim}
> r2 -d "windbg://-z MyDumpFile.dmp"
\end{verbatim}

Затем можно выполнять отладку как обычно (см. команду \texttt{d?}) или
взаимодействовать с командной строкой на сервере непосредственно с
помощью команды \texttt{=!}:

\begin{verbatim}
[0x7ffcac9fcea0]> dcu 0x0007ffc98f42190
Continue until 0x7ffc98f42190 using 1 bpsize
ModLoad: 00007ffc`ab6b0000 00007ffc`ab6e0000   C:\WINDOWS\System32\IMM32.DLL
Breakpoint 1 hit
hit breakpoint at: 0x7ffc98f42190

[0x7fffcf232190]> =!k4
Child-SP          RetAddr           Call Site
00000033`73b1f618 00007ff6`c67a861d r_main!r_main_radare2
00000033`73b1f620 00007ff6`c67d0019 radare2!main+0x8d
00000033`73b1f720 00007ff6`c67cfebe radare2!invoke_main+0x39
00000033`73b1f770 00007ff6`c67cfd7e radare2!__scrt_common_main_seh+0x12e
\end{verbatim}

\hypertarget{ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}{%
\section{Инструменты}\label{ux438ux43dux441ux442ux440ux443ux43cux435ux43dux442ux44b}}

Radare2 - это не единственный инструмент, предоставляемый проектом
radare2. Остальные главы в этой книге сосредоточены на представлении
инструментов radare2, эта глава будет сосредоточена на объяснении
сопутствующих инструментов. Все функциональные возможности,
предоставляемые различными API и плагинами, включают различные
инструменты, позволяющие легко использовать их из командной строки и
легко интегрировать их со скриптами ОС.

Благодаря ``ортогональному'' дизайну фреймворка, можно делать все то,
что умеет r2, при помощи следующих классов инструментов:

\begin{itemize}
\tightlist
\item
  сопутствующие инструменты,
\item
  API нативных библиотек,
\item
  запуск сценариев с помощью r2pipe,
\item
  оболочка R2.
\end{itemize}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rax2-1}{%
\subsection{Программа
Rax2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rax2-1}}

Утилита \texttt{rax2} - часть пакета radare, она является простым
вычислителем выражений для командной строки ОС. Программа полезна для
выполнения базовых преобразований между значениями с плавающей запятой,
шестнадцатеричными представлениями, шестнадцатеричными строками в ascii,
восьмеричных чисел в другие системы счисления. Поддерживается порядок
байтов и запускает свой интерпретатор командной строки, если аргументы
не приведены. В командной строке rax2 может считывать значения из stdin,
поэтому его можно использовать как многобазовый калькулятор значений во
входном потоке.

Внутри r2 функциональность rax2 доступна в группе команд
\texttt{?\ \textless{}выражение\textgreater{}}. Например:

\begin{verbatim}
[0x00000000]> ? 3+4
\end{verbatim}

Как видите, числовые выражения могут содержать математические выражения,
такие как сложение, вычитание, \ldots{} а также операции со скобками.
Синтаксис, в котором представлены числа, определяет систему счисления,
например:

\begin{itemize}
\tightlist
\item
  3 : decimal, base 10
\item
  0xface : hexadecimal, base 16
\item
  0472 : octal, base 8
\item
  2M : units, 2 megabytes
\item
  \ldots{}
\end{itemize}

Справка доступна по \texttt{rax2\ -h}, она покажет вам еще кучу
синтаксических элементов

\begin{verbatim}
$ rax2 -h
Usage: rax2 [options] [expr ...]
  =[base]                      ;  rax2 =10 0x46 -> output in base 10
  int     ->  hex              ;  rax2 10
  hex     ->  int              ;  rax2 0xa
  -int    ->  hex              ;  rax2 -77
  -hex    ->  int              ;  rax2 0xffffffb3
  int     ->  bin              ;  rax2 b30
  int     ->  ternary          ;  rax2 t42
  bin     ->  int              ;  rax2 1010d
  ternary ->  int              ;  rax2 1010dt
  float   ->  hex              ;  rax2 3.33f
  hex     ->  float            ;  rax2 Fx40551ed8
  oct     ->  hex              ;  rax2 35o
  hex     ->  oct              ;  rax2 Ox12 (O is a letter)
  bin     ->  hex              ;  rax2 1100011b
  hex     ->  bin              ;  rax2 Bx63
  ternary ->  hex              ;  rax2 212t
  hex     ->  ternary          ;  rax2 Tx23
  raw     ->  hex              ;  rax2 -S < /binfile
  hex     ->  raw              ;  rax2 -s 414141
  -l                           ;  добавить перевод строки в вывод (для -E/-D/-r/..
  -a      show ascii table     ;  rax2 -a
  -b      bin -> str           ;  rax2 -b 01000101 01110110
  -B      str -> bin           ;  rax2 -B hello
  -d      force integer        ;  rax2 -d 3 -> 3 instead of 0x3
  -e      swap endianness      ;  rax2 -e 0x33
  -D      base64 decode        ;
  -E      base64 encode        ;
  -f      floating point       ;  rax2 -f 6.3+2.1
  -F      stdin slurp code hex ;  rax2 -F < shellcode.[c/py/js]
  -h      help                 ;  rax2 -h
  -i      dump as C byte array ;  rax2 -i < bytes
  -k      keep base            ;  rax2 -k 33+3 -> 36
  -K      randomart            ;  rax2 -K 0x34 1020304050
  -L      bin -> hex(bignum)   ;  rax2 -L 111111111 # 0x1ff
  -n      binary number        ;  rax2 -n 0x1234 # 34120000
  -N      binary number        ;  rax2 -N 0x1234 # \x34\x12\x00\x00
  -r      r2 style output      ;  rax2 -r 0x1234
  -s      hexstr -> raw        ;  rax2 -s 43 4a 50
  -S      raw -> hexstr        ;  rax2 -S < /bin/ls > ls.hex
  -t      tstamp -> str        ;  rax2 -t 1234567890
  -x      hash string          ;  rax2 -x linux osx
  -u      units                ;  rax2 -u 389289238 # 317.0M
  -w      signed word          ;  rax2 -w 16 0xffff
  -v      version              ;  rax2 -v
\end{verbatim}

Примеры:

\begin{verbatim}
$ rax2 3+0x80
0x83
\end{verbatim}

\begin{verbatim}
$ rax2 0x80+3
131
\end{verbatim}

\begin{verbatim}
$ echo 0x80+3 | rax2
131
\end{verbatim}

\begin{verbatim}
$ rax2 -s 4142
AB
\end{verbatim}

\begin{verbatim}
$ rax2 -S AB
4142
\end{verbatim}

\begin{verbatim}
$ rax2 -S < bin.foo
...
\end{verbatim}

\begin{verbatim}
$ rax2 -e 33
0x21000000
\end{verbatim}

\begin{verbatim}
$ rax2 -e 0x21000000
33
\end{verbatim}

\begin{verbatim}
$ rax2 -K 90203010
+--[0x10302090]---+
|Eo. .            |
| . . . .         |
|      o          |
|       .         |
|        S        |
|                 |
|                 |
|                 |
|                 |
+-----------------+
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rafind2-1}{%
\section{Программа
rafind2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rafind2-1}}

Rafind2 --- это командная строка библиотеки \texttt{r\_search}. Она
позволяет искать строки, последовательности байтов с двоичными масками и
т.д.

\begin{verbatim}
$ rafind2 -h
Usage: rafind2 [-mXnzZhqv] [-a align] [-b sz] [-f/t from/to] [-[e|s|S] str] [-x hex] -|file|dir ..
 -a [align] принимать только выровненные хиты
 -b [size]  установить размер блока
 -e [regex] поиск соответствий regex (может быть использовано несколько раз)
 -f [from]  начать поиск с адреса 'from'
 -h         показать это сообщение
 -i         идентифицировать тип файла (r2 -nqcpm файл)
 -j         выводить в формате JSON
 -m         поиск магических последовательностей, идентификация типа файла
 -M [str]   задать бинарную маску, применяемую к ключевым словам
 -n         не останавливаться при наличии ошибок чтения
 -r         вывести результат в виде команд radare
 -s [str]   поиск заданной строки (может быть использовано несколько раз)
 -S [str]   поиск заданной wide-строки (может быть использовано несколько раз), предполагается кодировка UTF-8.
 -t [to]    остановить поиск на адресе 'to'
 -q         тихий режим, не показывать заголовки в результатах (имена файлов), совпадающий контент (по умолчанию для поиска в одном файле)
 -v         напечатать версию и выйти
 -x [hex]   поиск шнадцатеричных строк (909090) (может быть использовано несколько раз)
 -X         выводить результат в виде шестнадцатеричного дампа
 -z         поиск строк, заканчивающихся нулем
 -Z         показывать строки для каждого хита
\end{verbatim}

Вот как его использовать: сначала найдем ``lib'' внутри двоичного файла
\texttt{/bin/ls}.

\begin{verbatim}
$ rafind2 -s lib /bin/ls
0x5f9
0x675
0x679
...
$
\end{verbatim}

Обратите внимание, что выходные данные довольно минималистичны и
показывают смещения там, где находится строка \texttt{lib}. Можно
использовать этот вывод для подачи других инструментов.

Результаты подсчета:

\begin{verbatim}
$ rafind2 -s lib /bin/ls | wc -l
\end{verbatim}

Отображение результатов с контекстом:

\begin{verbatim}
$ export F=/bin/ls
$ for a in `rafind2 -s lib $F` ; do \
    r2 -ns $a -qc'x 32' $F ; done
0x000005f9  6c69 622f 6479 6c64 .. lib/dyld........
0x00000675  6c69 622f 6c69 6275 .. lib/libutil.dyli
0x00000679  6c69 6275 7469 6c2e .. libutil.dylib...
0x00000683  6c69 6200 000c 0000 .. lib......8......
0x000006a5  6c69 622f 6c69 626e .. lib/libncurses.5
0x000006a9  6c69 626e 6375 7273 .. libncurses.5.4.d
0x000006ba  6c69 6200 0000 0c00 .. lib.......8.....
0x000006dd  6c69 622f 6c69 6253 .. lib/libSystem.B.
0x000006e1  6c69 6253 7973 7465 .. libSystem.B.dyli
0x000006ef  6c69 6200 0000 0000 .. lib......&......
\end{verbatim}

Rafind2 также может быть использован в качестве замены \texttt{file} для
идентификации mimetype файла с помощью внутренней базы данных магических
последовательностей radare2.

\begin{verbatim}
$ rafind2 -i /bin/ls
0x00000000 1 Mach-O
\end{verbatim}

Также утилита работает как замена \texttt{strings} аналогично rabin2 -z,
но без анализа заголовков и двоичных разделов.

\begin{verbatim}
$ rafind2 -z /bin/ls| grep http
0x000076e5 %http://www.apple.com/appleca/root.crl0\r
0x00007ae6 https://www.apple.com/appleca/0
0x00007fa9 )http://www.apple.com/certificateauthority0
0x000080ab $http://crl.apple.com/codesigning.crl0
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rarun2-1}{%
\section{Программа
Rarun2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rarun2-1}}

Rarun2 - инструмент, позволяющий настроить специальную среду выполнения
- переопределять stdin/stdout, каналы, переменные среды, а также
параметров, полезных для формирования ограниченной среды, в которой
предполагается выполнить двоичный файл, включая режим отладки.

\begin{verbatim}
$ rarun2 -h
Usage: rarun2 -v|-t|script.rr2 [directive ..]
\end{verbatim}

Rarun2 используется как в качестве отдельного инструмента, так и в
составе radare2. Задания среды исполнения (профиля) используется
текстовый файл в формате ключ=значение. Формат профиля очень прост.
Наиболее важные ключи - \texttt{program} и \texttt{arg*}. Профиль rarun2
можно загружать и в radare2. Для загрузки профиля из файла необходимо
использовать флаг\texttt{-r}, флаг \texttt{-R} позволяет задавать
директивы в командной строке.

Один из наиболее распространенных вариантов использования -
перенаправление вывода отлаживаемой программы в radare2. Для этого нужно
использовать \texttt{stdio}, \texttt{stdout}, \texttt{stdin},
\texttt{input} и пару аналогичных ключей.

Вот пример профиля:

\begin{verbatim}
program=/bin/ls
arg1=/bin
# arg2=hello
# arg3="hello\nworld"
# arg4=:048490184058104849
# arg5=:!ragg2 -p n50 -d 10:0x8048123
# arg6=@arg.txt
# arg7=@300@ABCD # 300 chars filled with ABCD pattern
# system=r2 -
# aslr=no
setenv=FOO=BAR
# unsetenv=FOO
# clearenv=true
# envfile=environ.txt
timeout=3
# timeoutsig=SIGTERM # or 15
# connect=localhost:8080
# listen=8080
# pty=false
# fork=true
# bits=32
# pid=0
# pidfile=/tmp/foo.pid
# #sleep=0
# #maxfd=0
# #execve=false
# #maxproc=0
# #maxstack=0
# #core=false
# #stdio=blah.txt
# #stderr=foo.txt
# stdout=foo.txt
# stdin=input.txt # or !program to redirect input from another program
# input=input.txt
# chdir=/
# chroot=/mnt/chroot
# libpath=$PWD:/tmp/lib
# r2preload=yes
# preload=/lib/libfoo.so
# setuid=2000
# seteuid=2000
# setgid=2001
# setegid=2001
# nice=5
\end{verbatim}

\hypertarget{rabin2-ux441ux432ux43eux439ux441ux442ux432ux430-ux434ux432ux43eux438ux447ux43dux43eux433ux43e-ux444ux430ux439ux43bux430}{%
\section{Rabin2 --- свойства двоичного
файла}\label{rabin2-ux441ux432ux43eux439ux441ux442ux432ux430-ux434ux432ux43eux438ux447ux43dux43eux433ux43e-ux444ux430ux439ux43bux430}}

Под этим именем radare скрывает мощный инструмент для обработки двоичных
файлов, для получения информации об импорте, разделах, заголовках и
других данных. Rabin2 может представить его в нескольких форматах,
принятых другими инструментами, включая сам radare2. Rabin2 понимает
многие форматы файлов: Java CLASS, ELF, PE, Mach-O или любой формат,
поддерживаемый плагинами, и он может получать импорт / экспорт символов,
зависимости библиотеки, строки разделов данных, внешние ссылки, адрес
точки входа, разделы, тип архитектуры.

\begin{verbatim}
$ rabin2 -h
Usage: rabin2 [-AcdeEghHiIjlLMqrRsSvVxzZ] [-@ at] [-a arch] [-b bits] [-B addr]
              [-C F:C:D] [-f str] [-m addr] [-n str] [-N m:M] [-P[-P] pdb]
              [-o str] [-O str] [-k query] [-D lang symname] | file
 -@ [addr]       показать секцию, символ или импорт по указанному адресу
 -A              перечислить включенные бинарики и их битовые пары архитектуры
 -a [arch]       установить архитектуру (x86, arm, .. or <arch>_<bits>)
 -b [bits]       устанолить биты (32, 64 ...)
 -B [addr]       заменить базовый адрес (pie bins)
 -c              перечислить классы
 -C [fmt:C:D]    создать [elf,mach0,pe] с секциями Code и Data шеснадцатеричными кодами (see -a)
 -d              показать отладочную/dwarf информацию
 -D lang name    "распутать" имя символа (-D all для bin.demangle=true)
 -e              точка входа
 -E              глобально экспортируемые символы
 -f [str]        выбрать строку в встроенный бинарике
 -F [binfmt]     использовать насильно заданный бинарный плагин, игнорируя анализ заголовка
 -g              то же что, и -SMZIHVResizcld (показать всю информацию)
 -G [addr]       загрузка адреса . смещения относительно заголовка
 -h              это сообщение
 -H              поля заголовка
 -i              импорты (символы, импортированные из библиотек)
 -I              информация о бинарике
 -j              выводить в json
 -k [sdb-query]  запустить запрос к sdb. пример: '*'
 -K [algo]       вычислить контрольные суммы (md5, sha1, ...)
 -l              прилинкованные библиотеки
 -L [plugin]     перечислить поддерживаемые плагины и их детали
 -m [addr]       показывать исходный код по адресу
 -M              main (показать адрес символа main)
 -n [str]        показать секцию, символ или импорт, поименованную строку
 -N [min:max]    установить числа min:max в символах для строк (смотри -z и -zz)
 -o [str]        вывод файла/папки для операций записи (выключено по умолчанию)
 -O [str]        записать/экстрагировать операции (-O help)
 -p              показать физический адрес
 -P              показать отладочную/pdb информацию,
 -PP             загрузить файл pdb.
 -q              выдавать меньше информации
 -qq             выдавать меньше информации (без смещений/размеров для -z, например)
 -Q              показать адрес загрузки, используемый dlopen (не-aslr-библиотеки)
 -r              вывода в формате radare
 -R              релокации
 -s              символы
 -S              секции
 -u              нефильтрованный вывод (без переименования символов-дубликатов и секций)
 -v              показать версию и выйти
 -V              показать версию бинарика
 -x              экстрагировать бинарики, содержащиеся в файле
 -X [fmt] [f] .. запаковать в fat или zip-файлы перечисленные файлы и бинарики, содержащиеся в файле
 -z              строки (из сегмента данных)
 -zz             строки (из raw-бинариков [e bin.rawstr=1])
 -zzz            дамп raw-строк на стандартный вывод (для файлов большого размера)
 -Z              попробовать угадать размер двоичной программы
......
\end{verbatim}

\hypertarget{ux438ux434ux435ux43dux442ux438ux444ux438ux43aux430ux446ux438ux44f-ux441ux432ux43eux439ux441ux442ux432-ux444ux430ux439ux43bux430}{%
\subsection{Идентификация свойств
файла}\label{ux438ux434ux435ux43dux442ux438ux444ux438ux43aux430ux446ux438ux44f-ux441ux432ux43eux439ux441ux442ux432-ux444ux430ux439ux43bux430}}

Идентификация типа файла осуществляется с помощью \texttt{-I}. С помощью
этого параметра rabin2 выводит информацию о двоичном типе, такую как
кодировка, порядок байтов, класс, операционная система:

\begin{verbatim}
$ rabin2 -I /bin/ls
arch     x86
binsz    128456
bintype  elf
bits     64
canary   true
class    ELF64
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
lang     c
linenum  false
lsyms    false
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   false
relro    partial
rpath    NONE
static   false
stripped true
subsys   linux
va       true
\end{verbatim}

Чтобы заставить rabin2 выдавать информацию в формате, понятном основной
программе radare2, добавьте флаг \texttt{-Ir}:

\begin{verbatim}
$ rabin2 -Ir /bin/ls
e cfg.bigendian=false
e asm.bits=64
e asm.dwarf=true
e bin.lang=c
e file.type=elf
e asm.os=linux
e asm.arch=x86
e asm.pcalign=0
\end{verbatim}

\hypertarget{ux442ux43eux447ux43aux438-ux432ux432ux43eux434ux430-ux432-ux43aux43eux434}{%
\subsection{Точки ввода в
код}\label{ux442ux43eux447ux43aux438-ux432ux432ux43eux434ux430-ux432-ux43aux43eux434}}

Флаг \texttt{-e}, переданный rabin2, покажет точки входа для данного
двоичного файла. Два примера:

\begin{verbatim}
$ rabin2 -e /bin/ls
[Entrypoints]
vaddr=0x00005310 paddr=0x00005310 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program

1 entrypoints

$ rabin2 -er /bin/ls
fs symbols
f entry0 1 @ 0x00005310
f entry0_haddr 1 @ 0x00000018
s entry0
\end{verbatim}

\hypertarget{ux438ux43cux43fux43eux440ux442ux44b}{%
\subsection{Импорты}\label{ux438ux43cux43fux43eux440ux442ux44b}}

Rabin2 способен находить импортированные объекты по исполняемому файлу,
а также их смещения в своем PLT. Эта информация полезна, например, для
понимания того, какая внешняя функция вызывается инструкцией
\texttt{call}. Передайте флаг \texttt{-i} rabin2, чтобы получить список
импортов. Пример:

\begin{verbatim}
$ rabin2 -i /bin/ls
[Imports]
nth vaddr      bind   type   lib name
-------------------------------------
   1 0x000032e0  GLOBAL    FUNC __ctype_toupper_loc
   2 0x000032f0  GLOBAL    FUNC getenv
   3 0x00003300  GLOBAL    FUNC sigprocmask
   4 0x00003310  GLOBAL    FUNC __snprintf_chk
   5 0x00003320  GLOBAL    FUNC raise
   6 0x00000000  GLOBAL    FUNC free
   7 0x00003330  GLOBAL    FUNC abort
   8 0x00003340  GLOBAL    FUNC __errno_location
   9 0x00003350  GLOBAL    FUNC strncmp
  10 0x00000000    WEAK  NOTYPE _ITM_deregisterTMCloneTable
  11 0x00003360  GLOBAL    FUNC localtime_r
  12 0x00003370  GLOBAL    FUNC _exit
  13 0x00003380  GLOBAL    FUNC strcpy
  14 0x00003390  GLOBAL    FUNC __fpending
  15 0x000033a0  GLOBAL    FUNC isatty
  16 0x000033b0  GLOBAL    FUNC sigaction
  17 0x000033c0  GLOBAL    FUNC iswcntrl
  18 0x000033d0  GLOBAL    FUNC wcswidth
  19 0x000033e0  GLOBAL    FUNC localeconv
  20 0x000033f0  GLOBAL    FUNC mbstowcs
  21 0x00003400  GLOBAL    FUNC readlink
...
\end{verbatim}

\hypertarget{ux44dux43aux441ux43fux43eux440ux442ux44b}{%
\subsection{Экспорты}\label{ux44dux43aux441ux43fux43eux440ux442ux44b}}

Rabin2 способен находить экспорты. Пример:

\begin{verbatim}
$ rabin2 -E /usr/lib/libr_bin.so | head
[Exports]

nth  paddr       vaddr      bind   type size lib name
-----------------------------------------------------
210 0x000ae1f0 0x000ae1f0 GLOBAL   FUNC  200 r_bin_java_print_exceptions_attr_summary
211 0x000afc90 0x000afc90 GLOBAL   FUNC  135 r_bin_java_get_args
212 0x000b18e0 0x000b18e0 GLOBAL   FUNC   35 r_bin_java_get_item_desc_from_bin_cp_list
213 0x00022d90 0x00022d90 GLOBAL   FUNC  204 r_bin_class_add_method
214 0x000ae600 0x000ae600 GLOBAL   FUNC  175 r_bin_java_print_fieldref_cp_summary
215 0x000ad880 0x000ad880 GLOBAL   FUNC  144 r_bin_java_print_constant_value_attr_summary
216 0x000b7330 0x000b7330 GLOBAL   FUNC  679 r_bin_java_print_element_value_summary
217 0x000af170 0x000af170 GLOBAL   FUNC   65 r_bin_java_create_method_fq_str
218 0x00079b00 0x00079b00 GLOBAL   FUNC   15 LZ4_createStreamDecode
\end{verbatim}

\hypertarget{ux441ux438ux43cux432ux43eux43bux44b-ux44dux43aux441ux43fux43eux440ux442ux44b}{%
\subsection{Символы
(Экспорты)}\label{ux441ux438ux43cux432ux43eux43bux44b-ux44dux43aux441ux43fux43eux440ux442ux44b}}

В rabin2 формат списка сгенерированных символов аналогичен списку
импорта. Используйте параметр \texttt{-s} для получения экспортов:

\begin{verbatim}
rabin2 -s /bin/ls | head
[Symbols]

nth paddr       vaddr      bind   type   size lib name
------------------------------------------------------
110 0x000150a0 0x000150a0 GLOBAL FUNC 56 _obstack_allocated_p
111 0x0001f600 0x0021f600 GLOBAL  OBJ  8 program_name
112 0x0001f620 0x0021f620 GLOBAL  OBJ  8 stderr
113 0x00014f90 0x00014f90 GLOBAL FUNC 21 _obstack_begin_1
114 0x0001f600 0x0021f600   WEAK  OBJ  8 program_invocation_name
115 0x0001f5c0 0x0021f5c0 GLOBAL  OBJ  8 alloc_failed_handler
116 0x0001f5f8 0x0021f5f8 GLOBAL  OBJ  8 optarg
117 0x0001f5e8 0x0021f5e8 GLOBAL  OBJ  8 stdout
118 0x0001f5e0 0x0021f5e0 GLOBAL  OBJ  8 program_short_name
\end{verbatim}

С опцией \texttt{-sr} rabin2 создает сценарий radare2. Позже он может
быть передан в ядро, чтобы автоматически помечать все символы и
определять соответствующие диапазоны байтов как функции и блоки данных.

\begin{verbatim}
$ rabin2 -sr /bin/ls | head
fs symbols
f sym.obstack_allocated_p 56 0x000150a0
f sym.program_invocation_name 8 0x0021f600
f sym.stderr 8 0x0021f620
f sym.obstack_begin_1 21 0x00014f90
f sym.program_invocation_name 8 0x0021f600
f sym.obstack_alloc_failed_handler 8 0x0021f5c0
f sym.optarg 8 0x0021f5f8
f sym.stdout 8 0x0021f5e8
f sym.program_invocation_short_name 8 0x0021f5e0
\end{verbatim}

\hypertarget{ux441ux43fux438ux441ux43eux43a-ux431ux438ux431ux43bux438ux43eux442ux435ux43a}{%
\subsection{Список
библиотек}\label{ux441ux43fux438ux441ux43eux43a-ux431ux438ux431ux43bux438ux43eux442ux435ux43a}}

Rabin2 перечисляет библиотеки, используемые двоичным файлом, параметр -
\texttt{-l}:

\begin{verbatim}
$ rabin2 -l `which r2`
[Linked libraries]
libr_core.so
libr_parse.so
libr_search.so
libr_cons.so
libr_config.so
libr_bin.so
libr_debug.so
libr_anal.so
libr_reg.so
libr_bp.so
libr_io.so
libr_fs.so
libr_asm.so
libr_syscall.so
libr_hash.so
libr_magic.so
libr_flag.so
libr_egg.so
libr_crypto.so
libr_util.so
libpthread.so.0
libc.so.6

22 libraries
\end{verbatim}

Давайте проверим вывод с помощью команды \texttt{ldd}:

\begin{verbatim}
$ ldd `which r2`
linux-vdso.so.1 (0x00007fffba38e000)
libr_core.so => /usr/lib64/libr_core.so (0x00007f94b4678000)
libr_parse.so => /usr/lib64/libr_parse.so (0x00007f94b4425000)
libr_search.so => /usr/lib64/libr_search.so (0x00007f94b421f000)
libr_cons.so => /usr/lib64/libr_cons.so (0x00007f94b4000000)
libr_config.so => /usr/lib64/libr_config.so (0x00007f94b3dfa000)
libr_bin.so => /usr/lib64/libr_bin.so (0x00007f94b3afd000)
libr_debug.so => /usr/lib64/libr_debug.so (0x00007f94b38d2000)
libr_anal.so => /usr/lib64/libr_anal.so (0x00007f94b2fbd000)
libr_reg.so => /usr/lib64/libr_reg.so (0x00007f94b2db4000)
libr_bp.so => /usr/lib64/libr_bp.so (0x00007f94b2baf000)
libr_io.so => /usr/lib64/libr_io.so (0x00007f94b2944000)
libr_fs.so => /usr/lib64/libr_fs.so (0x00007f94b270e000)
libr_asm.so => /usr/lib64/libr_asm.so (0x00007f94b1c69000)
libr_syscall.so => /usr/lib64/libr_syscall.so (0x00007f94b1a63000)
libr_hash.so => /usr/lib64/libr_hash.so (0x00007f94b185a000)
libr_magic.so => /usr/lib64/libr_magic.so (0x00007f94b164d000)
libr_flag.so => /usr/lib64/libr_flag.so (0x00007f94b1446000)
libr_egg.so => /usr/lib64/libr_egg.so (0x00007f94b1236000)
libr_crypto.so => /usr/lib64/libr_crypto.so (0x00007f94b1016000)
libr_util.so => /usr/lib64/libr_util.so (0x00007f94b0d35000)
libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f94b0b15000)
libc.so.6 => /lib64/libc.so.6 (0x00007f94b074d000)
libr_lang.so => /usr/lib64/libr_lang.so (0x00007f94b0546000)
libr_socket.so => /usr/lib64/libr_socket.so (0x00007f94b0339000)
libm.so.6 => /lib64/libm.so.6 (0x00007f94affaf000)
libdl.so.2 => /lib64/libdl.so.2 (0x00007f94afdab000)
/lib64/ld-linux-x86-64.so.2 (0x00007f94b4c79000)
libssl.so.1.0.0 => /usr/lib64/libssl.so.1.0.0 (0x00007f94afb3c000)
libcrypto.so.1.0.0 => /usr/lib64/libcrypto.so.1.0.0 (0x00007f94af702000)
libutil.so.1 => /lib64/libutil.so.1 (0x00007f94af4ff000)
libz.so.1 => /lib64/libz.so.1 (0x00007f94af2e8000)
\end{verbatim}

Если сравнить выходы \texttt{rabin2\ -l} и \texttt{ldd} видно, что
rabin2 перечисляет меньше библиотек, чем \texttt{ldd}. Причина в том,
что rabin2 не следует и не показывает зависимостей библиотек.
Отображаются только прямые двоичные зависимости.

\hypertarget{ux441ux442ux440ux43eux43aux438-1}{%
\subsection{Строки}\label{ux441ux442ux440ux43eux43aux438-1}}

Параметр \texttt{-z} используется для перечисления читаемых строк,
найденных в разделе ``.rodata'' двоичных файлов ELF и в разделе .text
файлов PE. Пример:

\begin{verbatim}
$ rabin2 -z /bin/ls | head
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
000 0x000160f8 0x000160f8  11  12 (.rodata) ascii dev_ino_pop
001 0x00016188 0x00016188  10  11 (.rodata) ascii sort_files
002 0x00016193 0x00016193   6   7 (.rodata) ascii posix-
003 0x0001619a 0x0001619a   4   5 (.rodata) ascii main
004 0x00016250 0x00016250  10  11 (.rodata) ascii ?pcdb-lswd
005 0x00016260 0x00016260  65  66 (.rodata) ascii # Configuration file for dircolors, a utility to help you set the
006 0x000162a2 0x000162a2  72  73 (.rodata) ascii # LS_COLORS environment variable used by GNU ls with the --color option.
007 0x000162eb 0x000162eb  56  57 (.rodata) ascii # Copyright (C) 1996-2018 Free Software Foundation, Inc.
008 0x00016324 0x00016324  70  71 (.rodata) ascii # Copying and distribution of this file, with or without modification,
009 0x0001636b 0x0001636b  76  77 (.rodata) ascii # are permitted provided the copyright notice and this notice are preserved.
\end{verbatim}

С параметром \texttt{-zr} эта информация представлена в виде списка
команд radare2. Его можно использовать в сеансе radare2 для
автоматического создания пространства флагов под названием «строки»,
предварительно заполненного флагами для всех строк, найденных rabin2.
Кроме того, этот сценарий будет помечать соответствующие диапазоны
байтов как строки, а не код.

\begin{verbatim}
$ rabin2 -zr /bin/ls | head
fs stringsf str.dev_ino_pop 12 @ 0x000160f8
Cs 12 @ 0x000160f8
f str.sort_files 11 @ 0x00016188
Cs 11 @ 0x00016188
f str.posix 7 @ 0x00016193
Cs 7 @ 0x00016193
f str.main 5 @ 0x0001619a
Cs 5 @ 0x0001619a
f str.pcdb_lswd 11 @ 0x00016250
Cs 11 @ 0x00016250
\end{verbatim}

\hypertarget{ux441ux435ux43aux446ux438ux438-ux43fux440ux43eux433ux440ux430ux43cux43c}{%
\subsection{Секции
программ}\label{ux441ux435ux43aux446ux438ux438-ux43fux440ux43eux433ux440ux430ux43cux43c}}

Rabin2, вызываемый с параметром \texttt{-S}, дает полную информацию о
разделах исполняемого файла. Для каждой секции отображаются индекс,
смещение, размер, выравнивание, тип и разрешения. Пример показывает
следующее:

\begin{verbatim}
$ rabin2 -S /bin/ls
[Sections]

nth paddr          size vaddr         vsize perm name
-----------------------------------------------------
00 0x00000000     0 0x00000000     0 ----
01 0x00000238    28 0x00000238    28 -r-- .interp
02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag
03 0x00000278   176 0x00000278   176 -r-- .gnu.hash
04 0x00000328  3000 0x00000328  3000 -r-- .dynsym
05 0x00000ee0  1412 0x00000ee0  1412 -r-- .dynstr
06 0x00001464   250 0x00001464   250 -r-- .gnu.version
07 0x00001560   112 0x00001560   112 -r-- .gnu.version_r
08 0x000015d0  4944 0x000015d0  4944 -r-- .rela.dyn
09 0x00002920  2448 0x00002920  2448 -r-- .rela.plt
10 0x000032b0    23 0x000032b0    23 -r-x .init
11 0x000032d0  1648 0x000032d0  1648 -r-x .plt
12 0x00003940    24 0x00003940    24 -r-x .plt.got
13 0x00003960 73931 0x00003960 73931 -r-x .text
14 0x00015a2c     9 0x00015a2c     9 -r-x .fini
15 0x00015a40 20201 0x00015a40 20201 -r-- .rodata
16 0x0001a92c  2164 0x0001a92c  2164 -r-- .eh_frame_hdr
17 0x0001b1a0 11384 0x0001b1a0 11384 -r-- .eh_frame
18 0x0001e390     8 0x0021e390     8 -rw- .init_array
19 0x0001e398     8 0x0021e398     8 -rw- .fini_array
20 0x0001e3a0  2616 0x0021e3a0  2616 -rw- .data.rel.ro
21 0x0001edd8   480 0x0021edd8   480 -rw- .dynamic
22 0x0001efb8    56 0x0021efb8    56 -rw- .got
23 0x0001f000   840 0x0021f000   840 -rw- .got.plt
24 0x0001f360   616 0x0021f360   616 -rw- .data
25 0x0001f5c8     0 0x0021f5e0  4824 -rw- .bss
26 0x0001f5c8   232 0x00000000   232 ---- .shstrtab
\end{verbatim}

С опцией \texttt{-Sr} rabin2 пометит начало/конец каждого раздела и
передаст остальную информацию как комментарий.

\begin{verbatim}
$ rabin2 -Sr /bin/ls | head
fs sections
"f section. 1 0x00000000"
"f section..interp 1 0x000002a8"
"f section..note.gnu.build_id 1 0x000002c4"
"f section..note.ABI_tag 1 0x000002e8"
"f section..gnu.hash 1 0x00000308"
"f section..dynsym 1 0x000003b8"
"f section..dynstr 1 0x00000fb8"
"f section..gnu.version 1 0x00001574"
"f section..gnu.version_r 1 0x00001678"
\end{verbatim}

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radiff2-1}{%
\section{Программа
Radiff2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-radiff2-1}}

Radiff2 - это инструмент, предназначенный для сравнения двоичных файлов,
подобно тому, как обычный \texttt{diff} сравнивает текстовые файлы.

\begin{verbatim}
$ radiff2 -h
Usage: radiff2 [-abBcCdjrspOxuUvV] [-A[A]] [-g sym] [-m graph_mode][-t %] [file] [file]
  -a [arch]  указать архитектурный плагин для использования (x86, arm, ..)
  -A [-A]    запустить aaa или aaaa после загрузки каждого бинарика (смотри -C)
  -b [bits]  указать размер регистров для архитектуры (16, 32, 64, ..)
  -B         вывод в двоичном diff (GDIFF)
  -c         количество изменений
  -C         выполнить сравнения графов управления (колонки: смещение-A, оценка сходства, смещение-B) (смотри -A)
  -d         использовать delta diffing
  -D         выводить дизассемблирование вместо шеснадцатеричного кода
  -e [k=v]   установить значение переменной среды для всех экземплярах RCore
  -g [sym|off1,off2]   сравнение графа заданного символа или двух смещений
  -G [cmd]   запустить команду r2 на каждом созданном экземпляре RCore
  -i         импортировать diff-ы  целевых файлов (смотри -u, -U и -z)
  -j         выводить результат в формте json
  -n         печатать только адреса (diff.bare=1)
  -m [aditsjJ]  выбрать режим вывода графа
  -O         производить сравнение между байтами оп-кодов
  -p         использовать физическую адресацию (io.va=0)
  -q         тихий режим (обесцетить вывод и его объем)
  -r         вывести результат в виде команд radare
  -s         вычислить расстояние редактирование (без подстановки, алгоритм  сравнения Eugene W. Myer O(ND))
  -ss        вычислить расстояние редактирование Левенштейна (замена разрешена, O(N^2))
  -S [name]  сортировать код diff (имя, длина имени, адрес, размер, тип, расстояние) (только для -C или -g)
  -t [0-100] установить порог для кода diff (по умолчанию 70%)
  -x         показать две колонки различий в шеснадцатеричном виде
  -X         показать две колонки различий hexII
  -u         унифицированный формат вывода (---+++)
  -U         унифицированный вывод, используя системный 'diff'
  -v         показать версию
  -V         больше информации (сейчас только для -s)
  -z         сравнение экстрагированных строк
  -Z         сравнение кода в виде сигнатур

Форматы вывода графа управления: (-m [mode])
  <blank/a>  Ascii-art
  s          команды r2
  d          Graphviz dot
  g          Graph Modelling Language (gml)
  j          json
  J          json с disarm
  k          SDB key-value
  t          Tiny ascii art
  i          Интерактивный ascii-art
\end{verbatim}

\hypertarget{ux431ux438ux43dux430ux440ux43dux43eux435-ux441ux440ux430ux432ux43dux435ux43dux438ux435}{%
\section{Бинарное
сравнение}\label{ux431ux438ux43dux430ux440ux43dux43eux435-ux441ux440ux430ux432ux43dux435ux43dux438ux435}}

Этот раздел основан на http://radare.today статье
``\href{https://radareorg.github.io/blog/posts/binary-diffing/}{двоичное
сравнение}''

Без параметров \texttt{radiff2} по умолчанию показывает, какие байты
изменены и соответствующие им смещения:

\begin{verbatim}
$ radiff2 genuine cracked      # оригинальный взломанный
0x000081e0 85c00f94c0 => 9090909090 0x000081e0
0x0007c805 85c00f84c0 => 9090909090 0x0007c805

$ rasm2 -d 85c00f94c0
test eax, eax
sete al
\end{verbatim}

Заметим, два перехода (jumps) заменены на nop-ы.

Для массовой обработки может потребоваться более высокоуровневый обзор
различий. Вот почему radare2 может вычислять расстояние и процент
сходства между двумя файлами с помощью опции \texttt{-s}:

\begin{verbatim}
$ radiff2 -s /bin/true /bin/false
similarity: 0.97
distance: 743
\end{verbatim}

Если нужны более конкретные данные, можно подсчитать различия с помощью
параметра \texttt{-c}:

\begin{verbatim}
$ radiff2 -c genuine cracked
2
\end{verbatim}

Если нет уверенности, похожи ли двоичные файлы, с флагом \texttt{-C}
можно проверить, есть ли соответствующие функции. В этом режиме, он даст
вам три столбца для всех функций: «Смещение первого файла», «Процент
совпадения» и «Смещение второго файла».

\begin{verbatim}
$ radiff2 -C /bin/false /bin/true
  entry0  0x4013e8 |   MATCH  (0.904762) | 0x4013e2  entry0
  sym.imp.__libc_start_main  0x401190 |   MATCH  (1.000000) | 0x401190  sym.imp.__libc_start_main
  fcn.00401196  0x401196 |   MATCH  (1.000000) | 0x401196  fcn.00401196
  fcn.0040103c  0x40103c |   MATCH  (1.000000) | 0x40103c  fcn.0040103c
  fcn.00401046  0x401046 |   MATCH  (1.000000) | 0x401046  fcn.00401046
  fcn.000045e0   24 0x45e0 | UNMATCH  (0.916667) | 0x45f0    24 fcn.000045f0
  ...
\end{verbatim}

Можно попросить radiff2 сначала выполнить анализ - флаг \texttt{-A}
запустит \texttt{aaa} на двоичных файлах. И мы можем указать архитектуру
двоичных файлов для этого анализа, используя

\begin{verbatim}
$ radiff2 -AC -a x86 /bin/true /bin/false | grep UNMATCH
[x] Анализировать все флаги, начиная с sym. и entry0 (aa)
[x] Анализировать len байт инструкций на ссылки (aar)
[x] Анализировать вызовы функций (aac)
[ ] [*] Использование -AA или aaaa запускают дополнительные экспериментальные алгоритмы анализа.
[x] Создание имен функций для fcn.* и sym.func.* (aan))
[x] Анализировать все флаги, начиная с sym. и entry0 (aa)
[x] Анализировать len байт инструкций на ссылки (aar)
[x] Анализировать вызовы функций (aac)
[ ] [*] Использование -AA или aaaa запускают дополнительные экспериментальные алгоритмы анализа.
[x] Создание имен функций для fcn.* и sym.func.* (aan))
                        sub.fileno_500   86 0x4500 | UNMATCH  (0.965116) | 0x4510    86 sub.fileno_510
                    sub.__freading_4c0   59 0x44c0 | UNMATCH  (0.949153) | 0x44d0    59 sub.__freading_4d0
                        sub.fileno_440  120 0x4440 | UNMATCH  (0.200000) | 0x4450   120 sub.fileno_450
                     sub.setlocale_fa0   64 0x3fa0 | UNMATCH  (0.104651) | 0x3fb0    64 sub.setlocale_fb0
                          fcn.00003a50  120 0x3a50 | UNMATCH  (0.125000) | 0x3a60   120 fcn.00003a60
\end{verbatim}

Теперь классная функция - radare2 поддерживает сравнения графов, как в
\href{http://www.darungrim.org/}{DarunGrim}, флаг - \texttt{-g}. Можно
присвоить имя символа, указав два смещения, если функция, которую вы
хотите сравнить, называется по-разному в сравниваемых файлах. Например,
\texttt{radiff2\ -md\ -g\ main\ /bin/true\ /bin/false\ \textbar{}\ xdot\ -}
покажет различия в функции \texttt{main()} программ Unix \texttt{true} и
\texttt{false}. Можно сравнить его с
\texttt{radiff2\ -md\ -g\ main\ /bin/false\ /bin/true\ \textbar{}\ xdot\ -}
(обратите внимание на порядок аргументов), чтобы получить две версии.
Вот, что из этого получилось:

\begin{figure}
\centering
\includegraphics{img/true_false2.png}
\caption{/bin/true против /bin/false}
\end{figure}

Части желтого цвета указывают, что некоторые смещения не совпадают.
Серый кусок означает идеальное соответствие. Оранжевый подчеркивает
сильную разницу. Если присмотреться, то увидим, что в левой части
картинки есть \texttt{mov\ eax,\ 0x1;\ pop\ rbx;\ pop\ rbp;\ ret}, а в
правой части - \texttt{xor\ edx,\ edx;\ pop\ rbx;\ pop\ rbp;\ ret}.

Двоичное сравнение является важной функцией для обратного
проектирования. Его можно использовать для анализа
\href{https://en.wikipedia.org/wiki/Patch_Tuesday}{обновлений
безопасности}, зараженных двоичных файлов, изменений прошивки и многого
другого\ldots{}

Мы показали только функции анализа кода, но radare2 поддерживает
дополнительные типы сравнения между двумя двоичными файлами: на уровне
байтов, дельтифицированные сходства и многое другое в будущем.

Есть планы по внедрению большего количества видов алгоритмов в r2:
добавить поддержку дифференциации ASCII-арт-графов и лучшую интеграцию с
остальной частью инструментария.

\hypertarget{ux443ux442ux438ux43bux438ux442ux430-rasm2}{%
\section{Утилита
Rasm2}\label{ux443ux442ux438ux43bux438ux442ux430-rasm2}}

Программа \texttt{rasm2} является ассемблером/дизассемблером. Изначально
инструмент \texttt{rasm} разработан для внесения исправлений (patching)
в двоичный файл. Основная функция заключается в получении кодов байтов,
соответствующих заданной машинной инструкции (оп-кода).

\begin{verbatim}
$ rasm2 -h
Usage: rasm2 [-ACdDehLBvw] [-a arch] [-b bits] [-o addr] [-s syntax]
             [-f file] [-F fil:ter] [-i skip] [-l len] 'code'|hex|-
 -a [arch]    Задать архитектуру для процедур ассемблирования/дисассемблирования (смотрите -L)
 -A           Показать результаты анализа заданных шеснадцатеричных кодов
 -b [bits]    Задать разрядность регистров процессора (8, 16, 32, 64) (RASM2_BITS)
 -B           Вывод/ввод в двоичном виде (-l обязателен для двоичного вывода)
 -c [cpu]     Задать конкретный CPU (зависит от архитектуры)
 -C           Вывод в формате C
 -d, -D       Дизассемблировать из шестнадцатеричных кодов байтов (-D показывать оп-коды)
 -e           Задать прямой порядок (big endian) вместо обратного (little endian) порядок байтов
 -E           Выводить ESIL-выражения (вход тот же как в -d)
 -f [file]    Прочитать данные из файла
 -F [in:out]  Задать входной и/или выходной фильтр (att2intel, x86.pseudo, ...)
 -h, -hh      Показать данное сообщение, -hh дает больше информации
 -i [len]     Игнорировать/пропустить len байт входных данных
 -j           Выводить в формате json
 -k [kernel]  Задать операционную систему  (linux, windows, darwin, ..)
 -l [len]     Длина ввода/вывода
 -L           Перечислить плагины Asm: (a-ассемлирование, d-дизассемблирование, A-анализ, e-ESIL)
 -o [offset]  Задать начальное смещение (по умлочанию 0)
 -O [file]    Имя выходного файла (rasm2 -Bf a.asm -O a)
 -p           Выполнить SPP над входными данными для ассемблирования
 -q           "Тихий" режим
 -r           Представить результат в виде команд radare
 -s [syntax]  Задать синтаксис (intel, att)
 -v           Показать информацию о версии
 -w           Описание семантики оп-кода (что делает инструкция)
 Если значение '-l' больше длины вывода, вывод заполняется nop-ами
 Если последний аргумент '-' читается из stdin
Переменные среды:
 RASM2_NOPLUGINS  Не загружать динамические плагины (ускорение загрузки)
 RASM2_ARCH       То же, что и rasm2 -a
 RASM2_BITS       То же, что и rasm2 -b
 R_DEBUG          Отображать ли сообщения об ошибках и сигнал о сбое
\end{verbatim}

Плагины для поддерживаемых архитектур перечисляются, используя флаг
\texttt{-L}. Используемый плагин указывается именем в флаге \texttt{-a}

\begin{verbatim}
$ rasm2 -L
_dAe  8 16       6502        LGPL3   6502/NES/C64/Tamagotchi/T-1000 CPU
_dAe  8          8051        PD      8051 Intel CPU
_dA_  16 32      arc         GPL3    Argonaut RISC Core
a___  16 32 64   arm.as      LGPL3   as ARM Assembler (use ARM_AS environment)
adAe  16 32 64   arm         BSD     Capstone ARM disassembler
_dA_  16 32 64   arm.gnu     GPL3    Acorn RISC Machine CPU
_d__  16 32      arm.winedbg LGPL2   WineDBG's ARM disassembler
adAe  8 16       avr         GPL     AVR Atmel
adAe  16 32 64   bf          LGPL3   Brainfuck (by pancake, nibble) v4.0.0
_dA_  32         chip8       LGPL3   Chip8 disassembler
_dA_  16         cr16        LGPL3   cr16 disassembly plugin
_dA_  32         cris        GPL3    Axis Communications 32-bit embedded processor
adA_  32 64      dalvik      LGPL3   AndroidVM Dalvik
ad__  16         dcpu16      PD      Mojang's DCPU-16
_dA_  32 64      ebc         LGPL3   EFI Bytecode
adAe  16         gb          LGPL3   GameBoy(TM) (z80-like)
_dAe  16         h8300       LGPL3   H8/300 disassembly plugin
_dAe  32         hexagon     LGPL3   Qualcomm Hexagon (QDSP6) V6
_d__  32         hppa        GPL3    HP PA-RISC
_dAe             i4004       LGPL3   Intel 4004 microprocessor
_dA_  8          i8080       BSD     Intel 8080 CPU
adA_  32         java        Apache  Java bytecode
_d__  32         lanai       GPL3    LANAI
_d__  8          lh5801      LGPL3   SHARP LH5801 disassembler
_d__  32         lm32        BSD     disassembly plugin for Lattice Micro 32 ISA
_dA_  16 32      m68k        BSD     Capstone M68K disassembler
_dA_  32         malbolge    LGPL3   Malbolge Ternary VM
_d__  16         mcs96       LGPL3   condrets car
adAe  16 32 64   mips        BSD     Capstone MIPS disassembler
adAe  32 64      mips.gnu    GPL3    MIPS CPU
_dA_  16         msp430      LGPL3   msp430 disassembly plugin
_dA_  32         nios2       GPL3    NIOS II Embedded Processor
_dAe  8          pic         LGPL3   PIC disassembler
_dAe  32 64      ppc         BSD     Capstone PowerPC disassembler
_dA_  32 64      ppc.gnu     GPL3    PowerPC
_d__  32         propeller   LGPL3   propeller disassembly plugin
_dA_  32 64      riscv       GPL     RISC-V
_dAe  32         rsp         LGPL3   Reality Signal Processor
_dAe  32         sh          GPL3    SuperH-4 CPU
_dA_  8 16       snes        LGPL3   SuperNES CPU
_dAe  32 64      sparc       BSD     Capstone SPARC disassembler
_dA_  32 64      sparc.gnu   GPL3    Scalable Processor Architecture
_d__  16         spc700      LGPL3   spc700, snes' sound-chip
_d__  32         sysz        BSD     SystemZ CPU disassembler
_dA_  32         tms320      LGPLv3  TMS320 DSP family (c54x,c55x,c55x+,c64x)
_d__  32         tricore     GPL3    Siemens TriCore CPU
_dAe  32         v810        LGPL3   v810 disassembly plugin
_dAe  32         v850        LGPL3   v850 disassembly plugin
_dAe  8 32       vax         GPL     VAX
adA_  32         wasm        MIT     WebAssembly (by cgvwzq) v0.1.0
_dA_  32         ws          LGPL3   Whitespace esotheric VM
a___  16 32 64   x86.as      LGPL3   Intel X86 GNU Assembler
_dAe  16 32 64   x86         BSD     Capstone X86 disassembler
a___  16 32 64   x86.nasm    LGPL3   X86 nasm assembler
a___  16 32 64   x86.nz      LGPL3   x86 handmade assembler
_dA_  16         xap         PD      XAP4 RISC (CSR)
_dA_  32         xcore       BSD     Capstone XCore disassembler
_dAe  32         xtensa      GPL3    XTensa CPU
adA_  8          z80         GPL     Zilog Z80
\end{verbatim}

\begin{quote}
Обратите внимание, что «ad» в первой колонке означает, что и ассемблер и
дизассемблер поддерживаются плагином. ``\emph{d'' - доступен только
дизассемблер, ''a}'' - доступен только ассемблер.
\end{quote}

\hypertarget{ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435}{%
\subsection{Ассемблирование}\label{ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux435}}

Ассемблирование преобразует инструкцию микропроцессора в
человекочитаемой форме в виде мнемоники в набор байтов, выполняемые
машиной. В radare2 ассемблирование и дизассемблирование реализованы в
API r\_asm\_*. Функции API запускаются командами \texttt{pa} и
\texttt{pad} из командной строки radare2, а также с помощью инструмента
\texttt{rasm2}.

Rasm2 используется для создания и вставки в блоки байтов
шестнадцатеричных кодов, представляющих машинную инструкцию. Следующая
строка собирает инструкцию mov для x86/32.

\begin{verbatim}
$ rasm2 -a x86 -b 32 'mov eax, 33'
b821000000
\end{verbatim}

Помимо указания входных данных в качестве аргумента rasm2, мнемоники
можно задавать в rasm2:

\begin{verbatim}
$ echo 'push eax;nop;nop' | rasm2 -f -
5090
\end{verbatim}

Как видно, rasm2 может собирать одну или несколько инструкций. В
командной строке мнемоники разделяются точкой с запятой \texttt{;}.
Мнемоники также можно загружать это из файла, основывающийся на
синтаксисе и директивах nasm/gas/\ldots{} Можно ознакомиться со
справочной страницей rasm2 для получения более подробной информации.

Команды \texttt{pa} и \texttt{pad} являются подкомандами печати, они
отображают результаты ассемблирования и дизассемблирования. Надо
сформировать и записать в блок данных инструкцию? - используйте команды
\texttt{wa} и \texttt{wx} с добавлением строки с мнемониками или байтов.

Ассемблер понимает различные диалекты ассемблера: \texttt{x86} (варианты
Intel и AT\&T), \texttt{olly} (синтаксис OllyDBG), \texttt{powerpc}
(PowerPC), \texttt{arm} и \texttt{java}. Для синтаксиса Intel rasm2
имитирует NASM и GAS.

В репозитории исходного кода rasm2 содержат несколько примеров
реализации функций ассемблирования. Ознакомьтесь с ними, посмотрите, как
реализуется ассемблирование в двоичный блок данных и в файл.

Создадим двоичный файл с именем \texttt{selfstop.rasm} из мнемоник
ассемблера:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{;}
\CommentTok{; Шелл{-}код запуска системного выхова, останавливающего программу. }
\CommentTok{; Код представлен в диалекте rasm для x86.}
\CommentTok{;}
\CommentTok{; {-}{-} Автор {-} pancake}
\CommentTok{;}

\NormalTok{.arch x86}
\NormalTok{.}\PreprocessorTok{equ}\NormalTok{ base }\BaseNTok{0x8048000}
\NormalTok{.}\BuiltInTok{org} \BaseNTok{0x8048000}  \CommentTok{; смещение, куда мы вставим 5 байт jmp{-}а}

\FunctionTok{selfstop:}
  \BuiltInTok{push} \BaseNTok{0x8048000}
  \BuiltInTok{pusha}
  \BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \DecValTok{20}
  \BuiltInTok{int} \BaseNTok{0x80}

  \BuiltInTok{mov} \KeywordTok{ebx}\OperatorTok{,} \KeywordTok{eax}
  \BuiltInTok{mov} \KeywordTok{ecx}\OperatorTok{,} \DecValTok{19}
  \BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \DecValTok{37}
  \BuiltInTok{int} \BaseNTok{0x80}
  \BuiltInTok{popa}
  \ControlFlowTok{ret}
\CommentTok{;}
\CommentTok{; Вставка системного вызова}
\CommentTok{;}

  \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

Теперь можно собрать его ``на месте'' (in place):

\begin{verbatim}
[0x00000000]> e asm.bits = 32
[0x00000000]> wx `!rasm2 -f a.rasm`
[0x00000000]> pd 20
       0x00000000    6800800408   push 0x8048000 ;  0x08048000
       0x00000005    60           pushad
       0x00000006    b814000000   mov eax, 0x14 ;  0x00000014
       0x0000000b    cd80         int 0x80
          syscall[0x80][0]=?
       0x0000000d    89c3         mov ebx, eax
       0x0000000f    b913000000   mov ecx, 0x13 ;  0x00000013
       0x00000014    b825000000   mov eax, 0x25 ;  0x00000025
       0x00000019    cd80         int 0x80
          syscall[0x80][0]=?
       0x0000001b    61           popad
       0x0000001c    c3           ret
       0x0000001d    c3           ret
\end{verbatim}

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c-1}{%
\subsubsection{Визуальный
режим}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c-1}}

Ассемблирование также доступно в визуальном режиме radare2 по нажатию
клавиши \texttt{A} - вставка генерированного кода по адресу смещения.
Функция ассемблирования в визуальном режиме не вносит изменения в
память, пока не будет нажат enter - это замечательное ее свойство! Таким
образом, можно проверить размер кода и то, какие инструкции
перекрываются, прежде чем фиксировать изменения.

\hypertarget{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440}{%
\subsection{Дизассемблер}\label{ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440}}

Дизассемблирование --- это обратное действие ассемблированию. Rasm2
принимает шестнадцатеричный код в качестве входных данных (но также
может принимать файл в двоичной форме) и показывает человекочитаемую
форму инструкций в виде мнемоник.

Для этого в программе rasm2 используется флаг \texttt{-d}:

\begin{verbatim}
$ rasm2 -a x86 -b 32 -d '90'
nop
\end{verbatim}

В Rasm2 есть флаг \texttt{-D}, добавляющий к результату
дизассемблирования \texttt{-d} смещения и байты. Флагами управляется
также выполнение дизассемблирования блоков данных из заданного места в
памяти. Флаги позволяют генерировать варианты дизассемблирования для
последующего синтаксического анализа внешними скриптами, фильтровать
grep-ом требуемой информации:

\hypertarget{pd-n}{%
\subsubsection{pd N}\label{pd-n}}

Дизассемблировать N инструкций

\hypertarget{pd-n-1}{%
\subsubsection{pD N}\label{pd-n-1}}

Дизассемблировать N байт

\hypertarget{pda}{%
\subsubsection{pda}\label{pda}}

Дизассемблировать все инструкции (смещаясь на 1 байт или минимальный
размер инструкции выравнивания), что полезно для ROP

\hypertarget{pi-pi}{%
\subsection{pi, pI}\label{pi-pi}}

То же самое, что \texttt{pd} и \texttt{pD}, но с использованием более
простого вывода.

\hypertarget{ux43aux43eux43dux444ux438ux433ux443ux440ux438ux440ux43eux432ux430ux43dux438ux435-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}{%
\subsection{Конфигурирование
дизассемблера}\label{ux43aux43eux43dux444ux438ux433ux443ux440ux438ux440ux43eux432ux430ux43dux438ux435-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux435ux440ux430}}

Функционирование ассемблера и дизассемблера настраиваются множеством
переменных настройки. Конфигурация доступна с помощью команды
\texttt{e}. Вот наиболее распространенные из них:

\begin{itemize}
\tightlist
\item
  asm.bytes - показать/скрыть байты
\item
  asm.offset - показать/скрыть смещение
\item
  asm.lines - показать/скрыть номера строк
\item
  asm.ucase - показать дизассемблированный код в верхнем регистре
\item
  \ldots{}
\end{itemize}

Используйте \texttt{e??asm.} для получения более подробной информации.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-ragg2-1}{%
\section{Программа
ragg2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-ragg2-1}}

Название ragg2 расшифровывается как \texttt{radare2\ egg}, это основной
блок для построения перемещаемых фрагментов кода, используемых для
внедрения в целевые процессы при эксплуатации.

Программа ragg2 компилирует программы на простом языке высокого уровня в
маленькие двоичные файлы для архитектур x86, x86-64 и ARM.

По умолчанию он будет компилировать свой собственный язык
\texttt{ragg2}, но также можно скомпилировать и C-код, используя GCC или
Clang в шелл-код в зависимости от расширения файла. Создадим C-файл под
названием \texttt{a.c}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    write}\OperatorTok{(}\DecValTok{1}\OperatorTok{,} \StringTok{"Hello World}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{13}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$ ragg2 -a x86 -b32 a.c
e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00

$ rasm2 -a x86 -b 32 -D e900000000488d3516000000bf01000000b80400000248c7c20d0000000f0531c0c348656c6c6f20576f726c640a00
0x00000000   5               e900000000  jmp 5
0x00000005   1                       48  dec eax
0x00000006   6             8d3516000000  lea esi, [0x16]
0x0000000c   5               bf01000000  mov edi, 1
0x00000011   5               b804000002  mov eax, 0x2000004
0x00000016   1                       48  dec eax
0x00000017   6             c7c20d000000  mov edx, 0xd
0x0000001d   2                     0f05  syscall
0x0000001f   2                     31c0  xor eax, eax
0x00000021   1                       c3  ret
0x00000022   1                       48  dec eax
0x00000023   2                     656c  insb byte es:[edi], dx
0x00000025   1                       6c  insb byte es:[edi], dx
0x00000026   1                       6f  outsd dx, dword [esi]
0x00000027   3                   20576f  and byte [edi + 0x6f], dl
0x0000002a   2                     726c  jb 0x98
0x0000002c   3                   640a00  or al, byte fs:[eax]
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux440-ux43aux43eux43cux43fux438ux43bux44fux446ux438ux438-ragg2}{%
\subsection{Пример компиляции
ragg2}\label{ux43fux440ux438ux43cux435ux440-ux43aux43eux43cux43fux438ux43bux44fux446ux438ux438-ragg2}}

\begin{verbatim}
$ cat hello.r
exit@syscall(1);

main@global() {
    exit(2);
}

$ ragg2 -a x86 -b 64 hello.r
48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   1                       48  dec eax
0x00000001   6             c7c002000000  mov eax, 2
0x00000007   1                       50  push eax
0x00000008   1                       48  dec eax
0x00000009   3                   8b3c24  mov edi, dword [esp]
0x0000000c   1                       48  dec eax
0x0000000d   6             c7c001000000  mov eax, 1
0x00000013   2                     0f05  syscall
0x00000015   1                       48  dec eax
0x00000016   3                   83c408  add esp, 8
0x00000019   1                       c3  ret

$ rasm2 -a x86 -b 64 -D 48c7c00200000050488b3c2448c7c0010000000f054883c408c3
0x00000000   7           48c7c002000000  mov rax, 2
0x00000007   1                       50  push rax
0x00000008   4                 488b3c24  mov rdi, qword [rsp]
0x0000000c   7           48c7c001000000  mov rax, 1
0x00000013   2                     0f05  syscall
0x00000015   4                 4883c408  add rsp, 8
0x00000019   1                       c3  ret
\end{verbatim}

\hypertarget{ux43cux430ux43bux435ux43dux44cux43aux438ux435-ux434ux432ux43eux438ux447ux43dux44bux435-ux444ux430ux439ux43bux44b}{%
\subsection{Маленькие двоичные
файлы}\label{ux43cux430ux43bux435ux43dux44cux43aux438ux435-ux434ux432ux43eux438ux447ux43dux44bux435-ux444ux430ux439ux43bux44b}}

Файлы создаются, используя флаг \texttt{-F} в ragg2 и \texttt{-C} в
rabin2.

\hypertarget{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux44fux437ux44bux43aux430}{%
\section{Синтаксис
языка}\label{ux441ux438ux43dux442ux430ux43aux441ux438ux441-ux44fux437ux44bux43aux430}}

Код r\_egg компилируется однопроходным компилятором. Необходимо, в
частности, определить правильный размер фрейма стека функции во
избежание ошибок компиляции.

Компилятор генерирует ассемблерный код для x86-\{32,64\} и ARM. Также
преследуется цель поддержать большее количество платформ. Этот код
компилируется с помощью r\_asm и формирует маленький двоичный файл с
r\_bin.

Можно использовать r\_egg для создания автономных двоичных файлов, не
зависящих от смещения, оп-кодов для инъекций в запущенные процессы и в
двоичные файлы на диске.

Сгенерированный код не оптимизирован, но безопасен для выполнения.

\hypertarget{ux43fux440ux435ux43fux440ux43eux446ux435ux441ux441ux43eux440}{%
\subsection{Препроцессор}\label{ux43fux440ux435ux43fux440ux43eux446ux435ux441ux441ux43eux440}}

\hypertarget{ux43fux441ux435ux432ux434ux43eux43dux438ux43cux44b-1}{%
\subsubsection{Псевдонимы}\label{ux43fux441ux435ux432ux434ux43eux43dux438ux43cux44b-1}}

Иногда во время компиляции нужно заменить одну сущность в нескольких
местах. Псевдонимы переводятся в операторы `equ' в сборке языка, т.е.
эти переопределения делаются при помощи ключевых слов на уровне
ассемблера.

\texttt{AF\_INET@alias(2);}

\texttt{printf@alias(0x8053940);}

\hypertarget{ux432ux43aux43bux44eux447ux435ux43dux438ux44f-ux432-ux442ux435ux43aux441ux442}{%
\subsubsection{Включения в
текст}\label{ux432ux43aux43bux44eux447ux435ux43dux438ux44f-ux432-ux442ux435ux43aux441ux442}}

Используйте \texttt{cat(1)} или препроцессор для объединения нескольких
скомпилированных файлов.

\texttt{INCDIR@alias("/usr/include/ragg2");}

\texttt{sys-osx.r@include(INCDIR);}

\hypertarget{ux445ux430ux448ux431ux430ux43dux433}{%
\subsubsection{Хашбанг}\label{ux445ux430ux448ux431ux430ux43dux433}}

Можно использовать хэшбанг, чтобы сделать сгенерированные файлы (eggs)
исполняемыми.

\texttt{\$\ head\ -n1\ hello.r}

\texttt{\#!/usr/bin/ragg2\ -X}

\texttt{\$\ ./hello.r}

\texttt{Hello\ World!}

\hypertarget{main}{%
\subsubsection{Main}\label{main}}

Кода выполняется последовательно: первая определенная функция будет
исполняться первой. Если надо запустить main() просто пишите исходный
код в следующей форме:

\texttt{\#!/usr/bin/ragg2\ -X}

\texttt{main();}

\texttt{...}

\texttt{main@global(128,64)\ \{}

\texttt{...}

\hypertarget{ux43eux43fux440ux435ux434ux435ux43bux435ux43dux438ux435-ux444ux443ux43dux43aux446ux438ux438}{%
\subsubsection{Определение
функции}\label{ux43eux43fux440ux435ux434ux435ux43bux435ux43dux438ux435-ux444ux443ux43dux43aux446ux438ux438}}

Если надо разделить свой код на несколько блоков. Блоки кода привязаны к
метке, за которой следуют скобки `\{ \ldots{} \}'.

\hypertarget{ux441ux438ux433ux43dux430ux442ux443ux440ux44b-ux444ux443ux43dux43aux446ux438ux439}{%
\subsubsection{Сигнатуры
функций}\label{ux441ux438ux433ux43dux430ux442ux443ux440ux44b-ux444ux443ux43dux43aux446ux438ux439}}

\texttt{name@type(stackframesize,staticframesize)\ \{\ body\ \}},

\texttt{name} : имя определяемой функции,

\texttt{type} : см. типы функций ниже,

\texttt{stackframesize} : получение пространства из стека для хранения
локальных переменных,

\texttt{staticframesize} : получение пространства из стека для хранения
статических переменных (strings),

\texttt{body} : код функции.

\hypertarget{ux442ux438ux43fux44b-ux444ux443ux43dux43aux446ux438ux439}{%
\subsubsection{Типы
функций}\label{ux442ux438ux43fux44b-ux444ux443ux43dux43aux446ux438ux439}}

\texttt{alias} Используется для создания псевдонимов,

\texttt{data} ; тело блока определяется в .data,

\texttt{inline} ; тело функции встраивается в вызывающий код (inlined)
при вызове,

\texttt{global} ; сделать символ глобальным,

\texttt{fastcall} ; функция, вызываемая с помощью соглашения о быстром
вызове,

\texttt{syscall} ; определение соглашения о вызове для системного
вызова.

\hypertarget{ux441ux438ux441ux442ux435ux43cux43dux44bux435-ux432ux44bux437ux43eux432ux44b-1}{%
\subsubsection{Системные
вызовы}\label{ux441ux438ux441ux442ux435ux43cux43dux44bux435-ux432ux44bux437ux43eux432ux44b-1}}

Программа r\_egg предлагает синтаксический сахар для определения
системных вызовов. Синтаксис выглядит следующим образом:

\texttt{exit@syscall(1);}

\texttt{@syscall()\ \{}

`\texttt{:\ mov\ eax,}.arg```

\texttt{:\ int\ 0x80}

\texttt{\}}

\texttt{main@global()\ \{}

\texttt{exit\ (0);}

\texttt{\}}

\hypertarget{ux431ux438ux431ux43bux438ux43eux442ux435ux43aux438}{%
\subsubsection{Библиотеки}\label{ux431ux438ux431ux43bux438ux43eux442ux435ux43aux438}}

На данный момент отсутствует поддержка связывания r\_egg программ с
системными библиотеками. Но если вы вставляете код в программу
(диск/память), нужно определить адрес каждой функции, используя
синтаксис @alias.

\hypertarget{ux43eux441ux43dux43eux432ux43dux430ux44f-ux431ux438ux431ux43bux438ux43eux442ux435ux43aux430}{%
\subsubsection{Основная
библиотека}\label{ux43eux441ux43dux43eux432ux43dux430ux44f-ux431ux438ux431ux43bux438ux43eux442ux435ux43aux430}}

Ведется разработка библиотеки, похожую на библиотеку libc, полностью
реализованную на r\_egg.

\hypertarget{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-1}{%
\subsubsection{Переменные}\label{ux43fux435ux440ux435ux43cux435ux43dux43dux44bux435-1}}

\texttt{.arg}

\texttt{.arg0}

\texttt{.arg1}

\texttt{.arg2}

\texttt{.var0}

\texttt{.var2}

\texttt{.fix}

\texttt{.ret\ ;\ eax\ for\ x86,\ r0\ for\ arm}

\texttt{.bp}

\texttt{.pc}

\texttt{.sp}

\textbf{Внимание:} Все числа после \texttt{.var} и \texttt{.arg}
означают смещение относительно верхней части стека, они не являются
частями имен переменных.

\hypertarget{ux43cux430ux441ux441ux438ux432ux44b}{%
\subsubsection{Массивы}\label{ux43cux430ux441ux441ux438ux432ux44b}}

Поддерживается в виде raw-указателей. TODO: улучшить эту функцию.

\hypertarget{ux43eux442ux441ux43bux435ux436ux438ux432ux430ux43dux438ux435}{%
\subsubsection{Отслеживание}\label{ux43eux442ux441ux43bux435ux436ux438ux432ux430ux43dux438ux435}}

Иногда r\_egg-программы ломаются или просто не работают так, как
ожидалось. Используйте архитектуру `trace', чтобы получить трассировку
вызова arch-backend:

\texttt{\$\ ragg2\ -a\ trace\ -s\ yourprogram.r}

\hypertarget{ux443ux43aux430ux437ux430ux442ux435ux43bux438}{%
\subsubsection{Указатели}\label{ux443ux43aux430ux437ux430ux442ux435ux43bux438}}

TODO: Теоретически `*' используется для получения содержимого указателя
памяти.

\hypertarget{ux432ux438ux440ux442ux443ux430ux43bux44cux43dux44bux435-ux440ux435ux433ux438ux441ux442ux440ux44b}{%
\subsubsection{Виртуальные
регистры}\label{ux432ux438ux440ux442ux443ux430ux43bux44cux43dux44bux435-ux440ux435ux433ux438ux441ux442ux440ux44b}}

TODO: a0, a1, a2, a3, sp, fp, bp, pc

\hypertarget{ux43cux430ux442ux435ux43cux430ux442ux438ux447ux435ux441ux43aux438ux435-ux43eux43fux435ux440ux430ux446ux438ux438}{%
\subsubsection{Математические
операции}\label{ux43cux430ux442ux435ux43cux430ux442ux438ux447ux435ux441ux43aux438ux435-ux43eux43fux435ux440ux430ux446ux438ux438}}

Ragg2 поддерживает присвоение локальным переменным результатов
математических операций, в том числе следующие операторы:

\texttt{+} \texttt{-} \texttt{*} \texttt{/} \texttt{\&}
\texttt{\textbar{}} \texttt{\^{}}

\hypertarget{ux432ux43eux437ux432ux440ux430ux449ux430ux435ux43cux44bux435-ux437ux43dux430ux447ux435ux43dux438ux44f}{%
\subsubsection{Возвращаемые
значения}\label{ux432ux43eux437ux432ux440ux430ux449ux430ux435ux43cux44bux435-ux437ux43dux430ux447ux435ux43dux438ux44f}}

Возвращаемое значение хранится в регистре a0, этот регистр
устанавливается в результате вызова функции, или при использованиии
переменной без присвоения.

\begin{verbatim}
$ cat test.r
add@global(4) {
    .var0 = .arg0 + .arg1;
    .var0;
}

main@global() {
    add (3,4);
}

$ ragg2 -F -o test test.r
$ ./test
$ echo $?
7
\end{verbatim}

\hypertarget{ux43bux43eux432ux443ux448ux43aux438-traps}{%
\subsubsection{Ловушки
(traps)}\label{ux43bux43eux432ux443ux448ux43aux438-traps}}

Каждая архитектура имеет отдельную инструкцию для прерывания выполнения
программы. Язык REgg использует функцию `break()' для запуска emit\_trap
- обратный вызов для выбранной архитектуры. Функция \texttt{break()};
--\textgreater{} компилируется в `int3' на x86, \texttt{break;}
--\textgreater{} компилируется в `int3' на x86.

\hypertarget{ux432ux441ux442ux440ux43eux435ux43dux43dux44bux439-ux430ux441ux441ux435ux43cux431ux43bux435ux440}{%
\subsubsection{Встроенный
ассемблер}\label{ux432ux441ux442ux440ux43eux435ux43dux43dux44bux439-ux430ux441ux441ux435ux43cux431ux43bux435ux440}}

Строки с префиксом `:' просто встроены в выходной файл.

\texttt{:\ jmp\ 0x8048400}

\texttt{:\ .byte\ 33,44}

\hypertarget{ux43cux435ux442ux43aux438}{%
\subsubsection{Метки}\label{ux43cux435ux442ux43aux438}}

Метки определяются, используя ключевое слово \texttt{:}, следующим
образом:

\texttt{:label\_name:},

\texttt{/*\ бесконечный\ цикл\ */},

\texttt{goto(label\_name}).

\hypertarget{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux438ux441ux43fux43eux43bux43dux435ux43dux438ux435ux43c}{%
\subsubsection{Управление
исполнением}\label{ux443ux43fux440ux430ux432ux43bux435ux43dux438ux435-ux438ux441ux43fux43eux43bux43dux435ux43dux438ux435ux43c}}

\texttt{goto\ (addr)} -- ветвление,

\texttt{while\ (cond)},

\texttt{if\ (cond)},

\texttt{if\ (cond)\ \{\ body\ \}\ else\ \{\ body\ \}},

\texttt{break\ ()} -- выполняет инструкцию trap.

\hypertarget{ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux438}{%
\subsubsection{Комментарии}\label{ux43aux43eux43cux43cux435ux43dux442ux430ux440ux438ux438}}

Поддерживаемый синтаксис для комментариев:

\texttt{/*\ многострочный\ комментарий\ */\textquotesingle{}},

\texttt{//\ однострочный\ комментарий},

\texttt{\#\ однострочный\ комментарий}.

\hypertarget{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rahash2-1}{%
\section{Программа
rahash2}\label{ux43fux440ux43eux433ux440ux430ux43cux43cux430-rahash2-1}}

Инструмент rahash2 можно использовать для вычисления контрольных сумм
файлов, блоков данных дисковых устройств и строк. Реализовано множество
различных хэш-алгоритмов. Также можно выполнять некоторые операции
кодирования / декодирования, такие как шифрование base64 и xor
(гаммирование).

Вот пример использования:

\begin{verbatim}
$ rahash2 -a md5 -s "hello world"
\end{verbatim}

Обратите внимание, что rahash2 также позволяет считывать из stdin в
потоке, поэтому не нужно выделять 4 ГБ оперативной памяти для вычисления
хэша файла размером 4 ГБ.

\hypertarget{ux431ux43bux43eux447ux43dux43eux435-ux445ux435ux448ux438ux440ux43eux432ux430ux43dux438ux435}{%
\subsection{Блочное
хеширование}\label{ux431ux43bux43eux447ux43dux43eux435-ux445ux435ux448ux438ux440ux43eux432ux430ux43dux438ux435}}

При проведении сравнения больших объемов файлов полезно вычислять
частичные контрольные суммы. При этом файл разделяется на небольшие
части, которые легче идентифицировать по содержимому. Аналогично
содержимое раздела диска разбивается на блоки, затем хешируются, и по
значениям хэшей далее можно проводить сравнение. Если обнаружено два
блока с один и тем же хэшем, то весьма вероятно содержание этих блоков
будет одно и то же. Очень часто таким образом идентифицируются блоки с
нулевыми значениями. Блочное хэширование удобно для определения того,
какие блоки изменились. Также инструмент удобно при анализе дампов
оперативной памяти с виртуальной машины.

Построение блочного хэша делается при помощи команды, аналогичной

\begin{verbatim}
$ rahash2 -B 1M -b -a sha256 /bin/ls
\end{verbatim}

\hypertarget{ux445ux435ux448ux438ux440ux43eux432ux430ux43dux438ux435-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-rabin2}{%
\subsection{Хеширование при помощи
rabin2}\label{ux445ux435ux448ux438ux440ux43eux432ux430ux43dux438ux435-ux43fux440ux438-ux43fux43eux43cux43eux449ux438-rabin2}}

Инструмент rabin2 анализирует двоичные заголовки файлов, но он также
может использовать плагины rhash для вычисления контрольной суммы
разделов в двоичном файле.

\begin{verbatim}
$ rabin2 -K md5 -S /bin/ls
\end{verbatim}

\hypertarget{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux445ux44dux448ux435ux439-ux432-ux441ux435ux430ux43dux441ux435-radare2}{%
\subsection{Получение хэшей в сеансе
radare2}\label{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux445ux44dux448ux435ux439-ux432-ux441ux435ux430ux43dux441ux435-radare2}}

Вычисление контрольной суммы текущего блока при запуске radare2 -
команда \texttt{ph}. Название алгоритма передается в качестве параметра.
Пример сеанса:

\begin{verbatim}
$ radare2 /bin/ls
[0x08049790]> bf entry0
[0x08049790]> ph md5
d2994c75adaa58392f953a448de5fba7
\end{verbatim}

Можно использовать все алгоритмы хеширования, поддерживаемые
\texttt{rahash2}:

\begin{verbatim}
[0x00000000]> ph?
md5
sha1
sha256
sha384
sha512
md4
xor
xorpair
parity
entropy
hamdist
pcprint
mod255
xxhash
adler32
luhn
crc8smbus
crc15can
crc16
crc16hdlc
crc16usb
crc16citt
crc24
crc32
crc32c
crc32ecma267
crc32bzip2
crc32d
crc32mpeg2
crc32posix
crc32q
crc32jamcrc
crc32xfer
crc64
crc64ecma
crc64we
crc64xz
crc64iso
\end{verbatim}

Команда \texttt{ph} принимает необязательный числовой аргумент для
указания длины блока байтов, подлежащего хэшированию, параметр изменит
размер блока по умолчанию. Например:

\begin{verbatim}
[0x08049A80]> ph md5 32
9b9012b00ef7a94b5824105b7aaad83b
[0x08049A80]> ph md5 64
a71b087d8166c99869c9781e2edcf183
[0x08049A80]> ph md5 1024
a933cc94cd705f09a41ecc80c0041def
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-6}{%
\subsection{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-6}}

Инструмент rahash2 используется для вычисления контрольных сумм, хэшей,
включает функции хеширование байтовых потоков, блоков, файлов, текстовых
строк.

\begin{verbatim}
$ rahash2 -h
Usage: rahash2 [-rBhLkv] [-b S] [-a A] [-c H] [-E A] [-s S] [-f O] [-t O] [file] ...
 -a algo     список алгоритмов, разделенных запятой (по умолчанию 'sha256')
 -b bsize    задать размер блока данных (вместо файла целиком)
 -B          показать хэши по блокам
 -c hash     сравнить с хэшем, переданным в параметре
 -e          переключить проядок батов (swap endian) (использовать little endian)
 -E algo     шифровать, используйте -S для установки ключа и -I для установки вектора инициализации
 -D algo     расшифровать, используйте -S для установки ключа и -I для установки вектора инициализации
 -f from     начать хэширование по заданному адресу
 -i num      повтороить хэширование num раз
 -I iv       использвать заданный вектор инициализации (IV) (шестнадцатеричный или s:строковый)
 -S seed     задать начальное зерно (seed) (шестнадцатеричный или s:строковый), используйте ^ для задания префикса (ключа для -E),  "-" загрузит ключ с stdin, префикс @ указывает на файл
 -k          показать хэш, используя алгоритм randomkey из библиотеки openssh
 -q          запуск в "тихом" режиме (-qq показывает только результаты)
 -L          перечислить все доступные алгоритмы (смотрите -a)
 -r          вывести в виде команд radare
 -s string   хэшировать строку вместо файлов
 -t to       остановить хэширование на заданном адресе
 -x hexstr   хэшировать заданный блок байтов, заданных в шестнадцатеричном виде
 -v          показать версию программы и дополнительную информацию
\end{verbatim}

Чтобы получить хэш-значение MD5 текстовой строки, используйте параметр
\texttt{-s} :

\begin{verbatim}
$ rahash2 -q -a md5 -s 'hello world'
5eb63bbbe01eeed093cb22bb8f5acdc3
\end{verbatim}

Можно вычислить хэш-значения для содержимого файлов. Не пытайтесь
проводить хэширование очень больших файлов в такой форме, так как
rahash2 буферизует весь вход в памяти перед вычислением хэша. Чтобы надо
применить все алгоритмы хэширования, известные rahash2, используйте
\texttt{all} в качестве имени алгоритма:

\begin{verbatim}
$ rahash2 -a all /bin/ls
/bin/ls: 0x00000000-0x000268c7 md5: 767f0fff116bc6584dbfc1af6fd48fc7
/bin/ls: 0x00000000-0x000268c7 sha1: 404303f3960f196f42f8c2c12970ab0d49e28971
/bin/ls: 0x00000000-0x000268c7 sha256: 74ea05150acf311484bddd19c608aa02e6bf3332a0f0805a4deb278e17396354
/bin/ls: 0x00000000-0x000268c7 sha384: c6f811287514ceeeaabe73b5b2f54545036d6fd3a192ea5d6a1fcd494d46151df4117e1c62de0884cbc174c8db008ed1
/bin/ls: 0x00000000-0x000268c7 sha512: 53e4950a150f06d7922a2ed732060e291bf0e1c2ac20bc72a41b9303e1f2837d50643761030d8b918ed05d12993d9515e1ac46676bc0d15ac94d93d8e446fa09
/bin/ls: 0x00000000-0x000268c7 md4: fdfe7c7118a57c1ff8c88a51b16fc78c
/bin/ls: 0x00000000-0x000268c7 xor: 42
/bin/ls: 0x00000000-0x000268c7 xorpair: d391
/bin/ls: 0x00000000-0x000268c7 parity: 00
/bin/ls: 0x00000000-0x000268c7 entropy: 5.95471783
/bin/ls: 0x00000000-0x000268c7 hamdist: 00
/bin/ls: 0x00000000-0x000268c7 pcprint: 22
/bin/ls: 0x00000000-0x000268c7 mod255: ef
/bin/ls: 0x00000000-0x000268c7 xxhash: 76554666
/bin/ls: 0x00000000-0x000268c7 adler32: 7704fe60
/bin/ls: 0x00000000-0x000268c7 luhn: 01
/bin/ls: 0x00000000-0x000268c7 crc8smbus: 8d
/bin/ls: 0x00000000-0x000268c7 crc15can: 1cd5
/bin/ls: 0x00000000-0x000268c7 crc16: d940
/bin/ls: 0x00000000-0x000268c7 crc16hdlc: 7847
/bin/ls: 0x00000000-0x000268c7 crc16usb: 17bb
/bin/ls: 0x00000000-0x000268c7 crc16citt: 67f7
/bin/ls: 0x00000000-0x000268c7 crc24: 3e7053
/bin/ls: 0x00000000-0x000268c7 crc32: c713f78f
/bin/ls: 0x00000000-0x000268c7 crc32c: 6cfba67c
/bin/ls: 0x00000000-0x000268c7 crc32ecma267: b4c809d6
/bin/ls: 0x00000000-0x000268c7 crc32bzip2: a1884a09
/bin/ls: 0x00000000-0x000268c7 crc32d: d1a9533c
/bin/ls: 0x00000000-0x000268c7 crc32mpeg2: 5e77b5f6
/bin/ls: 0x00000000-0x000268c7 crc32posix: 6ba0dec3
/bin/ls: 0x00000000-0x000268c7 crc32q: 3166085c
/bin/ls: 0x00000000-0x000268c7 crc32jamcrc: 38ec0870
/bin/ls: 0x00000000-0x000268c7 crc32xfer: 7504089d
/bin/ls: 0x00000000-0x000268c7 crc64: b6471d3093d94241
/bin/ls: 0x00000000-0x000268c7 crc64ecma: b6471d3093d94241
/bin/ls: 0x00000000-0x000268c7 crc64we: 8fe37d44a47157bd
/bin/ls: 0x00000000-0x000268c7 crc64xz: ea83e12c719e0d79
/bin/ls: 0x00000000-0x000268c7 crc64iso: d243106d9853221c
\end{verbatim}

\hypertarget{ux43fux43bux430ux433ux438ux43dux44b}{%
\section{Плагины}\label{ux43fux43bux430ux433ux438ux43dux44b}}

Radare2 реализован на основе библиотек, в том числе поддерживающих
плагины для расширения их возможностей или добавления поддержки новых
архитектур и форматов.

В этом разделе объясняется, что такое плагины, их реализация и
использование.

\hypertarget{ux442ux438ux43fux44b-ux43fux43bux430ux433ux438ux43dux43eux432}{%
\subsection{Типы
плагинов}\label{ux442ux438ux43fux44b-ux43fux43bux430ux433ux438ux43dux43eux432}}

\begin{verbatim}
$ ls libr/*/p | grep : | awk -F / '{ print $2 }'
anal      # плагины анлиза,
asm       # плагины ассемблирования/дизассемблирования,
bin       # плагины синтаксического анализа форматов,
bp        # плагины точек останов,
core      # плагины ядра (новые команды),
crypto    # шифрование/дешифрование/хэши/...,
debug     # плагины отладки,
egg       # кодировщики шелл-кода, и т.п.,
fs        # файловые системы и таблицы партиций,
io        # плагины ввода-вывода,
lang      # встроенные языки сценариев,
parse     # синтаксический анализ результатов дизассемблирования,
reg       # регистровая логика архитектуры.
\end{verbatim}

\hypertarget{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux441ux43fux438ux441ux43aux430-ux43fux43bux430ux433ux438ux43dux43eux432}{%
\subsection{Получение списка
плагинов}\label{ux43fux43eux43bux443ux447ux435ux43dux438ux435-ux441ux43fux438ux441ux43aux430-ux43fux43bux430ux433ux438ux43dux43eux432}}

Инструменты r2 поддерживают флаг \texttt{-L} для вывода всех плагинов во
видам реализованных функций.

\begin{verbatim}
rasm2 -L    # перечень плагинов asm,
r2 -L       # перечень плагинов io,
rabin2 -L   # перечень плагинов bin,
rahash2 -L  # перечень плагинов хэш/шифрование/дешифрования.
\end{verbatim}

В проекте r2land есть другие плагины, можно получить списки прямо в r2
при помощи группы команд \texttt{L}.

Вот некоторые из команд:

\begin{verbatim}
L          # перечень плагинов ядра (core),
iL         # перечень плагинов bin,
dL         # перечень плагинов debug,
mL         # перечень плагинов fs,
ph         # вывести перечень поддерживаемых алгоритмов хеширования.
\end{verbatim}

Использование \texttt{?} в качестве значения в выражении выдает
возможные варианты значений для переменных среды.

\begin{verbatim}
e asm.arch=?   # список плагинов ассемблирования/дизассемблирования
e anal.arch=?  # список плагинов анализа
\end{verbatim}

\hypertarget{ux43fux440ux438ux43cux435ux447ux430ux43dux438ux44f}{%
\subsection{Примечания}\label{ux43fux440ux438ux43cux435ux447ux430ux43dux438ux44f}}

Обратите внимание - по ходу развития проекта выявляются некоторые
противоречия, они исправляются в новых версиях radare2.

\hypertarget{ux43fux43bux430ux433ux438ux43dux44b-ux432ux432ux43eux434ux430-ux432ux44bux432ux43eux434ux430}{%
\section{Плагины
ввода-вывода}\label{ux43fux43bux430ux433ux438ux43dux44b-ux432ux432ux43eux434ux430-ux432ux44bux432ux43eux434ux430}}

Весь доступ к файлам, сети, отладчику и вводу/выводу другого типа
представлен специальным уровнем абстракции, позволяющим radare
обрабатывать все данные как файл.

Плагины ввода-вывода представляют операции открытия, чтения, записи и
`system' в виде виртуальных файловых систем. Можно заставить radare
обрабатывать что угодно как простой файл. Примерами выступают сокетные
соединения, удаленный сеанс radare, файлы, процессы, устройства, сеансы
gdb.

Таким образом, когда radare считывает блок байтов, задача плагина
ввода-вывода заключается в том, чтобы получить эти байты из своего
источника, поместить их во внутренний буфер. Плагин ввода-вывода
выбирается по URI открываемого файла. Примеры:

\begin{itemize}
\tightlist
\item
  URI отладки
\end{itemize}

\begin{verbatim}
$ r2 dbg:///bin/ls<br />
$ r2 pid://1927
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Удаленные сеансы
\end{itemize}

\begin{verbatim}
$ r2 rap://:1234<br />
$ r2 rap://<host>:1234//bin/ls
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Виртуальные буферы
\end{itemize}

\begin{verbatim}
$ r2 malloc://512<br />
сокращение для
$ r2 -
\end{verbatim}

Получение списка плагинов ввода-вывода в radare - \texttt{radare2\ -L}:

\begin{verbatim}
$ r2 -L
rw_  ar       открытие файлов ar/lib [ar|lib]://[file//path] (LGPL3)
rw_  bfdbg    отладчик для экзотического BrainFuck (bfdbg://path/to/file) (LGPL3)
rwd  bochs    подключение к отладчику BOCHS (LGPL3)
r_d  debug    встроенный отладчик (dbg:///bin/ls dbg://1388 pidof:// waitfor://) (LGPL3) v0.2.0 pancake
rw_  default  открытие локальных файлов, используя def_mmap:// (LGPL3)
rwd  gdb      подключение к gdbserver, 'qemu -s', gdb://localhost:1234 (LGPL3)
rw_  gprobe   открытие gprobe-соединения - gprobe:// (LGPL3)
rw_  gzip     чтение/запись файлов gzip (LGPL3)
rw_  http     запрос GET HTTP (http://rada.re/) (LGPL3)
rw_  ihex     интерпретация файла Intel HEX (ihex://eeproms.hex) (LGPL)
r__  mach     отладка архитектуры mach io-плагин (в этой версии не поддерживается) (LGPL)
rw_  malloc   выделение памяти (malloc://1024 hex://cd8090) (LGPL3)
rw_  mmap     открытие файлов, используя mmap:// (LGPL3)
rw_  null     плагин null-plugin (null://23) (LGPL3)
rw_  procpid  доступ в /proc/pid/mem, io-плагин (LGPL3)
rwd  ptrace   использование ptrace и /proc/pid/mem (если доступны) io-плагин (LGPL3)
rwd  qnx      подключение к инстанцу QNX pdebug, qnx://host:1234 (LGPL3)
rw_  r2k      доступ к  API ядра, io-плагин (r2k://) (LGPL3)
rw_  r2pipe   r2pipe io-плагин (MIT)
rw_  r2web    r2web io-клиент (r2web://cloud.rada.re/cmd/) (LGPL3)
rw_  rap      сетевой протокол radare (rap://:port rap://host:port/file) (LGPL3)
rw_  rbuf     RBuffer io-плагин: rbuf:// (LGPL)
rw_  self     чтение памяти из своего адресного пространства, 'self://' (LGPL3)
rw_  shm      ресурсы разделяемой памяти (shm://key) (LGPL3)
rw_  sparse   выделение разреженных буферов (sparse buffer) (sparse://1024 sparse://) (LGPL3)
rw_  tcp      загрузка файлов по TCP (listen или connect) (LGPL3)
rwd  windbg   подключение к отладчику KD (windbg://socket) (LGPL3)
rwd  winedbg  Wine-dbg io- и debug.io-плагины для r2 (MIT)
rw_  zip      открытие файлов zip [apk|ipa|zip|zipall]://[file//path] (BSD)
\end{verbatim}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}{%
\subsection{Реализация плагина
дизассемблирования}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux434ux438ux437ux430ux441ux441ux435ux43cux431ux43bux438ux440ux43eux432ux430ux43dux438ux44f}}

Архитектура Radare2 модульная, поэтому реализация поддержки новой
архитектуры очень проста, особенно тем, кто свободно владеет С. По
множеству причин реализацию еще проще сделать на основе исходников из
дерева репозитория radare2.

Создаем всего один файл C, называемый \texttt{asm\_mycpu.c} и
соответсвующий Makefile.

Ключевым моментом плагина RAsm является структура

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RAsmPlugin r\_asm\_plugin\_mycpu }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{license }\OperatorTok{=} \StringTok{"LGPL3"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{desc }\OperatorTok{=} \StringTok{"MYCPU disassembly plugin"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{arch }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{bits }\OperatorTok{=} \DecValTok{32}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{endian }\OperatorTok{=}\NormalTok{ R\_SYS\_ENDIAN\_LITTLE}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{disassemble }\OperatorTok{=} \OperatorTok{\&}\NormalTok{disassemble}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Здесь \texttt{.disassemble} --- это указатель на функцию
дизассемблирования, принимающую буфер байтов и его длину:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ disassemble}\OperatorTok{(}\NormalTok{RAsm }\OperatorTok{*}\NormalTok{a}\OperatorTok{,}\NormalTok{ RAsmOp }\OperatorTok{*}\NormalTok{op}\OperatorTok{,} \DataTypeTok{const}\NormalTok{ ut8 }\OperatorTok{*}\NormalTok{buf}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{NAME}\CharTok{=}\StringTok{asm\_snes}
\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H R2\_USER\_PLUGINS}\CharTok{)}
\DataTypeTok{LIBEXT}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H LIBEXT}\CharTok{)}
\DataTypeTok{CFLAGS}\CharTok{=}\StringTok{{-}g {-}fPIC }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}cflags r\_anal}\CharTok{)}
\DataTypeTok{LDFLAGS}\CharTok{=}\StringTok{{-}shared }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}libs r\_anal}\CharTok{)}
\DataTypeTok{OBJS}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.o}
\DataTypeTok{LIB}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.}\CharTok{$(}\DataTypeTok{LIBEXT}\CharTok{)}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{clean:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}

\DecValTok{$(LIB):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
    \CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{LDFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{install:}
\NormalTok{    cp {-}f asm\_mycpu.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)} \CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}

\DecValTok{uninstall:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}\NormalTok{/asm\_mycpu.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{asm\_mycpu.c}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* radare {-} LGPL {-} Copyright 2018 {-} user */}

\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_types.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_lib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_asm.h\textgreater{}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ disassemble}\OperatorTok{(}\NormalTok{RAsm }\OperatorTok{*}\NormalTok{a}\OperatorTok{,}\NormalTok{ RAsmOp }\OperatorTok{*}\NormalTok{op}\OperatorTok{,} \DataTypeTok{const}\NormalTok{ ut8 }\OperatorTok{*}\NormalTok{buf}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ op\_cmd cmd }\OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{.}\NormalTok{instr }\OperatorTok{=} \StringTok{""}\OperatorTok{,}
        \OperatorTok{.}\NormalTok{operands }\OperatorTok{=} \StringTok{""}
    \OperatorTok{\};}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{len }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ ret }\OperatorTok{=}\NormalTok{ decode\_opcode }\OperatorTok{(}\NormalTok{buf}\OperatorTok{,}\NormalTok{ len}\OperatorTok{,} \OperatorTok{\&}\NormalTok{cmd}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{ret }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        snprintf }\OperatorTok{(}\NormalTok{op}\OperatorTok{{-}\textgreater{}}\NormalTok{buf\_asm}\OperatorTok{,}\NormalTok{ R\_ASM\_BUFSIZE}\OperatorTok{,} \StringTok{"\%s \%s"}\OperatorTok{,}
\NormalTok{              cmd}\OperatorTok{.}\NormalTok{instr}\OperatorTok{,}\NormalTok{ cmd}\OperatorTok{.}\NormalTok{operands}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ op}\OperatorTok{{-}\textgreater{}}\NormalTok{size }\OperatorTok{=}\NormalTok{ ret}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{RAsmPlugin r\_asm\_plugin\_mycpu }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{license }\OperatorTok{=} \StringTok{"LGPL3"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{desc }\OperatorTok{=} \StringTok{"MYCPU disassembly plugin"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{arch }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{bits }\OperatorTok{=} \DecValTok{32}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{endian }\OperatorTok{=}\NormalTok{ R\_SYS\_ENDIAN\_LITTLE}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{disassemble }\OperatorTok{=} \OperatorTok{\&}\NormalTok{disassemble}
\OperatorTok{\};}

\PreprocessorTok{\#ifndef R2\_PLUGIN\_INCORE}
\NormalTok{R\_API RLibStruct radare\_plugin }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ R\_LIB\_TYPE\_ASM}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{data }\OperatorTok{=} \OperatorTok{\&}\NormalTok{r\_asm\_plugin\_mycpu}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{version }\OperatorTok{=}\NormalTok{ R2\_VERSION}
\OperatorTok{\};}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

После компиляции radare2 упомянет плагин в списке плагинов вывода:

\begin{verbatim}
_d__  _8_32      mycpu        LGPL3   MYCPU
\end{verbatim}

\hypertarget{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430-ux432-ux434ux435ux440ux435ux432ux43e-ux438ux441ux445ux43eux434ux43dux438ux43aux43eux432-radare2}{%
\subsubsection{Перемещение плагина в дерево исходников
radare2}\label{ux43fux435ux440ux435ux43cux435ux449ux435ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430-ux432-ux434ux435ux440ux435ux432ux43e-ux438ux441ux445ux43eux434ux43dux438ux43aux43eux432-radare2}}

Добавление новой архитектуры в основную ветвь r2 требует изменения
нескольких файлов, что обеспечивает плагину правильную интеграцию
аналогично остальным плагинам.

Список файлов, требующих изменения:

\begin{itemize}
\tightlist
\item
  \texttt{plugins.def.cfg} : добавить название плагина в виде строки
  \texttt{asm.mycpu},
\item
  \texttt{libr/asm/p/mycpu.mk} : инструкции сборки,
\item
  \texttt{libr/asm/p/asm\_mycpu.c} : реализация,
\item
  \texttt{libr/include/r\_asm.h} : добавление определенных структур.
\end{itemize}

Сравните результат с плагином дизассемблирования для процессора NIOS II
по следующим коммитам:

Implement RAsm plugin:
https://github.com/radareorg/radare2/commit/933dc0ef6ddfe44c88bbb261165bf8f8b531476b

Реализация плагина RAnal:
https://github.com/radareorg/radare2/commit/ad430f0d52fbe933e0830c49ee607e9b0e4ac8f2

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux433ux43e-ux43fux43bux430ux433ux438ux43dux430-ux430ux43dux430ux43bux438ux437ux430}{%
\subsection{Реализация нового плагина
анализа}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux433ux43e-ux43fux43bux430ux433ux438ux43dux430-ux430ux43dux430ux43bux438ux437ux430}}

После реализации плагина дизассемблирования, его вывод бывает далеко не
идеальным - нет правильной подсветки, нет ``опорных линий'' и т.д.
Radare2 требует от каждого архитектурного плагина предоставлять также
аналитическую информацию о каждом оп-коде. На данный момент реализация
дизассемблирования и анализа оп-кодов разделена на два модуля - RAsm и
RAnal.

Реализуем плагин анализа. Принцип схож с реализацией дизассемблирования
- реализовать C-файл и соответствующий Makefile.

Структура плагина RAnal выглядит так -

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RAnalPlugin r\_anal\_plugin\_v810 }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{desc }\OperatorTok{=} \StringTok{"MYCPU code analysis plugin"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{license }\OperatorTok{=} \StringTok{"LGPL3"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{arch }\OperatorTok{=} \StringTok{"mycpu"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{bits }\OperatorTok{=} \DecValTok{32}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{op }\OperatorTok{=}\NormalTok{ mycpu\_op}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{esil }\OperatorTok{=}\NormalTok{ true}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{set\_reg\_profile }\OperatorTok{=}\NormalTok{ set\_reg\_profile}\OperatorTok{,}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Аналогично плагину дизассемблирования, есть ключевая функция -
\texttt{mycpu\_op}, сканирующая оп-код и создающая структуру RAnalOp. В
этом примере плагины анализа также выполняют описание оп-кода командами
ESIL (uplifting), так как включен \texttt{.esil\ =\ true}. Таким
образом, \texttt{mycpu\_op} обязан заполнять соответствующее ESIL-поле
структуры RAnalOp для оп-кодов. Вторая важная вещь для кодирования
оп-кодов в ESIL и выполнения эмуляции - регистровый профиль, подобно
тому, как в отладчике, он задается внутри функции
\texttt{set\_reg\_profile}.

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{NAME}\CharTok{=}\StringTok{anal\_snes}
\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H R2\_USER\_PLUGINS}\CharTok{)}
\DataTypeTok{LIBEXT}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H LIBEXT}\CharTok{)}
\DataTypeTok{CFLAGS}\CharTok{=}\StringTok{{-}g {-}fPIC }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}cflags r\_anal}\CharTok{)}
\DataTypeTok{LDFLAGS}\CharTok{=}\StringTok{{-}shared }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}libs r\_anal}\CharTok{)}
\DataTypeTok{OBJS}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.o}
\DataTypeTok{LIB}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.}\CharTok{$(}\DataTypeTok{LIBEXT}\CharTok{)}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{clean:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}

\DecValTok{$(LIB):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
    \CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{LDFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{install:}
\NormalTok{    cp {-}f anal\_snes.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)} \CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}

\DecValTok{uninstall:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}\NormalTok{/anal\_snes.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{anal\_snes.c:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* radare {-} LGPL {-} Copyright 2015 {-} condret */}

\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_types.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_lib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_asm.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_anal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"snes\_op\_table.h"}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ snes\_anop}\OperatorTok{(}\NormalTok{RAnal }\OperatorTok{*}\NormalTok{anal}\OperatorTok{,}\NormalTok{ RAnalOp }\OperatorTok{*}\NormalTok{op}\OperatorTok{,}\NormalTok{ ut64 addr}\OperatorTok{,} \DataTypeTok{const}\NormalTok{ ut8 }\OperatorTok{*}\NormalTok{data}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    memset }\OperatorTok{(}\NormalTok{op}\OperatorTok{,} \CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\OperatorTok{,} \KeywordTok{sizeof} \OperatorTok{(}\NormalTok{RAnalOp}\OperatorTok{));}
\NormalTok{    op}\OperatorTok{{-}\textgreater{}}\NormalTok{size }\OperatorTok{=}\NormalTok{ snes\_op}\OperatorTok{[}\NormalTok{data}\OperatorTok{[}\DecValTok{0}\OperatorTok{]].}\NormalTok{len}\OperatorTok{;}
\NormalTok{    op}\OperatorTok{{-}\textgreater{}}\NormalTok{addr }\OperatorTok{=}\NormalTok{ addr}\OperatorTok{;}
\NormalTok{    op}\OperatorTok{{-}\textgreater{}}\NormalTok{type }\OperatorTok{=}\NormalTok{ R\_ANAL\_OP\_TYPE\_UNK}\OperatorTok{;}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{data}\OperatorTok{[}\DecValTok{0}\OperatorTok{])} \OperatorTok{\{}
        \ControlFlowTok{case} \BaseNTok{0xea}\OperatorTok{:}
\NormalTok{            op}\OperatorTok{{-}\textgreater{}}\NormalTok{type }\OperatorTok{=}\NormalTok{ R\_ANAL\_OP\_TYPE\_NOP}\OperatorTok{;}
            \ControlFlowTok{break}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ op}\OperatorTok{{-}\textgreater{}}\NormalTok{size}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{struct}\NormalTok{ r\_anal\_plugin\_t r\_anal\_plugin\_snes }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"snes"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{desc }\OperatorTok{=} \StringTok{"SNES analysis plugin"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{license }\OperatorTok{=} \StringTok{"LGPL3"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{arch }\OperatorTok{=}\NormalTok{ R\_SYS\_ARCH\_NONE}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{bits }\OperatorTok{=} \DecValTok{16}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{init }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{fini }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{op }\OperatorTok{=} \OperatorTok{\&}\NormalTok{snes\_anop}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{set\_reg\_profile }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{fingerprint\_bb }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{fingerprint\_fcn }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{diff\_bb }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{diff\_fcn }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{diff\_eval }\OperatorTok{=}\NormalTok{ NULL}
\OperatorTok{\};}

\PreprocessorTok{\#ifndef R2\_PLUGIN\_INCORE}
\NormalTok{R\_API RLibStruct radare\_plugin }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ R\_LIB\_TYPE\_ANAL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{data }\OperatorTok{=} \OperatorTok{\&}\NormalTok{r\_anal\_plugin\_snes}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{version }\OperatorTok{=}\NormalTok{ R2\_VERSION}
\OperatorTok{\};}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

После компиляции radare2 упомянет плагин в списке плагинов вывода:

\begin{verbatim}
_dA_  _8_16      snes        LGPL3   SuperNES CPU
\end{verbatim}

\textbf{snes\_op\_table}.h:
https://github.com/radareorg/radare2/blob/master/libr/asm/arch/snes/snes\_op\_table.h

Пример:

\begin{itemize}
\tightlist
\item
  \textbf{6502}:
  https://github.com/radareorg/radare2/commit/64636e9505f9ca8b408958d3c01ac8e3ce254a9b
\item
  \textbf{SNES}:
  https://github.com/radareorg/radare2/commit/60d6e5a1b9d244c7085b22ae8985d00027624b49
\end{itemize}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux433ux43e-ux444ux43eux440ux43cux430ux442ux430-ux434ux432ux43eux438ux447ux43dux43eux433ux43e-ux444ux430ux439ux43bux430}{%
\subsection{Реализация нового формата двоичного
файла}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux433ux43e-ux444ux43eux440ux43cux430ux442ux430-ux434ux432ux43eux438ux447ux43dux43eux433ux43e-ux444ux430ux439ux43bux430}}

\hypertarget{ux432ux43aux43bux44eux447ux435ux43dux438ux435-ux432ux438ux440ux442ux443ux430ux43bux44cux43dux43eux439-ux430ux434ux440ux435ux441ux430ux446ux438ux438}{%
\subsubsection{Включение виртуальной
адресации}\label{ux432ux43aux43bux44eux447ux435ux43dux438ux435-ux432ux438ux440ux442ux443ux430ux43bux44cux43dux43eux439-ux430ux434ux440ux435ux441ux430ux446ux438ux438}}

В \texttt{info} надо добавить \texttt{et-\textgreater{}has\_va\ =\ 1;} и
\texttt{ptr-\textgreater{}srwx} с атрибутом \texttt{R\_BIN\_SCN\_MAP;}

\hypertarget{ux43eux444ux43eux440ux43cux43bux435ux43dux438ux435-ux43fux430ux43fux43aux438-ux441-ux438ux43cux435ux43dux435ux43c-ux444ux43eux440ux43cux430ux442ux430-ux444ux430ux439ux43bux430-ux432-librbinformat}{%
\subsubsection{Оформление папки с именем формата файла в
libr/bin/format}\label{ux43eux444ux43eux440ux43cux43bux435ux43dux438ux435-ux43fux430ux43fux43aux438-ux441-ux438ux43cux435ux43dux435ux43c-ux444ux43eux440ux43cux430ux442ux430-ux444ux430ux439ux43bux430-ux432-librbinformat}}

\textbf{Makefile:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{NAME}\CharTok{=}\StringTok{bin\_nes}
\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H R2\_USER\_PLUGINS}\CharTok{)}
\DataTypeTok{LIBEXT}\CharTok{=$(}\KeywordTok{shell}\StringTok{ r2 {-}H LIBEXT}\CharTok{)}
\DataTypeTok{CFLAGS}\CharTok{=}\StringTok{{-}g {-}fPIC }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}cflags r\_bin}\CharTok{)}
\DataTypeTok{LDFLAGS}\CharTok{=}\StringTok{{-}shared }\CharTok{$(}\KeywordTok{shell}\StringTok{ pkg{-}config {-}{-}libs r\_bin}\CharTok{)}
\DataTypeTok{OBJS}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.o}
\DataTypeTok{LIB}\CharTok{=$(}\DataTypeTok{NAME}\CharTok{)}\StringTok{.}\CharTok{$(}\DataTypeTok{LIBEXT}\CharTok{)}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{clean:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}

\DecValTok{$(LIB):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
    \CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{LDFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{install:}
\NormalTok{    cp {-}f }\CharTok{$(}\DataTypeTok{NAME}\CharTok{)}\NormalTok{.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)} \CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}

\DecValTok{uninstall:}
\NormalTok{    rm {-}f }\CharTok{$(}\DataTypeTok{R2\_PLUGIN\_PATH}\CharTok{)}\NormalTok{/}\CharTok{$(}\DataTypeTok{NAME}\CharTok{)}\NormalTok{.}\CharTok{$(}\DataTypeTok{SO\_EXT}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{bin\_nes.c:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_util.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}r\_bin.h\textgreater{}}

\DataTypeTok{static} \DataTypeTok{bool}\NormalTok{ load\_buffer}\OperatorTok{(}\NormalTok{RBinFile }\OperatorTok{*}\NormalTok{bf}\OperatorTok{,} \DataTypeTok{void} \OperatorTok{**}\NormalTok{bin\_obj}\OperatorTok{,}\NormalTok{ RBuffer }\OperatorTok{*}\NormalTok{b}\OperatorTok{,}\NormalTok{ ut64 loadaddr}\OperatorTok{,}\NormalTok{ Sdb }\OperatorTok{*}\NormalTok{sdb}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    ut64 size}\OperatorTok{;}
    \DataTypeTok{const}\NormalTok{ ut8 }\OperatorTok{*}\NormalTok{buf }\OperatorTok{=}\NormalTok{ r\_buf\_data }\OperatorTok{(}\NormalTok{b}\OperatorTok{,} \OperatorTok{\&}\NormalTok{size}\OperatorTok{);}
\NormalTok{    r\_return\_val\_if\_fail }\OperatorTok{(}\NormalTok{buf}\OperatorTok{,}\NormalTok{ false}\OperatorTok{);}
    \OperatorTok{*}\NormalTok{bin\_obj }\OperatorTok{=}\NormalTok{ r\_bin\_internal\_nes\_load }\OperatorTok{(}\NormalTok{buf}\OperatorTok{,}\NormalTok{ size}\OperatorTok{);}
    \ControlFlowTok{return} \OperatorTok{*}\NormalTok{bin\_obj }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ destroy}\OperatorTok{(}\NormalTok{RBinFile }\OperatorTok{*}\NormalTok{bf}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    r\_bin\_free\_all\_nes\_obj }\OperatorTok{(}\NormalTok{bf}\OperatorTok{{-}\textgreater{}}\NormalTok{o}\OperatorTok{{-}\textgreater{}}\NormalTok{bin\_obj}\OperatorTok{);}
\NormalTok{    bf}\OperatorTok{{-}\textgreater{}}\NormalTok{o}\OperatorTok{{-}\textgreater{}}\NormalTok{bin\_obj }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{bool}\NormalTok{ check\_buffer}\OperatorTok{(}\NormalTok{RBuffer }\OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{buf }\OperatorTok{||}\NormalTok{ length }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ false}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{(!}\NormalTok{memcmp }\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}x4E\textbackslash{}x45\textbackslash{}x53\textbackslash{}x1A}\StringTok{"}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ RBinInfo}\OperatorTok{*}\NormalTok{ info}\OperatorTok{(}\NormalTok{RBinFile }\OperatorTok{*}\NormalTok{arch}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    RBinInfo \textbackslash{}}\OperatorTok{*}\NormalTok{ret }\OperatorTok{=}\NormalTok{ R\_NEW0 }\OperatorTok{(}\NormalTok{RBinInfo}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{ret}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{arch }\OperatorTok{||} \OperatorTok{!}\NormalTok{arch}\OperatorTok{{-}\textgreater{}}\NormalTok{buf}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        free }\OperatorTok{(}\NormalTok{ret}\OperatorTok{);}
        \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{file }\OperatorTok{=}\NormalTok{ strdup }\OperatorTok{(}\NormalTok{arch}\OperatorTok{{-}\textgreater{}}\NormalTok{file}\OperatorTok{);}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{type }\OperatorTok{=}\NormalTok{ strdup }\OperatorTok{(}\StringTok{"ROM"}\OperatorTok{);}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{machine }\OperatorTok{=}\NormalTok{ strdup }\OperatorTok{(}\StringTok{"Nintendo NES"}\OperatorTok{);}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{os }\OperatorTok{=}\NormalTok{ strdup }\OperatorTok{(}\StringTok{"nes"}\OperatorTok{);}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{arch }\OperatorTok{=}\NormalTok{ strdup }\OperatorTok{(}\StringTok{"6502"}\OperatorTok{);}
\NormalTok{    ret}\OperatorTok{{-}\textgreater{}}\NormalTok{bits }\OperatorTok{=} \DecValTok{8}\OperatorTok{;}

    \ControlFlowTok{return}\NormalTok{ ret}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{struct}\NormalTok{ r\_bin\_plugin\_t r\_bin\_plugin\_nes }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"nes"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{desc }\OperatorTok{=} \StringTok{"NES"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{license }\OperatorTok{=} \StringTok{"BSD"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{get\_sdb }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{load\_buffer }\OperatorTok{=} \OperatorTok{\&}\NormalTok{load\_buffer}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{destroy }\OperatorTok{=} \OperatorTok{\&}\NormalTok{destroy}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{check\_buffer }\OperatorTok{=} \OperatorTok{\&}\NormalTok{check\_buffer}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{baddr }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{entries }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{sections }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{info }\OperatorTok{=} \OperatorTok{\&}\NormalTok{info}\OperatorTok{,}
\OperatorTok{\};}

\PreprocessorTok{\#ifndef R2\_PLUGIN\_INCORE}
\NormalTok{R\_API RLibStruct radare\_plugin }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ R\_LIB\_TYPE\_BIN}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{data }\OperatorTok{=} \OperatorTok{\&}\NormalTok{r\_bin\_plugin\_nes}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{version }\OperatorTok{=}\NormalTok{ R2\_VERSION}
\OperatorTok{\};}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux43fux440ux438ux43cux435ux440ux44b-7}{%
\subsubsection{Примеры}\label{ux43fux440ux438ux43cux435ux440ux44b-7}}

\begin{itemize}
\tightlist
\item
  XBE - https://github.com/radareorg/radare2/pull/972,
\item
  COFF - https://github.com/radareorg/radare2/pull/645,
\item
  TE - https://github.com/radareorg/radare2/pull/61,
\item
  Zimgz -
  https://github.com/radareorg/radare2/commit/d1351cf836df3e2e63043a6dc728e880316f00eb,
\item
  OMF -
  https://github.com/radareorg/radare2/commit/44fd8b2555a0446ea759901a94c06f20566bbc40.
\end{itemize}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux43eux442ux43bux430ux434ux447ux438ux43aux430}{%
\subsection{Реализация плагина
отладчика}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux43eux442ux43bux430ux434ux447ux438ux43aux430}}

\begin{itemize}
\tightlist
\item
  Добавление профиля регистров отладчика в shlr/gdb/src/core.c,
\item
  Добавление поддержки профиля и архитектуры регистров в
  libr/debug/p/debug\_native.c и libr/debug/p/debug\_gdb.c,
\item
  Добавьте код для профилей в функцию
  \texttt{r\_debug\_gdb\_attach(RDebug\ *dbg,\ int\ pid)}.
\end{itemize}

Если добавить поддержку gdb, тогда можно будет видеть профиль регистров
в активном сеансе gdb, используя команду
\texttt{maint\ print\ registers}.

\hypertarget{ux442ux43e-ux43bux438-ux435ux449ux435-ux431ux443ux434ux435ux442}{%
\subsection{То ли еще
будет!}\label{ux442ux43e-ux43bux438-ux435ux449ux435-ux431ux443ux434ux435ux442}}

\begin{itemize}
\tightlist
\item
  Статья по теме:
  http://radare.today/posts/extending-r2-with-new-plugins/
\end{itemize}

Некоторые коммиты, связанные с «Реализацией новых архитектур»

\begin{itemize}
\tightlist
\item
  Extensa:
  https://github.com/radareorg/radare2/commit/6f1655c49160fe9a287020537afe0fb8049085d7,
\item
  Malbolge: https://github.com/radareorg/radare2/pull/579,
\item
  6502: https://github.com/radareorg/radare2/pull/656,
\item
  h8300: https://github.com/radareorg/radare2/pull/664,
\item
  GBA: https://github.com/radareorg/radare2/pull/702,
\item
  CR16: https://github.com/radareorg/radare2/pull/721/ \&\& 726,
\item
  XCore:
  https://github.com/radareorg/radare2/commit/bb16d1737ca5a471142f16ccfa7d444d2713a54d,
\item
  SharpLH5801:
  https://github.com/neuschaefer/radare2/commit/f4993cca634161ce6f82a64596fce45fe6b818e7,
\item
  MSP430: https://github.com/radareorg/radare2/pull/1426,
\item
  HP-PA-RISC:
  https://github.com/radareorg/radare2/commit/f8384feb6ba019b91229adb8fd6e0314b0656f7b,
\item
  V810: https://github.com/radareorg/radare2/pull/2899,
\item
  TMS320: https://github.com/radareorg/radare2/pull/596.
\end{itemize}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux439-ux43fux441ux435ux432ux434ux43eux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b}{%
\subsection{Реализация новой
псевдоархитектуры}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43dux43eux432ux43eux439-ux43fux441ux435ux432ux434ux43eux430ux440ux445ux438ux442ux435ux43aux442ux443ux440ux44b}}

Простой плагин для Z80, который можно использовать в качестве примера:

https://github.com/radareorg/radare2/commit/8ff6a92f65331cf8ad74cd0f44a60c258b137a06

\hypertarget{ux43fux43bux430ux433ux438ux43dux44b-python}{%
\section{Плагины
Python}\label{ux43fux43bux430ux433ux438ux43dux44b-python}}

Необходимым условием для реализации модулей расширения на языке Python
для radare2 является установка плагина r2lang:
\texttt{r2pm\ -i\ lang-python}. Обратим внимание, что ради читабельности
кода в следующих примерах отсутствуют фактическая реализация функций!

Нужно сделать следующее: 1. \texttt{import\ r2lang} и
\texttt{from\ r2lang\ import\ R} (модуль констант) 2. Далее для плагина
RAsm реализуем функцию с двумя подфункциями - \texttt{assemble} и
\texttt{disassemble}, она также должна возвращать структуру,
представляющую плагин

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mycpu(a):}
    \KeywordTok{def}\NormalTok{ assemble(s):}
        \ControlFlowTok{return}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}

    \KeywordTok{def}\NormalTok{ disassemble(memview, addr):}
        \ControlFlowTok{try}\NormalTok{:}
\NormalTok{            opcode }\OperatorTok{=}\NormalTok{ get\_opcode(memview) }\CommentTok{\# https://docs.python.org/3/library/stdtypes.html\#memoryview}
\NormalTok{            opstr }\OperatorTok{=}\NormalTok{ optbl[opcode][}\DecValTok{1}\NormalTok{]}
            \ControlFlowTok{return}\NormalTok{ [}\DecValTok{4}\NormalTok{, opstr]}
        \ControlFlowTok{except}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\StringTok{"unknown"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Данная конструкция должна содержать указатели на эти две функции --
  \texttt{assemble} и \texttt{disassemble}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
    \ControlFlowTok{return}\NormalTok{ \{}
            \StringTok{"name"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"arch"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"bits"}\NormalTok{ : }\DecValTok{32}\NormalTok{,}
            \StringTok{"endian"}\NormalTok{ : R.R\_SYS\_ENDIAN\_LITTLE,}
            \StringTok{"license"}\NormalTok{ : }\StringTok{"GPL"}\NormalTok{,}
            \StringTok{"desc"}\NormalTok{ : }\StringTok{"MYCPU disasm"}\NormalTok{,}
            \StringTok{"assemble"}\NormalTok{ : assemble,}
            \StringTok{"disassemble"}\NormalTok{ : disassemble,}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Для плагина RAnal создается функция с двумя подфункциями -
  \texttt{set\_reg\_profile} и \texttt{op}, возвращается структура
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mycpu\_anal(a):}
       \KeywordTok{def}\NormalTok{ set\_reg\_profile():}
\NormalTok{        profile }\OperatorTok{=} \StringTok{"=PC  pc}\CharTok{\textbackslash{}n}\StringTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"=SP    sp}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r0  .32 0   0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r1  .32 4   0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r2  .32 8   0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r3  .32 12  0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r4  .32 16  0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    r5  .32 20  0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    sp  .32 24  0}\CharTok{\textbackslash{}n}\CommentTok{"} \OperatorTok{+} \OperatorTok{\textbackslash{}}
        \CommentTok{"gpr    pc  .32 28  0}\CharTok{\textbackslash{}n}\CommentTok{"}
        \ControlFlowTok{return}\NormalTok{ profile}

    \KeywordTok{def}\NormalTok{ op(memview, pc):}
\NormalTok{        analop }\OperatorTok{=}\NormalTok{ \{}
            \StringTok{"type"}\NormalTok{ : R.R\_ANAL\_OP\_TYPE\_NULL,}
            \StringTok{"cycles"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
            \StringTok{"stackop"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
            \StringTok{"stackptr"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
            \StringTok{"ptr"}\NormalTok{ : }\OperatorTok{{-}}\DecValTok{1}\NormalTok{,}
            \StringTok{"jump"}\NormalTok{ : }\OperatorTok{{-}}\DecValTok{1}\NormalTok{,}
            \StringTok{"addr"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
            \StringTok{"eob"}\NormalTok{ : }\VariableTok{False}\NormalTok{,}
            \StringTok{"esil"}\NormalTok{ : }\StringTok{""}\NormalTok{,}
\NormalTok{        \}}
        \ControlFlowTok{try}\NormalTok{:}
\NormalTok{            opcode }\OperatorTok{=}\NormalTok{ get\_opcode(memview) }\CommentTok{\# https://docs.python.org/3/library/stdtypes.html\#memoryview}
\NormalTok{            esilstr }\OperatorTok{=}\NormalTok{ optbl[opcode][}\DecValTok{2}\NormalTok{]}
            \ControlFlowTok{if}\NormalTok{ optbl[opcode][}\DecValTok{0}\NormalTok{] }\OperatorTok{==} \StringTok{"J"}\NormalTok{: }\CommentTok{\# it\textquotesingle{}s jump}
\NormalTok{                analop[}\StringTok{"type"}\NormalTok{] }\OperatorTok{=}\NormalTok{ R.R\_ANAL\_OP\_TYPE\_JMP}
\NormalTok{                analop[}\StringTok{"jump"}\NormalTok{] }\OperatorTok{=}\NormalTok{ decode\_jump(opcode, j\_mask)}
\NormalTok{                esilstr }\OperatorTok{=}\NormalTok{ jump\_esil(esilstr, opcode, j\_mask)}

        \ControlFlowTok{except}\NormalTok{:}
\NormalTok{            result }\OperatorTok{=}\NormalTok{ analop}
        \CommentTok{\# Don\textquotesingle{}t forget to return proper instruction size!}
        \ControlFlowTok{return}\NormalTok{ [}\DecValTok{4}\NormalTok{, result]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Эта структура должна содержать указатели на две функции
  \texttt{set\_reg\_profile} и \texttt{op}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
    \ControlFlowTok{return}\NormalTok{ \{}
            \StringTok{"name"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"arch"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"bits"}\NormalTok{ : }\DecValTok{32}\NormalTok{,}
            \StringTok{"license"}\NormalTok{ : }\StringTok{"GPL"}\NormalTok{,}
            \StringTok{"desc"}\NormalTok{ : }\StringTok{"MYCPU anal"}\NormalTok{,}
            \StringTok{"esil"}\NormalTok{ : }\DecValTok{1}\NormalTok{,}
            \StringTok{"set\_reg\_profile"}\NormalTok{ : set\_reg\_profile,}
            \StringTok{"op"}\NormalTok{ : op,}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  (Необязательный шаг) Чтобы добавить дополнительную информацию о
  размерах операций и выравнивании добавьте подфункцию \texttt{archinfo}
  и поместите ее указатель в структуре:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mycpu\_anal(a):}
    \KeywordTok{def}\NormalTok{ set\_reg\_profile():}
\NormalTok{        [...]}
    \KeywordTok{def}\NormalTok{ archinfo(query):}
        \ControlFlowTok{if}\NormalTok{ query }\OperatorTok{==}\NormalTok{ R.R\_ANAL\_ARCHINFO\_MIN\_OP\_SIZE:}
            \ControlFlowTok{return} \DecValTok{1}
        \ControlFlowTok{if}\NormalTok{ query }\OperatorTok{==}\NormalTok{ R.R\_ANAL\_ARCHINFO\_MAX\_OP\_SIZE:}
            \ControlFlowTok{return} \DecValTok{8}
        \ControlFlowTok{if}\NormalTok{ query }\OperatorTok{==}\NormalTok{ R.R\_ANAL\_ARCHINFO\_INV\_OP\_SIZE:  }\CommentTok{\# invalid op size}
            \ControlFlowTok{return} \DecValTok{2}
        \ControlFlowTok{return} \DecValTok{0}
    \KeywordTok{def}\NormalTok{ analop(memview, pc):}
\NormalTok{        [...]}

    \ControlFlowTok{return}\NormalTok{ \{}
            \StringTok{"name"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"arch"}\NormalTok{ : }\StringTok{"mycpu"}\NormalTok{,}
            \StringTok{"bits"}\NormalTok{ : }\DecValTok{32}\NormalTok{,}
            \StringTok{"license"}\NormalTok{ : }\StringTok{"GPL"}\NormalTok{,}
            \StringTok{"desc"}\NormalTok{ : }\StringTok{"MYCPU anal"}\NormalTok{,}
            \StringTok{"esil"}\NormalTok{ : }\DecValTok{1}\NormalTok{,}
            \StringTok{"set\_reg\_profile"}\NormalTok{ : set\_reg\_profile,}
            \StringTok{"archinfo"}\NormalTok{: archinfo,}
            \StringTok{"op"}\NormalTok{ : op,}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Зарегистрируйте оба плагина, используя \texttt{r2lang.plugin("asm")} и
  \texttt{r2lang.plugin("anal")}, соответственно.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Registering MYCPU disasm plugin..."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(r2lang.plugin(}\StringTok{"asm"}\NormalTok{, mycpu))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Registering MYCPU analysis plugin..."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(r2lang.plugin(}\StringTok{"anal"}\NormalTok{, mycpu\_anal))}
\end{Highlighting}
\end{Shaded}

Можно объединить все в один файл и загрузить его с помощью флага
\texttt{-i} :

\begin{verbatim}
r2 -I mycpu.py some_file.bin
\end{verbatim}

Можно загрузить плагин из оболочки r2: \texttt{\#!python\ mycpu.py}

Смотрите также:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/radareorg/radare2-bindings/blob/master/libr/lang/p/test-py-asm.py}{Python},
\item
  \href{https://github.com/radareorg/radare2-bindings/blob/master/libr/lang/p/dukasm.js}{Javascript}.
\end{itemize}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux444ux43eux440ux43cux430ux442ux430-ux432-python}{%
\subsubsection{Реализация плагина формата в
Python}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux43bux430ux433ux438ux43dux430-ux444ux43eux440ux43cux430ux442ux430-ux432-python}}

Обратим внимание, что ради читабельности кода в следующих примерах
отсутствуют конкретные реализации функции!

Нужно выполнить: 1. \texttt{import\ r2lang}, 2. Создайте функцию с
подфункциями: - \texttt{load}, - \texttt{load\_bytes}, -
\texttt{destroy}, - \texttt{check\_bytes}, - \texttt{baddr}, -
\texttt{entries}, - \texttt{sections}, - \texttt{imports}, -
\texttt{relocs}, - \texttt{binsym}, - \texttt{info},

вернуть структуру плагина (для плагина RAsm):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ le\_format(a):}
    \KeywordTok{def}\NormalTok{ load(binf):}
        \ControlFlowTok{return}\NormalTok{ [}\DecValTok{0}\NormalTok{]}

    \KeywordTok{def}\NormalTok{ check\_bytes(buf):}
        \ControlFlowTok{try}\NormalTok{:}
            \ControlFlowTok{if}\NormalTok{ buf[}\DecValTok{0}\NormalTok{] }\OperatorTok{==} \DecValTok{77} \KeywordTok{and}\NormalTok{ buf[}\DecValTok{1}\NormalTok{] }\OperatorTok{==} \DecValTok{90}\NormalTok{:}
\NormalTok{                lx\_off, }\OperatorTok{=}\NormalTok{ struct.unpack(}\StringTok{"\textless{}I"}\NormalTok{, buf[}\BaseNTok{0x3c}\NormalTok{:}\BaseNTok{0x40}\NormalTok{])}
                \ControlFlowTok{if}\NormalTok{ buf[lx\_off] }\OperatorTok{==} \DecValTok{76} \KeywordTok{and}\NormalTok{ buf[lx\_off}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{==} \DecValTok{88}\NormalTok{:}
                    \ControlFlowTok{return}\NormalTok{ [}\DecValTok{1}\NormalTok{]}
            \ControlFlowTok{return}\NormalTok{ [}\DecValTok{0}\NormalTok{]}
        \ControlFlowTok{except}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ [}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Проверяйте параметры всех функций и форматы возвращаемых ими данных.
Обратите внимание, что функции \texttt{entries}, \texttt{sections},
\texttt{imports}, \texttt{relocs} возвращают список словарей
специального вида, каждый со своим типом. Другие функции возвращают
только список числовых значений, даже если оно всего одно. Есть
специальная функция, которая возвращает информацию о файле -
\texttt{info}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{def}\NormalTok{ info(binf):}
        \ControlFlowTok{return}\NormalTok{ [\{}
                \StringTok{"type"}\NormalTok{ : }\StringTok{"le"}\NormalTok{,}
                \StringTok{"bclass"}\NormalTok{ : }\StringTok{"le"}\NormalTok{,}
                \StringTok{"rclass"}\NormalTok{ : }\StringTok{"le"}\NormalTok{,}
                \StringTok{"os"}\NormalTok{ : }\StringTok{"OS/2"}\NormalTok{,}
                \StringTok{"subsystem"}\NormalTok{ : }\StringTok{"CLI"}\NormalTok{,}
                \StringTok{"machine"}\NormalTok{ : }\StringTok{"IBM"}\NormalTok{,}
                \StringTok{"arch"}\NormalTok{ : }\StringTok{"x86"}\NormalTok{,}
                \StringTok{"has\_va"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
                \StringTok{"bits"}\NormalTok{ : }\DecValTok{32}\NormalTok{,}
                \StringTok{"big\_endian"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
                \StringTok{"dbg\_info"}\NormalTok{ : }\DecValTok{0}\NormalTok{,}
\NormalTok{                \}]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Эта структура должна содержать указатели на наиболее важные функции,
  такие как \texttt{check\_bytes}, \texttt{load}, \texttt{load\_bytes},
  \texttt{entries}, \texttt{relocs} и \texttt{imports}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
    \ControlFlowTok{return}\NormalTok{ \{}
            \StringTok{"name"}\NormalTok{ : }\StringTok{"le"}\NormalTok{,}
            \StringTok{"desc"}\NormalTok{ : }\StringTok{"OS/2 LE/LX format"}\NormalTok{,}
            \StringTok{"license"}\NormalTok{ : }\StringTok{"GPL"}\NormalTok{,}
            \StringTok{"load"}\NormalTok{ : load,}
            \StringTok{"load\_bytes"}\NormalTok{ : load\_bytes,}
            \StringTok{"destroy"}\NormalTok{ : destroy,}
            \StringTok{"check\_bytes"}\NormalTok{ : check\_bytes,}
            \StringTok{"baddr"}\NormalTok{ : baddr,}
            \StringTok{"entries"}\NormalTok{ : entries,}
            \StringTok{"sections"}\NormalTok{ : sections,}
            \StringTok{"imports"}\NormalTok{ : imports,}
            \StringTok{"symbols"}\NormalTok{ : symbols,}
            \StringTok{"relocs"}\NormalTok{ : relocs,}
            \StringTok{"binsym"}\NormalTok{ : binsym,}
            \StringTok{"info"}\NormalTok{ : info,}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Затем нужно зарегистрировать новый плагин формата файла:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Registering OS/2 LE/LX plugin..."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(r2lang.plugin(}\StringTok{"bin"}\NormalTok{, le\_format))}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux43eux442ux43bux430ux434ux43aux430}{%
\section{Отладка}\label{ux43eux442ux43bux430ux434ux43aux430}}

Часто при проектировании плагинов возникают проблемы, особенно если вы
делаете это для первый раз. Поэтому возможность их отладки очень важна.
Первым шагом для отладки является задание переменной среды при запуске
экземпляра radare2:

\begin{verbatim}
R_DEBUG=yes r2 /bin/ls
Loading /usr/local/lib/radare2/2.2.0-git//bin_xtr_dyldcache.so
Cannot find symbol 'radare_plugin' in library '/usr/local/lib/radare2/2.2.0-git//bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/radare2/2.2.0-git//2.2.0-git
Loading /home/user/.config/radare2/plugins/asm_mips_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/asm_sparc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Cannot open /home/user/.config/radare2/plugins/pimp
Cannot open /home/user/.config/radare2/plugins/yara
Loading /home/user/.config/radare2/plugins/asm_arm_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/core_yara.so
Module version mismatch /home/user/.config/radare2/plugins/core_yara.so (2.1.0) vs (2.2.0-git)
Loading /home/user/.config/radare2/plugins/asm_ppc_ks.so
PLUGIN OK 0x55b205ea6070 fcn 0x7f298de08762
Loading /home/user/.config/radare2/plugins/lang_python3.so
PLUGIN OK 0x55b205ea5ed0 fcn 0x7f298de08692
Loading /usr/local/lib/radare2/2.2.0-git/bin_xtr_dyldcache.so
Cannot find symbol 'radare_plugin' in library '/usr/local/lib/radare2/2.2.0-git/bin_xtr_dyldcache.so'
Cannot open /usr/local/lib/radare2/2.2.0-git/2.2.0-git
Cannot open directory '/usr/local/lib/radare2-extras/2.2.0-git'
Cannot open directory '/usr/local/lib/radare2-bindings/2.2.0-git'
USER CONFIG loaded from /home/user/.config/radare2/radare2rc
 -- В визуальном режиме используйте клавишу 'c', для переключения в режим курсора. Используйте TAB для навигации
[0x00005520]>
\end{verbatim}

\hypertarget{ux442ux435ux441ux442ux438ux440ux43eux432ux430ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430}{%
\section{Тестирование
плагина}\label{ux442ux435ux441ux442ux438ux440ux43eux432ux430ux43dux438ux435-ux43fux43bux430ux433ux438ux43dux430}}

Плагин используется в rasm2 и r2. Проверим, правильно ли он загружается
с помощью этой команды:

\begin{verbatim}
$ rasm2 -L | grep mycpu
_d  mycpu        My CPU disassembler  (LGPL3)
\end{verbatim}

Откроем пустой файл архитектуры `mycpu' и напишем там какой-нибудь
случайный код.

\begin{verbatim}
$ r2 -
 -- I endians swap
[0x00000000]> e asm.arch=mycpu
[0x00000000]> woR
[0x00000000]> pd 10
           0x00000000    888e         mov r8, 14
           0x00000002    b2a5         ifnot r10, r5
           0x00000004    3f67         ret
           0x00000006    7ef6         bl r15, r6
           0x00000008    2701         xor r0, 1
           0x0000000a    9826         mov r2, 6
           0x0000000c    478d         xor r8, 13
           0x0000000e    6b6b         store r6, 11
           0x00000010    1382         add r8, r2
           0x00000012    7f15         ret
\end{verbatim}

Ура! Заработало\ldots{} И теперь проверим, как он работает в командной
строке!

\begin{verbatim}
r2 -nqamycpu -cwoR -cpd' 10' -
\end{verbatim}

\hypertarget{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux430ux43aux435ux442ux430-r2pm-ux434ux43bux44f-ux43fux43bux430ux433ux438ux43dux430}{%
\section{Реализация пакета r2pm для
плагина}\label{ux440ux435ux430ux43bux438ux437ux430ux446ux438ux44f-ux43fux430ux43aux435ux442ux430-r2pm-ux434ux43bux44f-ux43fux43bux430ux433ux438ux43dux430}}

Напомним, что в radare2 включен собственный
\href{../tools/r2pm/intro.md}{менеджер пакетов}, можно легко добавлять
новые плагины, чтобы они были доступны всем.

Все пакеты расположены в репозитории
\href{https://github.com/radareorg/radare2-pm}{radare2-pm}. Для описания
структуры плагина используется очень простой текстовый формат.

\begin{verbatim}
R2PM_BEGIN

R2PM_GIT "https://github.com/user/mycpu"
R2PM_DESC "[r2-arch] дизассемблер и анализатор для MYCPU, плагин"

R2PM_INSTALL() {
    ${MAKE} clean
    ${MAKE} all || exit 1
    ${MAKE} install R2PM_PLUGDIR="${R2PM_PLUGDIR}"
}

R2PM_UNINSTALL() {
    rm -f "${R2PM_PLUGDIR}/asm_mycpu."*
    rm -f "${R2PM_PLUGDIR}/anal_mycpu."*
}

R2PM_END
\end{verbatim}

Затем добавьте его в каталог \texttt{/db} репозитория radare2-pm и
отправьте pull-запрос.

\hypertarget{ux437ux430ux434ux430ux447ux438-crackmes}{%
\section{Задачи
Crackmes}\label{ux437ux430ux434ux430ux447ux438-crackmes}}

Задачи Crackmes (из «crack me» challenge) предназначены для решения
инженерами, интересующимся обратным инжинирингом, для совершенствования
своих навыков. В этом разделе приведены учебные материалы по приемам
взлома файлов crackme с помощью r2.

\hypertarget{ux437ux430ux434ux430ux447ux43aux438-ioli-crackmes}{%
\section{Задачки IOLI
CrackMes}\label{ux437ux430ux434ux430ux447ux43aux438-ioli-crackmes}}

Задачки IOLI crackme - хорошая отправная точка для изучения r2. Это
набор разобранных примеров, основанных на пособии
\href{http://dustri.org/b/defeating-ioli-with-radare2.html}{dustri}

Копии задач доступны на локальном
\href{https://github.com/radareorg/radare2-book/raw/master/src/crackmes/ioli/IOLI-crackme.tar.gz}{зеркале}

\hypertarget{ioli-0x00}{%
\section{IOLI 0x00}\label{ioli-0x00}}

Первая задачка IOLI, самая простая.

\begin{verbatim}
$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 1234
Invalid Password!
\end{verbatim}

Первое, что проверяется - пароль, он может быть просто открытым текстом
внутри файла. Если это так, то ломать дальше ничего не нужно: используем
rabin2 с флагом -z для перечисления строк в двоичном файле.

\begin{verbatim}
$ rabin2 -z ./crackme0x00
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
1   0x00000581 0x08048581 10  11   .rodata ascii Password:
2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
\end{verbatim}

Что представляет собой полученный текст? - это заголовок, отображаемым
при запуске приложения.

\begin{verbatim}
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000568 0x08048568 24  25   .rodata ascii IOLI Crackme Level 0x00\n
\end{verbatim}

Эта строка - текст приглашения для ввода пароля.

\begin{verbatim}
1   0x00000581 0x08048581 10  11   .rodata ascii Password:
\end{verbatim}

Эта - вывод сообщения об ошибке при вводе неверного пароля.

\begin{verbatim}
3   0x00000596 0x08048596 18  19   .rodata ascii Invalid Password!\n
\end{verbatim}

Здесь говорится, что пароль принят.

\begin{verbatim}
4   0x000005a9 0x080485a9 15  16   .rodata ascii Password OK :)\n
\end{verbatim}

А это что? Это строка, но ее не было при запуске приложения.

\begin{verbatim}
2   0x0000058f 0x0804858f 6   7    .rodata ascii 250382
\end{verbatim}

Давайте попробуем ее в качестве пароля.

\begin{verbatim}
$ ./crackme0x00
IOLI Crackme Level 0x00
Password: 250382
Password OK :)
\end{verbatim}

Ну вот, теперь ясно, что 250382 - это и есть пароль, на этом взлом
закончен.

\hypertarget{ioli-0x01}{%
\section{IOLI 0x01}\label{ioli-0x01}}

Вторая задачка IOLI crackme.

\begin{verbatim}
$ ./crackme0x01
IOLI Crackme Level 0x01
Password: test
Invalid Password!
\end{verbatim}

Посмотрим перечень строк при помощи rabin2.

\begin{verbatim}
$ rabin2 -z ./crackme0x01
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000528 0x08048528 24  25   .rodata ascii IOLI Crackme Level 0x01\n
1   0x00000541 0x08048541 10  11   .rodata ascii Password:
2   0x0000054f 0x0804854f 18  19   .rodata ascii Invalid Password!\n
3   0x00000562 0x08048562 15  16   .rodata ascii Password OK :)\n
\end{verbatim}

Видно, что взлом будет не на столько прост как в задаче 0x00. Попробуем
дизассемблировать, используя r2.

\begin{verbatim}
$ r2 ./crackme0x01
-- Use `zoom.byte=printable` in zoom mode ('z' in Visual mode) to find strings
[0x08048330]> aa
[0x08048330]> pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 113: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01 ; [0x8048528:4]=0x494c4f49 ; "IOLI Crackme Level 0x01\n"
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 ; "Password: "
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      817dfc9a1400.  cmp dword [var_4h], 0x149a
|       ,=< 0x08048432      740e           je 0x8048442
|       |   0x08048434      c704244f8504.  mov dword [esp], str.Invalid_Password ; [0x804854f:4]=0x61766e49 ; "Invalid Password!\n"
|       |   0x0804843b      e8dcfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==< 0x08048440      eb0c           jmp 0x804844e
|      |`-> 0x08048442      c70424628504.  mov dword [esp], str.Password_OK_: ; [0x8048562:4]=0x73736150 ; "Password OK :)\n"
|      |    0x08048449      e8cefeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x8048440
|      `--> 0x0804844e      b800000000     mov eax, 0
|           0x08048453      c9             leave
\           0x08048454      c3             ret
\end{verbatim}

Команда «aa» заставляет r2 проанализировать весь двоичный файл, в
результате, среди прочего, получим имена символов (идентификаторов
сущностей).

Комбинация ``pdf'' - это сокращение от

\begin{itemize}
\item
  Print (распечатать)
\item
  Disassemble (в дизассемблированном виде)
\item
  Function (функцию)
\end{itemize}

Команда распечатает код основной функции в виде ассемблерных инструкций,
т.е. известной всем функции \texttt{main()}. В тексте много всего,
включая странные имена, стрелки и т.д.

\begin{itemize}
\item
  ``imp.'' - сокращение от ``imports''. Это импортированные символы,
  такие как printf()
\item
  ``str.'' - сокращение от ``strings''. Это, очевидно, строки.
\end{itemize}

Смотрим внимательно, находим инструкцию \texttt{cmp} с константой
0x149a. \texttt{cmp} - инструкция сравнения в архитектуре x86, а 0x -
префикс, задающий 16-ричную систему счисления (hexadecimal, hex) для
числа константы.

\begin{verbatim}
0x0804842b    817dfc9a140. cmp dword [ebp + 0xfffffffc], 0x149a
\end{verbatim}

Можно использовать команду radare2 \texttt{?} для распечатки 0x149a в
другой системе счисления.

\begin{verbatim}
[0x08048330]> ? 0x149a
int32   5274
uint32  5274
hex     0x149a
octal   012232
unit    5.2K
segment 0000:049a
string  "\x9a\x14"
fvalue: 5274.0
float:  0.000000f
double: 0.000000
binary  0b0001010010011010
trits   0t21020100
\end{verbatim}

Теперь понятно, что 0x149a равно 5274 в десятичной системе счисления.
Давайте попробуем это в качестве пароля.

\begin{verbatim}
$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 5274
Password OK :)
\end{verbatim}

Бинго, пароль - 5274. В этом случае функция пароля в 0x0804842b
сравнивала входные данные со значением 0x149a (шестнадцатеричный
формат). Поскольку вводят числа обычно в десятичной системе счисления,
нетрудно догадаться, что ввод пароля должен быть в десятичном формате
или 5274. Поскольку мы хакеры, и любопытство движет нами, давайте
посмотрим, что происходит, когда мы вводим в шестнадцатеричном виде.

\begin{verbatim}
$ ./crackme0x01
IOLI Crackme Level 0x01
Password: 0x149a
Invalid Password!
\end{verbatim}

Стоило попытаться, но не сработало. Проблема в том, что \texttt{scanf()}
принимает 0 в 0x149a как символ нуля, а остальные данные в связи с этим
не принимаются как шестнадцатеричное значение.

На этом все с задачей IOLI 0x01.

\hypertarget{ioli-0x02}{%
\section{IOLI 0x02}\label{ioli-0x02}}

Третья задача.

\begin{verbatim}
$ ./crackme0x02
IOLI Crackme Level 0x02
Password: hello
Invalid Password!
\end{verbatim}

Посмотрим файл с помощью rabin2.

\begin{verbatim}
$ rabin2 -z ./crackme0x02
[Strings]
nth paddr      vaddr      len size section type  string
-------------------------------------------------------
0   0x00000548 0x08048548 24  25   .rodata ascii IOLI Crackme Level 0x02\n
1   0x00000561 0x08048561 10  11   .rodata ascii Password:
2   0x0000056f 0x0804856f 15  16   .rodata ascii Password OK :)\n
3   0x0000057f 0x0804857f 18  19   .rodata ascii Invalid Password!\n
\end{verbatim}

Аналогично задаче 0x01, здесь нет строки с явным паролем, проанализируем
код с помощью r2.

\begin{verbatim}
[0x08048330]> aa
[x] Провести анализ всех флагов, начинающихся с sym. и entry0 (aa)
[0x08048330]> pdf@main
            ; DATA XREF from entry0 @ 0x8048347
/ 144: int main (int argc, char **argv, char **envp);
|           ; var int32_t var_ch @ ebp-0xc
|           ; var int32_t var_8h @ ebp-0x8
|           ; var int32_t var_4h @ ebp-0x4
|           ; var int32_t var_sp_4h @ esp+0x4
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424488504.  mov dword [esp], str.IOLI_Crackme_Level_0x02 ; [0x8048548:4]=0x494c4f49 ; "IOLI Crackme Level 0x02\n"
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424618504.  mov dword [esp], str.Password: ; [0x8048561:4]=0x73736150 ; "Password: "
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [var_4h]
|           0x0804841b      89442404       mov dword [var_sp_4h], eax
|           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      c745f85a0000.  mov dword [var_8h], 0x5a    ; 'Z' ; 90
|           0x08048432      c745f4ec0100.  mov dword [var_ch], 0x1ec   ; 492
|           0x08048439      8b55f4         mov edx, dword [var_ch]
|           0x0804843c      8d45f8         lea eax, [var_8h]
|           0x0804843f      0110           add dword [eax], edx
|           0x08048441      8b45f8         mov eax, dword [var_8h]
|           0x08048444      0faf45f8       imul eax, dword [var_8h]
|           0x08048448      8945f4         mov dword [var_ch], eax
|           0x0804844b      8b45fc         mov eax, dword [var_4h]
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
|       ,=< 0x08048451      750e           jne 0x8048461
|       |   0x08048453      c704246f8504.  mov dword [esp], str.Password_OK_: ; [0x804856f:4]=0x73736150 ; "Password OK :)\n"
|       |   0x0804845a      e8bdfeffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==< 0x0804845f      eb0c           jmp 0x804846d
|      |`-> 0x08048461      c704247f8504.  mov dword [esp], str.Invalid_Password ; [0x804857f:4]=0x61766e49 ; "Invalid Password!\n"
|      |    0x08048468      e8affeffff     call sym.imp.printf         ; int printf(const char *format)
|      |    ; CODE XREF from main @ 0x804845f
|      `--> 0x0804846d      b800000000     mov eax, 0
|           0x08048472      c9             leave
\           0x08048473      c3             ret
\end{verbatim}

Имея опыт решения crackme0x02, сначала ищем инструкцию \texttt{cmp} при
помощи простой команды:

\begin{verbatim}
[0x08048330]> pdf@main | grep cmp
|           0x0804844e      3b45f4         cmp eax, dword [var_ch]
\end{verbatim}

К сожалению, переменная, сравниваемая с eax, хранится где-то в стеке.
Проверить значение этой переменной напрямую невозможно -
распространенный случай в реверс-инжениринге. Нужно вычислить значение
переменной, анализируя инструкции, стоящие перед cmp. Поскольку объем
кода относительно невелик, это вполне возможно.

Пример:

\begin{verbatim}
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf                ; 15
|           0x080483f5      83c00f         add eax, 0xf                ; 15
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
\end{verbatim}

Легко получается значение в регистре eax. Оно равно 0x16.

Становится сложновато, когда объем кода растет. Radare2 позволяет
выводить дизассемблированный код в формате подобном C, что весьма бывает
полезно.

\begin{verbatim}
[0x08048330]> pdc@main
function main () {
    //  4 функциональных блока

    loc_0x80483e4:

         //DATA XREF from entry0 @ 0x8048347
       push ebp
       ebp = esp
       esp -= 0x18
       esp &= 0xfffffff0
       eax = 0
       eax += 0xf               //15
       eax += 0xf               //15
       eax >>>= 4
       eax <<<= 4
       esp -= eax
       dword [esp] = "IOLI Crackme Level 0x02\n" //[0x8048548:4]=0x494c4f49 ; str.IOLI_Crackme_Level_0x02 ; const char *format

       int printf("IOLI Crackme Level 0x02\n")
       dword [esp] = "Password: " //[0x8048561:4]=0x73736150 ; str.Password: ; const char *format

       int printf("Password: ")
       eax = var_4h
       dword [var_sp_4h] = eax
       dword [esp] = 0x804856c  //[0x804856c:4]=0x50006425 ; const char *format
       int scanf("%d")
                               //sym.imp.scanf ()
       dword [var_8h] = 0x5a    //'Z' ; 90
       dword [var_ch] = 0x1ec   //492
       edx = dword [var_ch]
       eax = var_8h             //"Z"
       dword [eax] += edx
       eax = dword [var_8h]
       eax = eax * dword [var_8h]
       dword [var_ch] = eax
       eax = dword [var_4h]
       var = eax - dword [var_ch]
       if (var) goto 0x8048461  //likely
       {
        loc_0x8048461:

           //CODE XREF from main @ 0x8048451
           dword [esp] = s"Invalid Password!\n"//[0x804857f:4]=0x61766e49 ; str.Invalid_Password ; const char *format

           int printf("Invalid ")
       do
       {
            loc_0x804846d:

               //CODE XREF from main @ 0x804845f
               eax = 0
               leave                    //(pstr 0x0804857f) "Invalid Password!\n" ebp ; str.Invalid_Password
               return
           } while (?);
       } while (?);
      }
      return;

}
\end{verbatim}

Команда \texttt{pdc} ненадежна, особенно при анализе циклов обработки
данных (while, for и т.д.). Поэтому предпочтительно использовать плагин
\href{https://github.com/radareorg/r2dec-js}{r2dec} в репозитории r2 для
генерации псевдокода C. Он легко устанавливается:

\begin{verbatim}
r2pm install r2dec
\end{verbatim}

декомпилируем \texttt{main()}, используя команду (типа \texttt{F5} в
IDA):

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x08048330}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@main}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x02 @ 0x80483e4 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ main }\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_ch}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_sp\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textgreater{}\textgreater{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textless{}\textless{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x02}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
    \OperatorTok{*((}\NormalTok{esp }\OperatorTok{+} \DecValTok{4}\OperatorTok{))} \OperatorTok{=}\NormalTok{ eax}\OperatorTok{;}
\NormalTok{    scanf }\OperatorTok{(}\BaseNTok{0x804856c}\OperatorTok{);}
\NormalTok{    var\_8h }\OperatorTok{=} \BaseNTok{0x5a}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=} \BaseNTok{0x1ec}\OperatorTok{;}
\NormalTok{    edx }\OperatorTok{=} \BaseNTok{0x1ec}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_8h}\OperatorTok{;}
    \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)} \OperatorTok{+=}\NormalTok{ edx}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ var\_8h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{*=}\NormalTok{ var\_8h}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=}\NormalTok{ eax}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{eax }\OperatorTok{==}\NormalTok{ var\_ch}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf }\OperatorTok{(}\StringTok{"Password OK :)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf }\OperatorTok{(}\StringTok{"Invalid Password!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Теперь это более человекочитабельно. Чтобы посмотреть строку в
0x804856c, можно: * seek (установить смещение), * print string
(распечатать строку).

\begin{verbatim}
[0x08048330]> s 0x804856c
[0x0804856c]> ps
%d
\end{verbatim}

Получили строку формата, используемую в \texttt{scanf()}. Однако r2dec
не распознает второй аргумент (eax) - указатель. Он указывает на var\_4h
и означает, что входные данные будут именно там храниться.

Теперь можно легко выписать псевдокод.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_ch }\OperatorTok{=} \OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{+}\NormalTok{ var\_ch}\OperatorTok{)\^{}}\DecValTok{2}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{==}\NormalTok{ our\_input}\OperatorTok{)}
\NormalTok{  printf}\OperatorTok{(}\StringTok{"Password OK :)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Учитывая, что первоначальное значение переменной var\_8h равно 0x5a, а
var\_ch равно 0x1ec, получаем var\_ch = 338724 (0x52b24):

\begin{verbatim}
$ rax2 '=10' '(0x5a+0x1ec)*(0x5a+0x1ec)'
338724

$ ./crackme0x02
IOLI Crackme Level 0x02
Password: 338724
Password OK :)
\end{verbatim}

Вот и все с crackme0x02.

\hypertarget{ioli-0x03}{%
\section{IOLI 0x03}\label{ioli-0x03}}

Задача crackme 0x03. Пропустим поиск строк и сразу все проанализируем.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x08048360}\OperatorTok{]\textgreater{}}\NormalTok{ aaa}
\OperatorTok{[}\BaseNTok{0x08048360}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@sym}\OperatorTok{.}\NormalTok{main}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x03 @ 0x8048498 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ main }\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_ch}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_sp\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textgreater{}\textgreater{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textless{}\textless{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x03}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
\NormalTok{    scanf }\OperatorTok{(}\BaseNTok{0x8048634}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{);}
\NormalTok{    var\_8h }\OperatorTok{=} \BaseNTok{0x5a}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=} \BaseNTok{0x1ec}\OperatorTok{;}
\NormalTok{    edx }\OperatorTok{=} \BaseNTok{0x1ec}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_8h}\OperatorTok{;}
    \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)} \OperatorTok{+=}\NormalTok{ edx}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ var\_8h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{*=}\NormalTok{ var\_8h}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=}\NormalTok{ eax}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{    test }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Выглядит просто, за исключением функции \texttt{test(eax,\ eax)}.
Необычно вызывать функцию с двумя одинаковыми параметрами, можно
предположить, что декомпиляция прошла не совсем так, как требуется.
Посмотрим код в виде инструкций процессора.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[0x08048360]\textgreater{} pdf}\FunctionTok{@}\ErrorTok{s}\NormalTok{ym}\OperatorTok{.}\NormalTok{main}
\NormalTok{...}
\NormalTok{           0x080484fc      8945f4         }\BuiltInTok{mov} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{           0x080484ff      8b45f4         }\BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{]}
\NormalTok{           0x08048502      89442404       }\BuiltInTok{mov} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_sp\_4h}\OperatorTok{],} \KeywordTok{eax}   \CommentTok{; uint32\_t arg\_ch}
\NormalTok{           0x08048506      8b45fc         }\BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_4h}\OperatorTok{]}
\NormalTok{           0x08048509      890424         }\BuiltInTok{mov} \DataTypeTok{dword} \OperatorTok{[}\KeywordTok{esp}\OperatorTok{],} \KeywordTok{eax}         \CommentTok{; int32\_t arg\_8h}
\NormalTok{           0x0804850c      e85dffffff     call sym}\OperatorTok{.}\NormalTok{test}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

В наличии \texttt{sym.test}, вызываемый с двумя параметрами. Один
параметр - var\_4h (наш ввод из \texttt{scanf()}). Другой -
var\_ch.~Значение var\_ch (как параметр \texttt{test()}) можно
вычислить, как это было в задаче crackme\_0x02. Оно равно 0x52b24.
Пробуем!

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./crackme0x03}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x03}
\ExtensionTok{Password:}\NormalTok{ 338724}
\ExtensionTok{Password}\NormalTok{ OK!!! :}\ErrorTok{)}
\end{Highlighting}
\end{Shaded}

Смотрим на \texttt{sym.test}. Это условный переход с двумя ветвями,
сравнивающий два параметра, потом производится сдвиг (shift). Догадка
состоит в том, сдвиг, скорее всего, является частью некоторой процедуры
расшифровки (шифр сдвига, например, шифр Цезаря).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x03 @ 0x804846e */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ test }\OperatorTok{(}\DataTypeTok{int32\_t}\NormalTok{ arg\_8h}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ arg\_ch}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ arg\_8h}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{eax }\OperatorTok{!=}\NormalTok{ arg\_ch}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        shift }\OperatorTok{(}\StringTok{"Lqydolg\#Sdvvzrug$"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        shift }\OperatorTok{(}\StringTok{"Sdvvzrug\#RN$$$\#=,"}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Взломаем \texttt{shift()} - удовлетворим наше любопытство.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[0x08048360]\textgreater{} pdf}\FunctionTok{@}\ErrorTok{s}\NormalTok{ym}\OperatorTok{.}\NormalTok{shift}
        \CommentTok{; CODE (CALL) XREF 0x08048491 (sym.test)}
        \CommentTok{; CODE (CALL) XREF 0x08048483 (sym.test)}
\NormalTok{/ function}\OperatorTok{:}\NormalTok{ sym}\OperatorTok{.}\NormalTok{shift }\OperatorTok{(}\DecValTok{90}\OperatorTok{)}
\NormalTok{|       0x08048414  sym}\OperatorTok{.}\NormalTok{shift}\OperatorTok{:}
\NormalTok{|       0x08048414     55               }\BuiltInTok{push} \KeywordTok{ebp}
\NormalTok{|       0x08048415     89e5             }\BuiltInTok{mov} \KeywordTok{ebp}\OperatorTok{,} \KeywordTok{esp}
\NormalTok{|       0x08048417     81ec98000000     }\BuiltInTok{sub} \KeywordTok{esp}\OperatorTok{,} \BaseNTok{0x98}
\NormalTok{|       0x0804841d     c7458400000000   mov }\DataTypeTok{dword} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{],} \BaseNTok{0x0}  \CommentTok{; this seems to be a counter}
\NormalTok{|  .    }\CommentTok{; CODE (JMP) XREF 0x0804844e (sym.shift)}
\NormalTok{/ loc}\OperatorTok{:}\NormalTok{ loc}\OperatorTok{.}\DecValTok{08048424} \OperatorTok{(}\DecValTok{74}\OperatorTok{)}
\NormalTok{|  .    0x08048424  loc}\OperatorTok{.}\DecValTok{08048424}\OperatorTok{:}
\NormalTok{|  .{-}{-}\textgreater{} 0x08048424     8b4508           }\BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{+}\BaseNTok{0x8}\OperatorTok{]} \CommentTok{; ebp+0x8 = strlen(chain)}
\NormalTok{|  |    0x08048427     890424           }\BuiltInTok{mov} \OperatorTok{[}\KeywordTok{esp}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{|  |    0x0804842a     e811ffffff       call }\DataTypeTok{dword}\NormalTok{ imp}\OperatorTok{.}\NormalTok{strlen}
\NormalTok{|  |       }\CommentTok{; imp.strlen()}
\NormalTok{|  |    0x0804842f     394584           }\BuiltInTok{cmp} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{|  |,=\textless{} 0x08048432     731c             }\ControlFlowTok{jae}\NormalTok{ loc}\OperatorTok{.}\DecValTok{08048450}
\NormalTok{|  ||   0x08048434     8d4588           }\BuiltInTok{lea} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x78}\OperatorTok{]}
\NormalTok{|  ||   0x08048437     89c2             }\BuiltInTok{mov} \KeywordTok{edx}\OperatorTok{,} \KeywordTok{eax}
\NormalTok{|  ||   0x08048439     035584           }\BuiltInTok{add} \KeywordTok{edx}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{]}
\NormalTok{|  ||   0x0804843c     8b4584           }\BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{]}
\NormalTok{|  ||   0x0804843f     034508           }\BuiltInTok{add} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{+}\BaseNTok{0x8}\OperatorTok{]}
\NormalTok{|  ||   0x08048442     0fb600           }\BuiltInTok{movzx} \KeywordTok{eax}\OperatorTok{,} \DataTypeTok{byte} \OperatorTok{[}\KeywordTok{eax}\OperatorTok{]}
\NormalTok{|  ||   0x08048445     2c03             }\BuiltInTok{sub} \KeywordTok{al}\OperatorTok{,} \BaseNTok{0x3}
\NormalTok{|  ||   0x08048447     8802             }\BuiltInTok{mov} \OperatorTok{[}\KeywordTok{edx}\OperatorTok{],} \KeywordTok{al}
\NormalTok{|  ||   0x08048449     8d4584           }\BuiltInTok{lea} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{]}
\NormalTok{|  ||   0x0804844c     ff00             inc }\DataTypeTok{dword} \OperatorTok{[}\KeywordTok{eax}\OperatorTok{]}
\NormalTok{|  \textasciigrave{}==\textless{} 0x0804844e     ebd4             jmp loc}\OperatorTok{.}\DecValTok{08048424}
\NormalTok{|   |   }\CommentTok{; CODE (JMP) XREF 0x08048432 (sym.shift)}
\NormalTok{/ loc}\OperatorTok{:}\NormalTok{ loc}\OperatorTok{.}\DecValTok{08048450} \OperatorTok{(}\DecValTok{30}\OperatorTok{)}
\NormalTok{|   |   0x08048450  loc}\OperatorTok{.}\DecValTok{08048450}\OperatorTok{:}
\NormalTok{|   \textasciigrave{}{-}\textgreater{} 0x08048450     8d4588           }\BuiltInTok{lea} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x78}\OperatorTok{]}
\NormalTok{|       0x08048453     034584           }\BuiltInTok{add} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x7c}\OperatorTok{]}
\NormalTok{|       0x08048456     c60000           mov }\DataTypeTok{byte} \OperatorTok{[}\KeywordTok{eax}\OperatorTok{],} \BaseNTok{0x0}
\NormalTok{|       0x08048459     8d4588           }\BuiltInTok{lea} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\KeywordTok{ebp}\OperatorTok{{-}}\BaseNTok{0x78}\OperatorTok{]}
\NormalTok{|       0x0804845c     89442404         }\BuiltInTok{mov} \OperatorTok{[}\KeywordTok{esp}\OperatorTok{+}\BaseNTok{0x4}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{|       0x08048460     c70424e8850408   mov }\DataTypeTok{dword} \OperatorTok{[}\KeywordTok{esp}\OperatorTok{],} \BaseNTok{0x80485e8}
\NormalTok{|       0x08048467     e8e4feffff       call }\DataTypeTok{dword}\NormalTok{ imp}\OperatorTok{.}\NormalTok{printf}
\NormalTok{|          }\CommentTok{; imp.printf()}
\NormalTok{|       0x0804846c     c9               leave}
\NormalTok{\textbackslash{}       0x0804846d     c3               ret}
        \CommentTok{; {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\end{Highlighting}
\end{Shaded}

Прочитав ассемблерный код, обнаруживаем, что расшифровка на самом деле -
``sub al, 0x3''. Напишем программу python:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{.join([}\BuiltInTok{chr}\NormalTok{(}\BuiltInTok{ord}\NormalTok{(i)}\OperatorTok{{-}}\BaseNTok{0x3}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \StringTok{\textquotesingle{}SdvvzrugRN$$$\textquotesingle{}}\NormalTok{]))}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{.join([}\BuiltInTok{chr}\NormalTok{(}\BuiltInTok{ord}\NormalTok{(i)}\OperatorTok{{-}}\BaseNTok{0x3}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \StringTok{\textquotesingle{}LqydolgSdvvzrug$\textquotesingle{}}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

Проще \texttt{запустить} этот код расшифровки, то есть отладить его или
эмулировать. Попытка использования эмулятора ESIL radare2 провалилась,
он завис при выполнении \texttt{call\ dword\ imp.strlen}. Также не
удалось воспользоваться функцией hooking / пропуск инструкции в radare2.
Ниже приведен пример эмуляции ESIL.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{[0x08048414]}\OperatorTok{\textgreater{}}\NormalTok{ s 0x08048445      }\CommentTok{\# the \textquotesingle{}sub al, 0x03\textquotesingle{}}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ aei               }\CommentTok{\# init VM}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ aeim              }\CommentTok{\# init memory}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ aeip              }\CommentTok{\# init ip}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ aer eax=0x41      }\CommentTok{\# set eax=0x41 {-}{-} \textquotesingle{}A\textquotesingle{}}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ aer               }\CommentTok{\# show current value of regs}
\ExtensionTok{oeax}\NormalTok{ = 0x00000000}
\ExtensionTok{eax}\NormalTok{ = 0x00000041}
\ExtensionTok{ebx}\NormalTok{ = 0x00000000}
\ExtensionTok{ecx}\NormalTok{ = 0x00000000}
\ExtensionTok{edx}\NormalTok{ = 0x00000000}
\ExtensionTok{esi}\NormalTok{ = 0x00000000}
\ExtensionTok{edi}\NormalTok{ = 0x00000000}
\ExtensionTok{esp}\NormalTok{ = 0x00178000}
\ExtensionTok{ebp}\NormalTok{ = 0x00178000}
\ExtensionTok{eip}\NormalTok{ = 0x08048445}
\ExtensionTok{eflags}\NormalTok{ = 0x00000000}
\ExtensionTok{[0x08048445]}\OperatorTok{\textgreater{}}\NormalTok{ V                 }\CommentTok{\# enter Visual mode}
\CommentTok{\# \textquotesingle{}p\textquotesingle{} or \textquotesingle{}P\textquotesingle{} to change visual mode}
\CommentTok{\# I prefer the [xaDvc] mode}
\CommentTok{\# use \textquotesingle{}s\textquotesingle{} to step in and \textquotesingle{}S\textquotesingle{} to step over}
\ExtensionTok{[0x08048442}\NormalTok{ [xaDvc]0 0\% 265 ./crackme0x03]}\OperatorTok{\textgreater{}}\NormalTok{ diq}\KeywordTok{;}\ExtensionTok{?0}\KeywordTok{;}\ExtensionTok{f}\NormalTok{ t.. @ sym.shift+46 }\CommentTok{\# 0x8048442}
\ExtensionTok{dead}\NormalTok{ at 0x00000000}
\ExtensionTok{{-}}\NormalTok{ offset }\AttributeTok{{-}}\NormalTok{   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF}
\ExtensionTok{0x00178000}\NormalTok{  0000 0000 0000 0000 0000 0000 0000 0000  ................}
\ExtensionTok{0x00178010}\NormalTok{  0000 0000 0000 0000 0000 0000 0000 0000  ................}
\ExtensionTok{0x00178020}\NormalTok{  0000 0000 0000 0000 0000 0000 0000 0000  ................}
\ExtensionTok{0x00178030}\NormalTok{  0000 0000 0000 0000 0000 0000 0000 0000  ................}
   \ExtensionTok{oeax}\NormalTok{ 0x00000000      eax 0x00000041      ebx 0x00000000      ecx 0x00000000}
    \ExtensionTok{edx}\NormalTok{ 0x00000000      esi 0x00000000      edi 0x00000000      esp 0x00178000}
    \ExtensionTok{ebp}\NormalTok{ 0x00178000      eip 0x08048445   eflags 0x00000000}
       \BuiltInTok{:}\NormalTok{   0x08048442      0fb600         movzx eax, byte [eax]}
       \BuiltInTok{:}   \KeywordTok{;}\ExtensionTok{{-}{-}}\NormalTok{ eip:}
       \BuiltInTok{:}\NormalTok{   0x08048445      2c03           sub al, 3}
       \BuiltInTok{:}\NormalTok{   0x08048447      8802           mov byte [edx], al}
       \BuiltInTok{:}\NormalTok{   0x08048449      8d4584         lea eax, [var\_7ch]}
       \BuiltInTok{:}\NormalTok{   0x0804844c      ff00           inc dword [eax]}
       \BuiltInTok{:}\NormalTok{=}\OperatorTok{\textless{}}\NormalTok{ 0x0804844e      ebd4           jmp 0x8048424}
           \KeywordTok{;} \ExtensionTok{CODE}\NormalTok{ XREF from sym.shift @ 0x8048432}
           \ExtensionTok{0x08048450}\NormalTok{      8d4588         lea eax, [var\_78h]}
\end{Highlighting}
\end{Shaded}

Кстати, можно открыть файл и использовать команду ``write data'' для
расшифровки данных.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{r2} \AttributeTok{{-}w}\NormalTok{ ./crackme0x03}
\ExtensionTok{[0x08048360]}\OperatorTok{\textgreater{}}\NormalTok{ aaa}
\ExtensionTok{[0x08048360]}\OperatorTok{\textgreater{}}\NormalTok{ fs strings}
\ExtensionTok{[0x08048360]}\OperatorTok{\textgreater{}}\NormalTok{ f}
\ExtensionTok{0x080485ec}\NormalTok{ 18 str.Lqydolg\_Sdvvzrug}
\ExtensionTok{0x080485fe}\NormalTok{ 18 str.Sdvvzrug\_RN}
\ExtensionTok{0x08048610}\NormalTok{ 25 str.IOLI\_Crackme\_Level\_0x03}
\ExtensionTok{0x08048629}\NormalTok{ 11 str.Password:}
\ExtensionTok{[0x08048360]}\OperatorTok{\textgreater{}}\NormalTok{ s str.Lqydolg\_Sdvvzrug}
\ExtensionTok{[0x080485ec]}\OperatorTok{\textgreater{}}\NormalTok{ wos 0x03 @ str.Lqydolg\_Sdvvzrug!0x11}
\ExtensionTok{[0x080485ec]}\OperatorTok{\textgreater{}}\NormalTok{ px}
\ExtensionTok{{-}}\NormalTok{ offset }\AttributeTok{{-}}\NormalTok{   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF}
\ExtensionTok{0x080485ec}\NormalTok{  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password}
\ExtensionTok{0x080485fc}\NormalTok{  2100 5364 7676 7a72 7567 2352 4e24 2424  !.Sdvvzrug\#RN}\VariableTok{$$}\NormalTok{$}
\ExtensionTok{0x0804860c}\NormalTok{  233d 2c00 494f 4c49 2043 7261 636b 6d65  }\CommentTok{\#=,.IOLI Crackme}
\ExtensionTok{0x0804861c}\NormalTok{  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas}
\ExtensionTok{0x0804862c}\NormalTok{  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .\%d......}
\ExtensionTok{[0x080485ec]}\OperatorTok{\textgreater{}}\NormalTok{ wos 0x03 @ str.Sdvvzrug\_RN!17}
\ExtensionTok{[0x080485ec]}\OperatorTok{\textgreater{}}\NormalTok{ px}
\ExtensionTok{{-}}\NormalTok{ offset }\AttributeTok{{-}}\NormalTok{   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF}
\ExtensionTok{0x080485ec}\NormalTok{  496e 7661 6c69 6420 5061 7373 776f 7264  Invalid Password}
\ExtensionTok{0x080485fc}\NormalTok{  2100 5061 7373 776f 7264 204f 4b21 2121  !.Password OK!!!}
\ExtensionTok{0x0804860c}\NormalTok{  203a 2900 494f 4c49 2043 7261 636b 6d65   :}\ErrorTok{)}\ExtensionTok{.IOLI}\NormalTok{ Crackme}
\ExtensionTok{0x0804861c}\NormalTok{  204c 6576 656c 2030 7830 330a 0050 6173   Level 0x03..Pas}
\ExtensionTok{0x0804862c}\NormalTok{  7377 6f72 643a 2000 2564 0000 0000 0000  sword: .\%d......}
\ExtensionTok{[0x080485ec]}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ioli-0x04}{%
\section{IOLI 0x04}\label{ioli-0x04}}

\hypertarget{x04}{%
\section{0x04}\label{x04}}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x080483d0}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@main}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x04 @ 0x8048509 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ main }\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_78h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textgreater{}\textgreater{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textless{}\textless{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x04}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    scanf }\OperatorTok{(}\BaseNTok{0x8048682}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    check }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Входим в функцию check.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ check }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ var\_dh}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_ch}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ format}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_sp\_8h}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ strlen }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{\textgreater{}=}\NormalTok{ eax}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{goto}\NormalTok{ label\_0}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ var\_ch}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{+=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{*(}\NormalTok{eax}\OperatorTok{);}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ al}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_dh}\OperatorTok{;}
\NormalTok{        sscanf }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{,} \BaseNTok{0x8048638}\OperatorTok{);}
\NormalTok{        edx }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_8h}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)} \OperatorTok{+=}\NormalTok{ edx}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0xf}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf }\OperatorTok{(}\StringTok{"Password OK!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{            exit }\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_ch}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)++;}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{label\_0}\OperatorTok{:}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Анализируя вручную ассемблерный код и псевдокод, можно просто выписать
C-подобный код для описания этой функции:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\DataTypeTok{int32\_t}\NormalTok{ check}\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_ch }\OperatorTok{\textless{}}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{s}\OperatorTok{);} \OperatorTok{++}\NormalTok{var\_ch}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ s}\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{];}
\NormalTok{        sscanf}\OperatorTok{(\&}\NormalTok{var\_dh}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}           \CommentTok{// read from string[var\_ch], store to var\_4h}
\NormalTok{        var\_8h }\OperatorTok{+=}\NormalTok{ var\_4h}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0xf}\OperatorTok{)}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Password OK}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Короче говоря, вычисляется сумма цифр некоторого числа (сложение цифры
за цифрой), например, 96 =\textgreater{} 9 + 6 = 15) :

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./crackme0x04}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x04}
\ExtensionTok{Password:}\NormalTok{ 12345}
\ExtensionTok{Password}\NormalTok{ OK!}

\ExtensionTok{./crackme0x04}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x04}
\ExtensionTok{Password:}\NormalTok{ 96}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

\hypertarget{ioli-0x05}{%
\section{IOLI 0x05}\label{ioli-0x05}}

Смотрим код, в нем используется \texttt{scanf()} для получения ввода,
затем ввод передается в функцию \texttt{check()} в качестве параметра.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x080483d0}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@main}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x05 @ 0x8048540 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ main }\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_78h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textgreater{}\textgreater{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textless{}\textless{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x05}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    scanf }\OperatorTok{(}\BaseNTok{0x80486b2}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{);}         \CommentTok{// 0x80486b2 is \%s}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    check }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Уже встречавшаяся функция check():

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x05 @ 0x80484c8 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ check }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ var\_dh}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_ch}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ format}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_sp\_8h}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ strlen }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{\textgreater{}=}\NormalTok{ eax}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{goto}\NormalTok{ label\_0}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ var\_ch}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{+=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{*(}\NormalTok{eax}\OperatorTok{);}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ al}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_dh}\OperatorTok{;}
\NormalTok{        sscanf }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{,} \BaseNTok{0x8048668}\OperatorTok{);}           \CommentTok{// 0x8048668 is \%d}
\NormalTok{        edx }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_8h}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)} \OperatorTok{+=}\NormalTok{ edx}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0x10}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{            parell }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_ch}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)++;}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{label\_0}\OperatorTok{:}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Точно так же можно написать наш собственный C-подобный псевдокод.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\DataTypeTok{int32\_t}\NormalTok{ check}\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_ch }\OperatorTok{\textless{}}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{s}\OperatorTok{);} \OperatorTok{++}\NormalTok{var\_ch}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ s}\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{];}
\NormalTok{        sscanf}\OperatorTok{(\&}\NormalTok{var\_dh}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}           \CommentTok{// read from string[var\_ch], store to var\_4h}
\NormalTok{        var\_8h }\OperatorTok{+=}\NormalTok{ var\_4h}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0x10}\OperatorTok{)}
\NormalTok{            parell}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Условие в if - \texttt{var\_8h\ ==\ 0x10}. Кроме того, новый вызов
функции - \texttt{parell(s)} заменяет теперь
\texttt{printf("пароль\ OK")} из предыдущей задачи. Следующим шагом
является взлом sym.parell.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x08048484}\OperatorTok{]\textgreater{}}\NormalTok{ s sym}\OperatorTok{.}\NormalTok{parell}
\OperatorTok{[}\BaseNTok{0x08048484}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@sym}\OperatorTok{.}\NormalTok{parell}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x05 @ 0x8048484 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{uint32\_t}\NormalTok{ parell }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ format}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{    sscanf }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{,} \BaseNTok{0x8048668}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\&=} \DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{eax }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf }\OperatorTok{(}\StringTok{"Password OK!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        exit }\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

С декомпилированным кодом все в порядке, за исключением функции
\texttt{sscanf()}. Его можно легко исправить, посмотрев ассемблерный
код.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{/ 68: sym}\OperatorTok{.}\NormalTok{parell }\OperatorTok{(}\NormalTok{int32\_t arg\_8h}\OperatorTok{)}\CommentTok{;}
\NormalTok{|           }\CommentTok{; var int32\_t var\_4h @ ebp{-}0x4}
\NormalTok{|           }\CommentTok{; arg int32\_t arg\_8h @ ebp+0x8}
\NormalTok{|           }\CommentTok{; var int32\_t var\_sp\_4h @ esp+0x4}
\NormalTok{|           }\CommentTok{; var int32\_t var\_8h @ esp+0x8}
\NormalTok{|           0x08048484      55             }\BuiltInTok{push} \KeywordTok{ebp}
\NormalTok{|           0x08048485      89e5           }\BuiltInTok{mov} \KeywordTok{ebp}\OperatorTok{,} \KeywordTok{esp}
\NormalTok{|           0x08048487      83ec18         }\BuiltInTok{sub} \KeywordTok{esp}\OperatorTok{,} \BaseNTok{0x18}
\NormalTok{|           0x0804848a      8d45fc         }\BuiltInTok{lea} \KeywordTok{eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{var\_4h}\OperatorTok{]}
\NormalTok{|           0x0804848d      89442408       }\BuiltInTok{mov} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_8h}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{|           0x08048491      c74424046886}\OperatorTok{.}\NormalTok{  mov }\DataTypeTok{dword} \OperatorTok{[}\NormalTok{var\_sp\_4h}\OperatorTok{],} \BaseNTok{0x8048668} \CommentTok{; [0x8048668:4]=0x50006425 \%d}
\NormalTok{|           0x08048499      8b4508         }\BuiltInTok{mov} \KeywordTok{eax}\OperatorTok{,} \DataTypeTok{dword} \OperatorTok{[}\NormalTok{arg\_8h}\OperatorTok{]}
\NormalTok{|           0x0804849c      890424         }\BuiltInTok{mov} \DataTypeTok{dword} \OperatorTok{[}\KeywordTok{esp}\OperatorTok{],} \KeywordTok{eax}
\NormalTok{|           0x0804849f      e800ffffff     call sym}\OperatorTok{.}\NormalTok{imp}\OperatorTok{.}\NormalTok{sscanf         }\CommentTok{; int sscanf(const char *s, const char *format,   ...)}
\NormalTok{....}
\end{Highlighting}
\end{Shaded}

Инструкция \texttt{mov\ dword\ {[}esp{]},\ eax} является ближайшей к
sscanf (она эквивалентна инструкции push). Он сохраняет строку `s' на
вершине стека (arg1). \texttt{mov\ dword\ {[}var\_sp\_4h{]},\ 0x8048668}
засылает `\%d' как arg2 в стек. Переменная var\_8h (esp + 0x8) хранит
адрес var\_4h, т.е. arg3.

Наконец, исправленный псевдокод -

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{uint32\_t}\NormalTok{ parell }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    sscanf }\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{((}\NormalTok{var\_4h }\OperatorTok{\&} \DecValTok{1}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf }\OperatorTok{(}\StringTok{"Password OK!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Выявлены два ограничения:

\begin{itemize}
\tightlist
\item
  Сумма цифр должна быть равна 16 (0x10),
\item
  Должно быть нечетным числом (1 \& number == 0).
\end{itemize}

Пароль теперь у нас под рукой.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./crackme0x05}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x05}
\ExtensionTok{Password:}\NormalTok{ 88}
\ExtensionTok{Password}\NormalTok{ OK!}

\ExtensionTok{./crackme0x05}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x05}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

Также можно использовать angr для решения этой задачи, так как заданы
два ограничения на пароль.

\hypertarget{ioli-0x06}{%
\section{IOLI 0x06}\label{ioli-0x06}}

Долгий процесс анализа этого двоичного файла (представление результата
далее в тексте не полное):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rabin2 {-}z ./crackme0x06}
\NormalTok{[Строки]}
\NormalTok{nth paddr      vaddr      len size section type  string}
\NormalTok{{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\NormalTok{0   0x00000738 0x08048738 4   5    .rodata ascii LOLO}
\NormalTok{1   0x00000740 0x08048740 13  14   .rodata ascii Password OK!\textbackslash{}n}
\NormalTok{2   0x0000074e 0x0804874e 20  21   .rodata ascii Password Incorrect!\textbackslash{}n}
\NormalTok{3   0x00000763 0x08048763 24  25   .rodata ascii IOLI Crackme Level 0x06\textbackslash{}n}
\NormalTok{4   0x0000077c 0x0804877c 10  11   .rodata ascii Password:}

\NormalTok{rabin2 {-}I ./crackme0x06}
\NormalTok{arch     x86}
\NormalTok{baddr    0x8048000}
\NormalTok{bintype  elf}
\NormalTok{bits     32}
\NormalTok{compiler GCC: (GNU) 3.4.6 (Gentoo 3.4.6{-}r2, ssp{-}3.4.6{-}1.0, pie{-}8.7.10)}
\NormalTok{crypto   false}
\NormalTok{endian   little}
\NormalTok{havecode true}
\NormalTok{lang     c}
\NormalTok{machine  Intel 80386}
\NormalTok{maxopsz  16}
\NormalTok{minopsz  1}
\NormalTok{os       linux}
\NormalTok{static   false}
\NormalTok{va       true}
\end{Highlighting}
\end{Shaded}

Проанализировав ответ, декомпилируем main

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x08048400}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@main}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x06 @ 0x8048607 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ main }\OperatorTok{(}\DataTypeTok{int32\_t}\NormalTok{ arg\_10h}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_78h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \CommentTok{// выравнивание стека}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{+=} \BaseNTok{0xf}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textgreater{}\textgreater{}=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{\textless{}\textless{}=} \DecValTok{4}\OperatorTok{;}

    \CommentTok{// основная логика}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x06}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    scanf }\OperatorTok{(}\BaseNTok{0x8048787}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=}\NormalTok{ arg\_10h}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{;}
\NormalTok{    check }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ arg\_10h}\OperatorTok{);}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Функции main передаются три аргумента \texttt{argc,\ argv,\ envp}, и эта
программа компилирована компилятором GCC, поэтому стек должен быть
таким:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{[esp}\NormalTok{ + 0x10] }\AttributeTok{{-}}\NormalTok{ envp}
\ExtensionTok{[esp}\NormalTok{ + 0x0c] }\AttributeTok{{-}}\NormalTok{ argv}
\ExtensionTok{[esp}\NormalTok{ + 0x08] }\AttributeTok{{-}}\NormalTok{ argc}
\ExtensionTok{[esp}\NormalTok{ + 0x04] }\AttributeTok{{-}}\NormalTok{ return address}
\end{Highlighting}
\end{Shaded}

Входим в функцию \texttt{check()} и декомпилируем ее. Функция отличается
от той, что была в задаче 0x05, но они по-прежнему имеют схожие
структуры кода.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int32\_t}\NormalTok{ check }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{,} \DataTypeTok{int32\_t}\NormalTok{ arg\_ch}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ var\_dh}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_ch}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ format}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_sp\_8h}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ strlen }\OperatorTok{(}\NormalTok{eax}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{\textgreater{}=}\NormalTok{ eax}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{goto}\NormalTok{ label\_0}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ var\_ch}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{+=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{*(}\NormalTok{eax}\OperatorTok{);}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ al}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_dh}\OperatorTok{;}
\NormalTok{        sscanf }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ eax}\OperatorTok{,} \BaseNTok{0x804873d}\OperatorTok{);}
\NormalTok{        edx }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_8h}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)} \OperatorTok{+=}\NormalTok{ edx}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0x10}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            eax }\OperatorTok{=}\NormalTok{ arg\_ch}\OperatorTok{;}
\NormalTok{            eax }\OperatorTok{=}\NormalTok{ s}\OperatorTok{;}
\NormalTok{            parell }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,}\NormalTok{ arg\_ch}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_ch}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)++;}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{label\_0}\OperatorTok{:}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Надо исправить \texttt{sscanf} и \texttt{parell}, обе они были
сгенерированы неправильно:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int32\_t}\NormalTok{ check }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{,} \DataTypeTok{void}\OperatorTok{*}\NormalTok{ envp}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_ch }\OperatorTok{\textless{}}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{s}\OperatorTok{);} \OperatorTok{++}\NormalTok{var\_ch}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ s}\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{];}
\NormalTok{        sscanf}\OperatorTok{(\&}\NormalTok{var\_dh}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}           \CommentTok{// read from string[var\_ch], store to var\_4h}
\NormalTok{        var\_8h }\OperatorTok{+=}\NormalTok{ var\_4h}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0x10}\OperatorTok{)}
\NormalTok{            parell}\OperatorTok{(}\NormalTok{s}\OperatorTok{,}\NormalTok{ envp}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Password Incorrect!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Больше никакой информации, надо снова взламывать \texttt{parell()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{uint32\_t}\NormalTok{ parell }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{ arg\_ch}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    sscanf }\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{dummy }\OperatorTok{(}\NormalTok{var\_4h}\OperatorTok{,}\NormalTok{ arg\_ch}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_bp\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_bp\_8h }\OperatorTok{\textless{}=} \DecValTok{9}\OperatorTok{;} \OperatorTok{++}\NormalTok{var\_bp\_8h}\OperatorTok{)\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{var\_4h }\OperatorTok{\&} \DecValTok{1} \OperatorTok{==} \DecValTok{0}\OperatorTok{)\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Password OK!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{            exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Появилось новое условие в \texttt{parell()} --
\texttt{dummy\ (var\_4h,\ arg\_ch)\ ==\ 0}. Взламываем dummy!

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x080484b4}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@sym}\OperatorTok{.}\NormalTok{dummy}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x06 @ 0x80484b4 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ dummy }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{**}\NormalTok{ s1}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int32\_t}\NormalTok{ var\_8h}\OperatorTok{;}
    \DataTypeTok{int32\_t}\NormalTok{ var\_4h}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ s2}\OperatorTok{;}
    \DataTypeTok{size\_t} \OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\NormalTok{    var\_4h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{        edx }\OperatorTok{=}\NormalTok{ eax}\OperatorTok{*}\DecValTok{4}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ s1}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(*((}\NormalTok{edx }\OperatorTok{+}\NormalTok{ eax}\OperatorTok{))} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{goto}\NormalTok{ label\_0}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ var\_4h}\OperatorTok{;}
\NormalTok{        ecx }\OperatorTok{=}\NormalTok{ eax}\OperatorTok{*}\DecValTok{4}\OperatorTok{;}
\NormalTok{        edx }\OperatorTok{=}\NormalTok{ s1}\OperatorTok{;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{;}
        \OperatorTok{*(}\NormalTok{eax}\OperatorTok{)++;}
\NormalTok{        eax }\OperatorTok{=} \OperatorTok{*((}\NormalTok{ecx }\OperatorTok{+}\NormalTok{ edx}\OperatorTok{));}
\NormalTok{        eax }\OperatorTok{=}\NormalTok{ strncmp }\OperatorTok{(}\NormalTok{eax}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \StringTok{"LOLO"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{eax }\OperatorTok{!=} \DecValTok{0}\OperatorTok{);}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{goto}\NormalTok{ label\_1}\OperatorTok{;}
\NormalTok{label\_0}\OperatorTok{:}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{label\_1}\OperatorTok{:}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ eax}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Выглядит как цикл обработки строки, можем ``украсить'' его.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x080484b4}\OperatorTok{]\textgreater{}}\NormalTok{ pdd@sym}\OperatorTok{.}\NormalTok{dummy}
\CommentTok{/* r2dec pseudo code output */}
\CommentTok{/* ./crackme0x06 @ 0x80484b4 */}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\DataTypeTok{int32\_t}\NormalTok{ dummy }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{**}\NormalTok{ s1}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_4h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ strncmp}\OperatorTok{(}\NormalTok{s1}\OperatorTok{[}\NormalTok{var\_4h}\OperatorTok{],} \StringTok{"LOLO"}\OperatorTok{,} \DecValTok{3}\OperatorTok{)} \OperatorTok{!=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_4h}\OperatorTok{++)\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{s1}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)}
            \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Теперь имеем три ограничения в crackme\_0x06:

\begin{itemize}
\tightlist
\item
  сумма цифр,
\item
  нечетное число,
\item
  должна быть переменная среды, имя которой начинается с ``LOL''.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ ./crackme0x06}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x06}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ Incorrect!}
\ExtensionTok{$}\NormalTok{ export LOLAA=help}
\ExtensionTok{$}\NormalTok{ ./cracke0x06}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x06}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

\hypertarget{ioli-0x07}{%
\section{IOLI 0x07}\label{ioli-0x07}}

Странная строка ``wtf?''.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ rabin2 }\AttributeTok{{-}z}\NormalTok{ ./crackme0x07}
\ExtensionTok{[Строки]}
\ExtensionTok{nth}\NormalTok{ paddr      vaddr      len size section type  string}
\ExtensionTok{{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\ExtensionTok{0}\NormalTok{   0x000007a8 0x080487a8 4   5    .rodata ascii LOLO}
\ExtensionTok{1}\NormalTok{   0x000007ad 0x080487ad 20  21   .rodata ascii Password Incorrect!}\DataTypeTok{\textbackslash{}n}
\ExtensionTok{2}\NormalTok{   0x000007c5 0x080487c5 13  14   .rodata ascii Password OK!}\DataTypeTok{\textbackslash{}n}
\ExtensionTok{3}\NormalTok{   0x000007d3 0x080487d3 5   6    .rodata ascii wtf}\PreprocessorTok{?}\DataTypeTok{\textbackslash{}n}
\ExtensionTok{4}\NormalTok{   0x000007d9 0x080487d9 24  25   .rodata ascii IOLI Crackme Level 0x07}\DataTypeTok{\textbackslash{}n}
\ExtensionTok{5}\NormalTok{   0x000007f2 0x080487f2 10  11   .rodata ascii Password:}
\end{Highlighting}
\end{Shaded}

Опять же, нет строки пароля или сравнений в \texttt{main()}. Приведем
здесь уже упрощенный псевдокод. Тип переменной var\_78h вероятно char
*pointer (string).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#include }\OperatorTok{\textless{}}\NormalTok{stdint}\OperatorTok{.}\NormalTok{h}\OperatorTok{\textgreater{}}
\NormalTok{int32\_t main }\OperatorTok{(}\NormalTok{int32\_t arg\_10h}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"IOLI Crackme Level 0x07\textbackslash{}n"}\OperatorTok{)}\CommentTok{;}
\NormalTok{    printf }\OperatorTok{(}\StringTok{"Password: "}\OperatorTok{)}\CommentTok{;}
\NormalTok{    scanf }\OperatorTok{(\%}\NormalTok{s}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_78h}\OperatorTok{)}\CommentTok{;}
\NormalTok{    return fcn\_080485b9 }\OperatorTok{(\&}\NormalTok{var\_78h}\OperatorTok{,}\NormalTok{ arg\_10h}\OperatorTok{)}\CommentTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Из-за потери информации ни \texttt{aa}, ни\texttt{aaa} не определили
названий функций. Можно дважды проверить ``flagspace''. Radare2
использует fcn\_080485b9 в качестве имен функций - распространенный
случай в реверс-инжениринге, когда нет никакой информации о символах в
двоичном файле.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{[0x080487fd]}\OperatorTok{\textgreater{}}\NormalTok{ fs symbols}
\ExtensionTok{[0x080487fd]}\OperatorTok{\textgreater{}}\NormalTok{ f}
\ExtensionTok{0x08048400}\NormalTok{ 33 entry0}
\ExtensionTok{0x0804867d}\NormalTok{ 92 main}
\ExtensionTok{0x080487a4}\NormalTok{ 4 obj.\_IO\_stdin\_used}
\end{Highlighting}
\end{Shaded}

Декомпилируем \texttt{fcn\_080485b9()}:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\BaseNTok{0x080485b9}\OperatorTok{]\textgreater{}}\NormalTok{ pdfc}
            \OperatorTok{;}\NormalTok{ CALL XREF from main @ }\BaseNTok{0x80486d4}
\OperatorTok{/} \DecValTok{118}\OperatorTok{:}\NormalTok{ fcn}\FloatTok{.080485}\ErrorTok{b9} \OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{int32\_t}\NormalTok{ arg\_ch}\OperatorTok{);}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{char} \OperatorTok{*}\NormalTok{var\_dh @ ebp}\OperatorTok{{-}}\BaseNTok{0xd}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{signed} \DataTypeTok{int}\NormalTok{ var\_ch  }\OperatorTok{\{} \OperatorTok{\textgreater{}=} \BaseNTok{0xffffffffffffffff}\OperatorTok{\}}\NormalTok{ @ ebp}\OperatorTok{{-}}\BaseNTok{0xc}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{uint32\_t}\NormalTok{ var\_8h @ ebp}\OperatorTok{{-}}\BaseNTok{0x8}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{int32\_t}\NormalTok{ var\_bp\_4h @ ebp}\OperatorTok{{-}}\BaseNTok{0x4}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ arg }\DataTypeTok{char} \OperatorTok{*}\NormalTok{s @ ebp}\OperatorTok{+}\BaseNTok{0x8}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ arg }\DataTypeTok{int32\_t}\NormalTok{ arg\_ch @ ebp}\OperatorTok{+}\BaseNTok{0xc}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{char} \OperatorTok{*}\NormalTok{format @ esp}\OperatorTok{+}\BaseNTok{0x4}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ var }\DataTypeTok{int32\_t}\NormalTok{ var\_sp\_8h @ esp}\OperatorTok{+}\BaseNTok{0x8}
\OperatorTok{|}           \BaseNTok{0x080485b9}      \DecValTok{55}\NormalTok{             push ebp}
\OperatorTok{|}           \BaseNTok{0x080485ba}      \FloatTok{89e5}\NormalTok{           mov ebp}\OperatorTok{,}\NormalTok{ esp}
\OperatorTok{|}           \BaseNTok{0x080485bc}      \DecValTok{83}\ErrorTok{ec28}\NormalTok{         sub esp}\OperatorTok{,} \BaseNTok{0x28}
\OperatorTok{|}           \BaseNTok{0x080485bf}\NormalTok{      c745f8000000}\OperatorTok{.}\NormalTok{  mov dword }\OperatorTok{[}\NormalTok{var\_8h}\OperatorTok{],} \DecValTok{0}
\OperatorTok{|}           \BaseNTok{0x080485c6}\NormalTok{      c745f4000000}\OperatorTok{.}\NormalTok{  mov dword }\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{],} \DecValTok{0}
\OperatorTok{|}           \OperatorTok{;}\NormalTok{ CODE XREF from fcn}\FloatTok{.080485}\ErrorTok{b9}\NormalTok{ @ }\BaseNTok{0x8048628}
\OperatorTok{|}       \OperatorTok{.{-}\textgreater{}} \BaseNTok{0x080485cd}      \DecValTok{8}\ErrorTok{b4508}\NormalTok{         mov eax}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{s}\OperatorTok{]}
\OperatorTok{|}       \OperatorTok{:}   \BaseNTok{0x080485d0}      \DecValTok{890424}\NormalTok{         mov dword }\OperatorTok{[}\NormalTok{esp}\OperatorTok{],}\NormalTok{ eax        }\OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}
\OperatorTok{|}       \OperatorTok{:}   \BaseNTok{0x080485d3}\NormalTok{      e8d0fdffff     call sym}\OperatorTok{.}\NormalTok{imp}\OperatorTok{.}\NormalTok{strlen         }\OperatorTok{;} \DataTypeTok{size\_t}\NormalTok{ strlen}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{)}
\OperatorTok{|}       \OperatorTok{:}   \BaseNTok{0x080485d8}      \DecValTok{3945}\ErrorTok{f4}\NormalTok{         cmp dword }\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{],}\NormalTok{ eax}
\OperatorTok{|}      \OperatorTok{,==\textless{}} \BaseNTok{0x080485db}      \DecValTok{734}\ErrorTok{d}\NormalTok{           jae }\BaseNTok{0x804862a}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485dd}      \DecValTok{8}\ErrorTok{b45f4}\NormalTok{         mov eax}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485e0}      \BaseNTok{03450}\ErrorTok{8}\NormalTok{         add eax}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{s}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485e3}      \DecValTok{0}\ErrorTok{fb600}\NormalTok{         movzx eax}\OperatorTok{,}\NormalTok{ byte }\OperatorTok{[}\NormalTok{eax}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485e6}      \DecValTok{8845}\ErrorTok{f3}\NormalTok{         mov byte }\OperatorTok{[}\NormalTok{var\_dh}\OperatorTok{],}\NormalTok{ al}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485e9}      \DecValTok{8}\ErrorTok{d45fc}\NormalTok{         lea eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{var\_bp\_4h}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485ec}      \DecValTok{89442408}\NormalTok{       mov dword }\OperatorTok{[}\NormalTok{var\_sp\_8h}\OperatorTok{],}\NormalTok{ eax  }\OperatorTok{;}   \OperatorTok{...}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485f0}\NormalTok{      c7442404c287}\OperatorTok{.}\NormalTok{  mov dword }\OperatorTok{[}\NormalTok{format}\OperatorTok{],} \BaseNTok{0x80487c2} \OperatorTok{;} \OperatorTok{[}\BaseNTok{0x80487c2}\OperatorTok{:}\DecValTok{4}\OperatorTok{]=}\BaseNTok{0x50006425} \OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{format}
\OperatorTok{|}      \OperatorTok{|:}   \OperatorTok{;{-}{-}}\NormalTok{ eip}\OperatorTok{:}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485f8}      \DecValTok{8}\ErrorTok{d45f3}\NormalTok{         lea eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{var\_dh}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485fb}      \DecValTok{890424}\NormalTok{         mov dword }\OperatorTok{[}\NormalTok{esp}\OperatorTok{],}\NormalTok{ eax        }\OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x080485fe}\NormalTok{      e8c5fdffff     call sym}\OperatorTok{.}\NormalTok{imp}\OperatorTok{.}\NormalTok{sscanf         }\OperatorTok{;} \DataTypeTok{int}\NormalTok{ sscanf}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{format}\OperatorTok{,}   \OperatorTok{...)}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x08048603}      \DecValTok{8}\ErrorTok{b55fc}\NormalTok{         mov edx}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{var\_bp\_4h}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x08048606}      \DecValTok{8}\ErrorTok{d45f8}\NormalTok{         lea eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{var\_8h}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x08048609}      \BaseNTok{0110}\NormalTok{           add dword }\OperatorTok{[}\NormalTok{eax}\OperatorTok{],}\NormalTok{ edx}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x0804860b}      \DecValTok{837}\ErrorTok{df810}\NormalTok{       cmp dword }\OperatorTok{[}\NormalTok{var\_8h}\OperatorTok{],} \BaseNTok{0x10}
\OperatorTok{|}     \OperatorTok{,===\textless{}} \BaseNTok{0x0804860f}      \DecValTok{7512}\NormalTok{           jne }\BaseNTok{0x8048623}
\OperatorTok{|}     \OperatorTok{||:}   \BaseNTok{0x08048611}      \DecValTok{8}\ErrorTok{b450c}\NormalTok{         mov eax}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{arg\_ch}\OperatorTok{]}
\OperatorTok{|}     \OperatorTok{||:}   \BaseNTok{0x08048614}      \DecValTok{89442404}\NormalTok{       mov dword }\OperatorTok{[}\NormalTok{format}\OperatorTok{],}\NormalTok{ eax     }\OperatorTok{;} \DataTypeTok{char} \OperatorTok{*}\NormalTok{arg\_ch}
\OperatorTok{|}     \OperatorTok{||:}   \BaseNTok{0x08048618}      \DecValTok{8}\ErrorTok{b4508}\NormalTok{         mov eax}\OperatorTok{,}\NormalTok{ dword }\OperatorTok{[}\NormalTok{s}\OperatorTok{]}
\OperatorTok{|}     \OperatorTok{||:}   \BaseNTok{0x0804861b}      \DecValTok{890424}\NormalTok{         mov dword }\OperatorTok{[}\NormalTok{esp}\OperatorTok{],}\NormalTok{ eax        }\OperatorTok{;} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}
\OperatorTok{|}     \OperatorTok{||:}   \BaseNTok{0x0804861e}\NormalTok{      e81fffffff     call fcn}\FloatTok{.08048542}
\OperatorTok{|}     \OperatorTok{||:}   \OperatorTok{;}\NormalTok{ CODE XREF from fcn}\FloatTok{.080485}\ErrorTok{b9}\NormalTok{ @ }\BaseNTok{0x804860f}
\OperatorTok{|}\NormalTok{     \textasciigrave{}}\OperatorTok{{-}{-}{-}\textgreater{}} \BaseNTok{0x08048623}      \DecValTok{8}\ErrorTok{d45f4}\NormalTok{         lea eax}\OperatorTok{,} \OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|:}   \BaseNTok{0x08048626}\NormalTok{      ff00           inc dword }\OperatorTok{[}\NormalTok{eax}\OperatorTok{]}
\OperatorTok{|}      \OperatorTok{|}\NormalTok{\textasciigrave{}}\OperatorTok{=\textless{}} \BaseNTok{0x08048628}\NormalTok{      eba3           jmp }\BaseNTok{0x80485cd}
\OperatorTok{|}      \OperatorTok{|}    \OperatorTok{;}\NormalTok{ CODE XREF from fcn}\FloatTok{.080485}\ErrorTok{b9}\NormalTok{ @ }\BaseNTok{0x80485db}
\NormalTok{\textbackslash{}      \textasciigrave{}}\OperatorTok{{-}{-}\textgreater{}} \BaseNTok{0x0804862a}\NormalTok{      e8f5feffff     call fcn}\FloatTok{.08048524}
\end{Highlighting}
\end{Shaded}

Уже знакомы со структурой этого кода из предыдущих задач (функция
проверки). Отсутствие информации о символах не создает нам больших
трудностей. При желании можно использовать команду \texttt{afn} для
переименования имен функций.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int32\_t}\NormalTok{ fcn\_080485b9 }\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{ s}\OperatorTok{,} \DataTypeTok{void}\OperatorTok{*}\NormalTok{ envp}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    var\_8h }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{var\_ch }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ var\_ch }\OperatorTok{\textless{}}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{s}\OperatorTok{);} \OperatorTok{++}\NormalTok{var\_ch}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        var\_dh }\OperatorTok{=}\NormalTok{ s}\OperatorTok{[}\NormalTok{var\_ch}\OperatorTok{];}
\NormalTok{        sscanf}\OperatorTok{(\&}\NormalTok{var\_dh}\OperatorTok{,} \OperatorTok{\%}\NormalTok{d}\OperatorTok{,} \OperatorTok{\&}\NormalTok{var\_4h}\OperatorTok{);}           \CommentTok{// read from string[var\_ch], store to var\_4h}
\NormalTok{        var\_8h }\OperatorTok{+=}\NormalTok{ var\_4h}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{var\_8h }\OperatorTok{==} \BaseNTok{0x10}\OperatorTok{)}
\NormalTok{            fcn\_08048542}\OperatorTok{(}\NormalTok{s}\OperatorTok{,}\NormalTok{ envp}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ fcn\_08048524}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Большая часть crackme 0x07 схожа с 0x06. Задачу можно решить с помощью
того же пароля и переменных среды:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ export LOLAA=help}
\ExtensionTok{$}\NormalTok{ ./cracke0x07}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x07}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

Но \ldots{} где находится `wtf?'. Обычное дело в реверс-инжениринге
искать перекрестные ссылки (xref) на строки (данные, функции и т.д.).
Соответствующие команды в Radare2 находятся в группе имен ``ax'':

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{[0x08048400]}\OperatorTok{\textgreater{}}\NormalTok{ f}
\ExtensionTok{0x080487a8}\NormalTok{ 5 str.LOLO}
\ExtensionTok{0x080487ad}\NormalTok{ 21 str.Password\_Incorrect}
\ExtensionTok{0x080487c5}\NormalTok{ 14 str.Password\_OK}
\ExtensionTok{0x080487d3}\NormalTok{ 6 str.wtf}
\ExtensionTok{0x080487d9}\NormalTok{ 25 str.IOLI\_Crackme\_Level\_0x07}
\ExtensionTok{0x080487f2}\NormalTok{ 11 str.Password:}
\ExtensionTok{[0x08048400]}\OperatorTok{\textgreater{}}\NormalTok{ axt 0x80487d3}
\KeywordTok{(}\ExtensionTok{nofunc}\KeywordTok{)} \ExtensionTok{0x804865c}\NormalTok{ [DATA] mov dword [esp], str.wtf}
\ExtensionTok{[0x08048400]}\OperatorTok{\textgreater{}}\NormalTok{ axF str.wtf}
\ExtensionTok{Ищем}\NormalTok{ ссылки на флаги, соответствующие }\StringTok{\textquotesingle{}str.wtf\textquotesingle{}}\NormalTok{...}
\ExtensionTok{[0x001eff28{-}0x001f0000]} \ErrorTok{(}\ExtensionTok{nofunc}\KeywordTok{)} \ExtensionTok{0x804865c}\NormalTok{ [DATA] mov dword [esp], str.wtf}
\ExtensionTok{Macro} \StringTok{\textquotesingle{}findstref\textquotesingle{}}\NormalTok{ removed.}
\end{Highlighting}
\end{Shaded}

\texttt{{[}DATA{]}\ mov\ dword\ {[}esp{]},\ str.wtf} по адресу
\texttt{0x804865c} - инструкция fcn.080485b9. Но анализ на ПК игнорирует
оставшиеся инструкции и отображает только неполный текст
дизассемблирования. Диапазон адресов fcn.080485b9 должен быть
\texttt{0x080485b9\ \textasciitilde{}\ 0x0804867c}. Сбросим размер блока
и распечатаем текст вместе с опкодом.

\begin{verbatim}
[0x08040000]> s 0x080485b9
[0x080485b9]> b 230
[0x08048400]> pd
...
            0x0804862f      8b450c         mov eax, dword [ebp + 0xc]
            0x08048632      89442404       mov dword [esp + 4], eax
            0x08048636      8b45fc         mov eax, dword [ebp - 4]
            0x08048639      890424         mov dword [esp], eax        ; char **s1
            0x0804863c      e873feffff     call fcn.080484b4
            0x08048641      85c0           test eax, eax
        ,=< 0x08048643      7436           je 0x804867b
        |   0x08048645      c745f4000000.  mov dword [ebp - 0xc], 0
        |   ; CODE XREF from fcn.080485b9 @ +0xc0
       .--> 0x0804864c      837df409       cmp dword [ebp - 0xc], 9
      ,===< 0x08048650      7f29           jg 0x804867b
      |:|   0x08048652      8b45fc         mov eax, dword [ebp - 4]
      |:|   0x08048655      83e001         and eax, 1
      |:|   0x08048658      85c0           test eax, eax
     ,====< 0x0804865a      7518           jne 0x8048674
     ||:|   0x0804865c      c70424d38704.  mov dword [esp], str.wtf    ; [0x80487d3:4]=0x3f667477 ; "wtf?\n" ; const char *format
     ||:|   0x08048663      e850fdffff     call sym.imp.printf         ; int printf(const char *format)
     ||:|   0x08048668      c70424000000.  mov dword [esp], 0          ; int status
     ||:|   0x0804866f      e874fdffff     call sym.imp.exit           ; void exit(int status)
     ||:|   ; CODE XREF from fcn.080485b9 @ +0xa1
     `----> 0x08048674      8d45f4         lea eax, [ebp - 0xc]
      |:|   0x08048677      ff00           inc dword [eax]
      |`==< 0x08048679      ebd1           jmp 0x804864c
      | |   ; CODE XREFS from fcn.080485b9 @ +0x8a, +0x97
      `-`-> 0x0804867b      c9             leave
            0x0804867c      c3             ret
\end{verbatim}

\texttt{test\ eax,\ ea;je\ 0x804867b} перейдет к инструкциям
\texttt{leave;\ ret}, что пропускает часть str.wtf кода. Только
использование \texttt{aa} при анализе этого двоичного файла может
отобразить всю функцию.

\hypertarget{ioli-0x08}{%
\section{IOLI 0x08}\label{ioli-0x08}}

Взломав код задачи, обнаруживаем, что задача похожа на 0x07,
используется тот же пароль:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ export LOLAA=help}
\ExtensionTok{$}\NormalTok{ ./cracke0x08}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x08}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

\href{https://dustri.org/b/defeating-ioli-with-radare2.html}{dustri}
показал лучший способ анализа crackme0x08. 0x07 --- это урезанная версия
0x08.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ radiff2 }\AttributeTok{{-}A} \AttributeTok{{-}C}\NormalTok{ ./crackme0x07 ./crackme0x08}
\ExtensionTok{...}
              \ExtensionTok{fcn.08048360}\NormalTok{  23 0x8048360 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048360}\NormalTok{   23 sym.\_init}
 \ExtensionTok{sym.imp.\_\_libc\_start\_main}\NormalTok{   6 0x8048388 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048388}\NormalTok{    6 sym.imp.\_\_libc\_start\_main}
             \ExtensionTok{sym.imp.scanf}\NormalTok{   6 0x8048398 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048398}\NormalTok{    6 sym.imp.scanf}
            \ExtensionTok{sym.imp.strlen}\NormalTok{   6 0x80483a8 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80483a8}\NormalTok{    6 sym.imp.strlen}
            \ExtensionTok{sym.imp.printf}\NormalTok{   6 0x80483b8 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80483b8}\NormalTok{    6 sym.imp.printf}
            \ExtensionTok{sym.imp.sscanf}\NormalTok{   6 0x80483c8 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80483c8}\NormalTok{    6 sym.imp.sscanf}
           \ExtensionTok{sym.imp.strncmp}\NormalTok{   6 0x80483d8 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80483d8}\NormalTok{    6 sym.imp.strncmp}
              \ExtensionTok{sym.imp.exit}\NormalTok{   6 0x80483e8 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80483e8}\NormalTok{    6 sym.imp.exit}
                    \ExtensionTok{entry0}\NormalTok{  33 0x8048400 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048400}\NormalTok{   33 entry0}
              \ExtensionTok{fcn.08048424}\NormalTok{  33 0x8048424 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048424}\NormalTok{   33 fcn.08048424}
              \ExtensionTok{fcn.08048450}\NormalTok{  47 0x8048450 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048450}\NormalTok{   47 sym.\_\_do\_global\_dtors\_aux}
              \ExtensionTok{fcn.08048480}\NormalTok{  50 0x8048480 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048480}\NormalTok{   50 sym.frame\_dummy}
              \ExtensionTok{fcn.080484b4}\NormalTok{ 112 0x80484b4 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80484b4}\NormalTok{  112 sym.dummy}
              \ExtensionTok{fcn.08048524}\NormalTok{  30 0x8048524 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048524}\NormalTok{   30 sym.che}
              \ExtensionTok{fcn.08048542}\NormalTok{ 119 0x8048542 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048542}\NormalTok{  119 sym.parell}
              \ExtensionTok{fcn.080485b9}\NormalTok{ 118 0x80485b9 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x80485b9}\NormalTok{  118 sym.check}
                      \ExtensionTok{main}\NormalTok{  92 0x804867d }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x804867d}\NormalTok{   92 main}
              \ExtensionTok{fcn.08048755}\NormalTok{   4 0x8048755 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048755}\NormalTok{    4 sym.\_\_i686.get\_pc\_thunk.bx}
              \ExtensionTok{fcn.08048760}\NormalTok{  35 0x8048760 }\KeywordTok{|}   \ExtensionTok{MATCH}  \ErrorTok{(}\ExtensionTok{1.000000}\KeywordTok{)} \KeywordTok{|} \ExtensionTok{0x8048760}\NormalTok{   35 sym.\_\_do\_global\_ctors\_aux}
              \ExtensionTok{fcn.0804878d}\NormalTok{  17 0x804878d }\KeywordTok{|}     \ExtensionTok{NEW}  \ErrorTok{(}\ExtensionTok{0.000000}\KeywordTok{)}
       \ExtensionTok{sym.\_\_libc\_csu\_init}\NormalTok{  99 0x80486e0 }\KeywordTok{|}     \ExtensionTok{NEW}  \ErrorTok{(}\ExtensionTok{0.000000}\KeywordTok{)}
       \ExtensionTok{sym.\_\_libc\_csu\_fini}\NormalTok{   5 0x8048750 }\KeywordTok{|}     \ExtensionTok{NEW}  \ErrorTok{(}\ExtensionTok{0.000000}\KeywordTok{)}
                 \ExtensionTok{sym.\_fini}\NormalTok{  26 0x8048784 }\KeywordTok{|}     \ExtensionTok{NEW}  \ErrorTok{(}\ExtensionTok{0.000000}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ioli-0x09}{%
\section{IOLI 0x09}\label{ioli-0x09}}

Подсказка: crackme0x09 скрывает строку формата (\%d и \%s), и она ничем
не отличается от 0x08.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{$}\NormalTok{ export LOLA=help}
\ExtensionTok{$}\NormalTok{ ./crackme0x09}
\ExtensionTok{IOLI}\NormalTok{ Crackme Level 0x09}
\ExtensionTok{Password:}\NormalTok{ 12346}
\ExtensionTok{Password}\NormalTok{ OK!}
\end{Highlighting}
\end{Shaded}

\hypertarget{avatao-r3v3rs3-4}{%
\subsection{Avatao R3v3rs3 4}\label{avatao-r3v3rs3-4}}

После нескольких лет отсутствия военных игр (wargames) в
\href{https://hacktivity.com}{Hacktivity}, в этом году наконец нашлось
время начать и почти закончить (да, я очень смущен этим незаконченным
webhack-ом :) ) один из них. В конференции было три разные игры, я
выбрал предоставленный \href{https://avatao.com}{avatao}. Было восемь
испытаний, большинство из которых представляют собой базовые элементы
веб-хакерства, один - получение привилегированных прав и бегство из
песочницы, одно переполнение буфера с последующим его использованием по
назначению, также было два упражнения по реверс-инженирингу. Задачи
находятся по адресу https://platform.avatao.com.

\hypertarget{radare2}{%
\subsection{.radare2}\label{radare2}}

Решим задачу обратной инженерии, используя
\href{http://www.radare.org/r/}{radar2}, свободный инструмент
реверс-инжениринга с открытым исходным кодом. Я впервые узнал о r2 еще в
2011 году, когда участвовал в большом проекте, где пришлось взламывать
огромный статический ELF размером 11 МБ. Нужен был инструмент,
позволяющий легко вносить исправления в Linux ELF. Тогда я использовал
r2 вместе с IDA и то только для небольших задач, мне с первого взгляда
понравилась вся концепция. С тех пор radare2 сильно развился, и я решил
уделить немного времени решению задач crackme при помощи этого
инструмента, также описать результат в виде статьи. Что ж, этот CTF дал
мне прекрасную возможность :).

Статья нацелена на то, чтобы показать некоторые особенности r2 в
процессе решения задачи crackme. Я объясню каждую использованную команду
r2 в виде цитат, подобных этой:

\begin{quote}
\textbf{\emph{Совет от r2:}} Всегда используй ? или флаг -h - получишь
больше информации!
\end{quote}

Если владеете r2 или просто интересуетесь задачками на взлом, пропустите
эти разделы! Обращаю внимание, что из-за стиля дальнейшего изложения я
собираюсь детально разбирать приемы, которые обычно не делаются во время
CTF, так как нет на это достаточно времени (например, пометить
\textbf{каждую} область памяти в соответствии с ее предназначением). С
небольшими исполняемыми файлами crackme можно получить результат, не
вдаваясь в такие детали.

Дам несколько советов в изучении radare2, и, раз вы интересуетесь
реверс-инженирингом, вас как минимум должен заинтересовать r2 :):

Пакет включает множество дополнительных инструментов и огромное
количество функций. Все они очень хорошо документированы. Призываю вас
ознакомиться с руководством и использовать встроенную систему справки,
добавляя ``?'' в конец каждой команды!

Примеры:

\begin{verbatim}
[0x00000000]> ?
Usage: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...
Append '?' to any char command to get detailed help
Prefix with number to repeat command N times (f.ex: 3x)
|%var =valueAlias for 'env' command
| *off[=[0x]value]     Pointer read/write data/values (see ?v, wx, wv)
| (macro arg0 arg1)    Manage scripting macros
| .[-|(m)|f|!sh|cmd]   Define macro or load r2, cparse or rlang file
| = [cmd]              Run this command via rap://
| /                    Search for bytes, regexps, patterns, ..
| ! [cmd]              Run given command as in system(3)
| # [algo] [len]       Calculate hash checksum of current block
| #!lang [..]          Hashbang to run an rlang script
| a                    Perform analysis of code
| b                    Get or change block size

...

[0x00000000]> a?
|Usage: a[abdefFghoprxstc] [...]
| ab [hexpairs]     analyze bytes
| aa                analyze all (fcns + bbs) (aa0 to avoid sub renaming)
| ac [cycles]       analyze which op could be executed in [cycles]
| ad                analyze data trampoline (wip)
| ad [from] [to]    analyze data pointers to (from-to)
| ae [expr]         analyze opcode eval expression (see ao)
| af[rnbcsl?+-*]    analyze Functions
| aF                same as above, but using anal.depth=1

...
\end{verbatim}

Проект находится в стадии активной разработки - нет и дня без фиксации в
репозитории GitHub. Как говорится в файле readme, всегда нужно
использовать версию из git!

Некоторые рекомендуемые материалы для чтения:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/pwntester/cheatsheets/blob/master/radare2.md}{Шпаргалка
  от pwntester-а}
\item
  \href{https://www.gitbook.com/book/radareorg/radare2-book/details}{Книга
  Radare2}
\item
  \href{http://radare.today}{Блог Radare2}
\item
  \href{https://github.com/radareorg/radare2/wiki}{Radare2 Wiki}
\end{itemize}

\hypertarget{first_steps}{%
\subsection{.first\_steps}\label{first_steps}}

Хорошо, хватит хвалить r2, давайте начнем взламывать (ревер-инжениринг)
программы.

Во-первых, вы должны знать своего врага:

\begin{verbatim}
[0x00 avatao]$ rabin2 -I reverse4
pic      false
canary   true
nx       true
crypto   false
va       true
intrp    /lib64/ld-linux-x86-64.so.2
bintype  elf
class    ELF64
lang     c
arch     x86
bits     64
machine  AMD x86-64 architecture
os       linux
subsys   linux
endian   little
stripped true
static   false
linenum  false
lsyms    false
relocs   false
rpath    NONE
binsz    8620
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} rabin2 --- это удобный инструмент,
поставляемый вместе с radare2. Он используется для извлечения информации
(импорты, символы, библиотеки и т. д.) из бинарных исполняемых файлов.
Как всегда, пользуйтесь справкой (rabin2 -h)!
\end{quote}

Итак, имеем динамически связанный, 64-битный исполняемый файл Linux с
вырезанной информацией о символах (stripped) - ничего особенного.
Попробуем запустить его:

\begin{verbatim}
[0x00 avatao]$ ./reverse4
?
Size of data: 2623
pamparam
Wrong!

[0x00 avatao]$ "\x01\x00\x00\x00" | ./reverse4
Size of data: 1
\end{verbatim}

Хорошо, программа сначала считывает число в качестве размера со
стандартного ввода, затем читает далее, вероятно, ``размер''
байтов/символов, обрабатывает этот ввод и выводит либо ``Wrong!'', либо
ничего, либо еще что-то, предположительно наш флаг. Не стоит тратить
больше времени на дебильный подбор данных для ввода исполняемого файла,
запустим r2, потому что in asm we trust!

\begin{verbatim}
[0x00 avatao]$ r2 -A reverse4
 -- Heisenbug: A bug that disappears or alters its behavior when one attempts to probe or isolate it.
(-- Heisenbug - ошибка, которая исчезает или меняет свое поведение при попытке исследовать или изолировать ее (синдром телемастера).)
[0x00400720]>
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Флаг командной строки -A запускает команду
\emph{ааа} при входе в r2, он анализирует весь код на наличие
перекресных ссылок. Вследствие этого мы получим имена функций, строк,
информацию о перекрестных сслках (XREFS) и т.д. Как всегда, нужна помощь
- используйте \emph{?}.
\end{quote}

Хорошей практикой является создание проекта для сохранения и
восстановления состояния при повторном входе в r2:

\begin{verbatim}
[0x00400720]> Ps avatao_reverse4
avatao_reverse4
[0x00400720]>
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Сохранение проекта - команда Ps {[}файл{]},
загрузка - Po {[}файл{]}. При помощи флага -p можно загрузить проект при
запуске r2.
\end{quote}

Посмотрим все найденные строки при помощи r2:

\begin{verbatim}
[0x00400720]> fs strings
[0x00400720]> f
0x00400e98 7 str.Wrong_
0x00400e9f 27 str.We_are_in_the_outer_space_
0x00400f80 18 str.Size_of_data:__u_n
0x00400f92 23 str.Such_VM__MuCH_reV3rse_
0x00400fa9 16 str.Use_everything_
0x00400fbb 9 str.flag.txt
0x00400fc7 26 str.You_won__The_flag_is:__s_n
0x00400fe1 21 str.Your_getting_closer_
[0x00400720]>
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} r2 ставит флаги на важные/интересные адреса
смещений, и организует их в пространства флагов (строки, функции,
символы и т.д.). Можно посмотреть список всех пространств, используя
\emph{fs}, подключиться - \emph{fs {[}пространство{]}} (по умолчанию -
*, что означает все пространства флагов). Команда \emph{f} покажет все
флаги из выбранного пространства.
\end{quote}

Итак, строки выглядят интересно, особенно 0x00400f92. Она намекает, что
этот crackme основан на виртуальной машине. Будем иметь это в виду!

Строки служат хорошей отправной точкой, если иметь дело с реальным
приложением со множеством разных функций. Но у нас crackme, они обычно
маленькие и простые, сосредоточены на решении простых задач. Поэтому
просто смотрим на точку или точки входа, можно ли понять что-то оттуда.
А сейчас все-таки посмотрим, где эти строки используются:

\begin{verbatim}
[0x00400720]> axt @@=`f~[0]`
d 0x400cb5 mov edi, str.Size_of_data:__u_n
d 0x400d1d mov esi, str.Such_VM__MuCH_reV3rse_
d 0x400d4d mov edi, str.Use_everything_
d 0x400d85 mov edi, str.flag.txt
d 0x400db4 mov edi, str.You_won__The_flag_is:__s_n
d 0x400dd2 mov edi, str.Your_getting_closer_
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} можно посмотреть список перекрестных ссылок
на адреса, используя команду \emph{axt {[}адрес{]}}. Также можно
использовать \emph{axf} перечислить ссылки с заданного адреса).
Последовательность символов *@@* задает итератор, он запускает команду,
подставляя в качестве параметра каждый элемент списка.

Список аргументов в данном примере берется из команды
\emph{f\textasciitilde{[}0{]}} . Она порождает список строк из
исполняемого файла \emph{f}, при этом фильтрует встроенным grep-ом
\emph{\textasciitilde{}} только первые столбцы (\emph{{[}0{]}}),
содержащие адреса строк.
\end{quote}

\hypertarget{main-1}{%
\subsection{.main}\label{main-1}}

Как было уже не раз сказано, надо сперва смотреть точку входа, так что с
этого и начнем:

\begin{verbatim}
[0x00400720]> s main
[0x00400c63]>
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Переход к любому смещению, флагу, выражению
и т.д. в исполняемом файле выполняется командой \emph{s} (seek). Можно
использовать ссылки, например, \emph{\$\$} (текущее смещение), отменить
предыдущее перемещение (\emph{s-} ) или заново его повторить (\emph{s+}
). Команда позволяет искать строки (\emph{s/ {[}строка{]}} ) или
шестнадцатеричные значения (\emph{s/х 4142}), а также делать много
других полезных вещей. Имеет смысл почитать инструкции? - \emph{s?}!
\end{quote}

Итак, мы находимся в начале функции main, можно, конечно, использовать
команду \emph{p} и ее дизассемблирующие разновидности \emph{pd} и
\emph{pdf}, но в r2 можно зажигать по полной: у него есть визуальный
режим, отображающий графы управления, похожие на графы IDA, но намного
круче, так как они изображены в ASCII :)!

\begin{quote}
\textbf{\emph{Совет от r2:}} Команды группы \emph{p} используется для
отображения объектов. Например, команда \emph{pd} дизассемблирует код с
текущей позиции, дизассемблирование текущей функции - \emph{pdf},
\emph{ps} печатает строки, \emph{px} - шестнадцатеричные дампы,
\emph{p6e} и \emph{p6d} кодируют и декодируют данные согласно base64.
Можно выдавать на экран и байты как есть (raw) - \emph{pr}, можно дампы
из одних файлов записывать в другие. Есть еще много других функций, см.
инструкцию - \emph{?}!
\end{quote}

R2 также поддерживает вид миникарты, невероятно полезной для получения
общего представления о функции:

\begin{figure}
\centering
\includegraphics{img/main/main_minimap.png}
\caption{миникарта функции main}
\end{figure}

\begin{quote}
\textbf{\emph{Совет от r2:}} Команда \emph{V} переводит в так называемый
визуальный режим, имеющий несколько видов отображения информации.
Переключать между ними можно, используя \emph{p} и \emph{P}. Граф
отображается, если еще раз нажать \emph{V} в визуальном режиме, либо
используя \emph{VV} будучи еще в командной строке.

Нажатие \emph{p} в режиме графа управления переведет систему в режим
отображения миникарты. Она отображает базовые функциональные блоки и
связи между ними, дизассемблированый код выбранного блока, помеченного
@@@@@ на миникарте, отображается тут же рядом. Можно выбирать следующий
или предыдущий блок с помощью клавиш *\textless TAB\textgreater{} * и
*\textless SHIFT\textgreater{} \textless TAB\textgreater{} *,
соответственно. Переход по ветвям графа между истинными и ложными
альтернативамиб очевидно, - \emph{t} и \emph{f}.

В визуальном режиме можно открыть командную строку с помощью лавиши
\emph{:}, клавиша \emph{o} - установка смещения.
\end{quote}

Походим по графу - узел за узлом! Первый блок выглядит так:

\begin{figure}
\centering
\includegraphics{img/main/bb-0c63.png}
\caption{main bb-0c63}
\end{figure}

Видно, что программа считывает слово (два байта) в локальную переменную
с именем \emph{local\_10\_6}, и затем сравнивает ее с 0xbb8. Это 3000 в
десятичном виде:

\begin{verbatim}
[0x00400c63]> ? 0xbb8
3000 0xbb8 05670 2.9K 0000:0bb8 3000 10111000 3000.0 0.000000f 0.000000
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Команда \emph{?} вычисляет выражения и
печатает результат в различных форматах.
\end{quote}

Если значение больше 3000, то оно будет заменено на 3000 принудительно:

\begin{figure}
\centering
\includegraphics{img/main/bb-0ca6.png}
\caption{main bb-0ca6}
\end{figure}

В следующем блоке есть несколько интересных моментов:

\begin{figure}
\centering
\includegraphics{img/main/bb-0cac.png}
\caption{main bb-0cac}
\end{figure}

Печатается сообщение ``Size of data:'', которое выдается при запуске
программы. Итак, теперь мы знаем, что локальная переменная
\emph{local\_10\_6} - это размер данных, подаваемых на вход. Назовем
переменную подходящим именем. Для этого открываем командную стоку r2,
находясь в визуальном режиме, с помощью клавиши \emph{:} и вводим туда
команду:

\begin{verbatim}
:> afvn local_10_6 input_size
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Комбинация \emph{af} - семейство команд,
используемых в процессе анализа функций. Включает также модификацию
аргументов и локальных переменных функции. Эти возможности находятся в
разделе \emph{afv}. Можете перечислить аргументы функции (\emph{afa}),
локальные переменные (\emph{afv}), даже переименовать их (\emph{afan},
\emph{afvn}). Существует множество других функций - как обычно:
ИСПОЛЬЗУЙ ``?'', ЛЮК!
\end{quote}

После этого в оперативной памяти выделяется кусок длиной
\emph{input\_size} байтов и заполняется данными со стандартного ввода.
Адрес этого фрагмента памяти хранится в \emph{local\_10}, снова
используем \emph{afvn}:

\begin{verbatim}
:> afvn local_10 input_data
\end{verbatim}

Почти закончили с этим блоком, осталось всего две вещи. Блок памяти
размером 512 (0x200) байт обнуляется по смещению 0x00602120. Беглый
взгляд на XREFS на этот адрес показывает, что эта память действительно
используется где-то в приложении:

\begin{verbatim}
:> axt 0x00602120
d 0x400cfe mov edi, 0x602120
d 0x400d22 mov edi, 0x602120
d 0x400dde mov edi, 0x602120
d 0x400a51 mov qword [rbp - 8], 0x602120
\end{verbatim}

Позже это будет важно, поэтому обозначим этот блок памяти:

\begin{verbatim}
:> f sym.memory 0x200 0x602120
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Флагами (идентификаторами сущностей) можно
управлять с помощью команд, начинающихся с \emph{f}. Мы добавили флаг
sym.memory, обозначающий памяти длиной 0x200 байт по адресу 0x602120.
Можно также и удалять флаги (\emph{f-name}), переименовывать их
(\emph{fr {[}текущее имя{]} {[}новое имя{]}}), добавлять
комантарии(\emph{fC {[}имя{]} {[}cmt{]}}), и даже раскрашивать цветом
(\emph{fc {[}имя{]} {[}цвет{]}}).
\end{quote}

Пока мы не перешли еще куда-то, нужно объявить этот фрагмент памяти
блоком данных, тогда он будет отображаться как шестнадцатеричный дамп
при дизассемблировании:

\begin{verbatim}
:> Cd 0x200 @ sym.memory
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Команды группы \emph{C} используются для
управления метаданными. Можно задавать комментарии (\emph{CC}) или
редактировать их (\emph{CC}), обозначать адреса в памяти блоками данных
(\emph{Cd}) или строками (\emph{Cs}) и т.п. Эти команды также
выполняются при помощи меню в визуальном режиме, меню вызывается
нажатием \emph{d}.
\end{quote}

Единственное, что осталось в этом блоке - вызов функции по адресу
0x400a45 с входными данными в качестве ее аргумента. Возвращаемое
значение функции сравнивается с ``*``, осуществляется условный переход в
зависимости от результата.

Теперь подтверждается предположения, сделанное в самом начале: этот
crackme основан на виртуальной машине. Учитывая эту информацию,
предположим, что эта функция - основной цикл виртуальной машины, а
входные данные --- это инструкции, которые будет выполнять виртуальная
машина. Оформим догадку, назовем функцию \emph{vmloop}, а ее входные
данные переименуем с \emph{input\_data} в \emph{bytecode}, а
\emph{input\_size} в \emph{bytecode\_length}. В этом нет крайней
необходимости в таком небольшом проекте, но рекомендуется называть
сущности в соответствии с их назначением, аналогично тому, как пишется
программа.

\begin{verbatim}
:> af vmloop 0x400a45
:> afvn input_size bytecode_length
:> afvn input_data bytecode
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Команда \emph{af} используется для анализа
функции, заданной именем, по указанному адресу. Две другие команды уже
использовались ранее.
\end{quote}

После переименования локальных переменных, пометки области памяти и
переименования функции виртуальной машины дизассемблированный код
выглядит так:

\begin{figure}
\centering
\includegraphics{img/main/bb-0cac_meta.png}
\caption{main bb-0cac\_meta}
\end{figure}

Вернемся к условному переходу. Если \emph{vmloop} возвращает что-то,
кроме ``*``, программа просто завершает работу, не давая нам наш флаг.
Очевидно, нам этого не надо, поэтому идем по ветке false.

\begin{figure}
\centering
\includegraphics{img/main/bb-0d1d.png}
\caption{main bb-0d1d}
\end{figure}

Теперь видно, что строка в этой 512-байтовой области памяти
\emph{sym.memory} сравнивается с ``Such VM! MuCH reV3rse!''. Если они не
равны, программа выводит байт-код и выходит:

\begin{figure}
\centering
\includegraphics{img/main/bb-0dde.png}
\caption{main bb-0dde}
\end{figure}

Итак, теперь точно знаем, что нужно предоставить на вход байт-код,
который будет генерировать эту строку при исполнении. Как видно на
миникарте, осталось проанализировать еще несколько ветвей, для
достижения результата нужно выполнить больше условий. Исследуем их
прежде чем углубляться в \emph{vmloop}!

Посмотрев миникарту всей функции, видно, что на ней распознается
какой-то цикл, начинающийся в блоке \emph{{[}\emph{0d34}{]}}, и он
включает следующие узлы:

\begin{itemize}
\tightlist
\item
  {[}\emph{0d34}{]}
\item
  {[}\emph{0d65}{]}
\item
  {[}\emph{0d3d}{]}
\item
  {[}\emph{0d61}{]}
\end{itemize}

Вот дизассемблирование этих блоков. Первый помещает 0 в локальную
переменную \emph{local\_10\_4}:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d34.png}
\caption{main bb-0d34}
\end{figure}

В блоке сравнивается \emph{local\_10\_4} с числом 8, далее выполняется
условный переход на основе полученного результата:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d65.png}
\caption{main bb-0d65}
\end{figure}

Совершенно очевидно, что \emph{local\_10\_4} - это переменная цикла,
поэтому назовем ее соответственно:

\begin{verbatim}
:> afvn local_10_4 i
\end{verbatim}

Следующий блок --- это собственно тело цикла:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d3d.png}
\caption{main bb-0d3d}
\end{figure}

Область памяти по адресу 0x6020e0 обрабатывается как массив двойных слов
(значения по четыре байта), и проверяется, равно ли i-е его значение
нулю. Если это не так, цикл просто продолжает выполняться:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d61.png}
\caption{main bb-0d61}
\end{figure}

Если значение равно нулю, цикл прерывается, перед выходом выполняется
этот блок:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d4d.png}
\caption{main bb-0d4d}
\end{figure}

Выводится сообщение: ``Use everything!''. Как установлено ранее, мы
имеем дело с виртуальной машиной. В этом контексте сообщение, вероятно,
означает, что нужно использовать все существующие инструкции. Выполнена
ли инструкция или нет, она сохраняется по адресу 0x6020e0, поэтому
давайте отметим эту область памяти флагом:

\begin{verbatim}
:> f sym.instr_dirty 4*9 0x6020e0
\end{verbatim}

Предполагая, что не выполнен выход из цикла по break, анализируем другие
ветвления и переходы:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d6b.png}
\caption{main bb-0d6b}
\end{figure}

Этот фрагмент кода кажется немного странным, если не знаком со
спецификой архитектуры процессоров x86\_64. В этом фрагменте речь идет
об относительной RIP-адресации, где адреса задаются как смещения от
адреса текущей инструкции, что упрощает реализацию режима PIE. В любом
случае r2 достаточно умен и отображает фактический адрес (0x602104).
Получил адрес, пометь его флагом!

\begin{verbatim}
:> f sym.good_if_ne_zero 4 0x602104
\end{verbatim}

Однако, при использовании относительной адресации RIP, флаги не будут
отображаться прямо в результате дизассемблирования, а r2 отобразит их в
виде комментариев:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d6b_meta.png}
\caption{main bb-0d6b\_meta}
\end{figure}

Если \emph{sym.good\_if\_ne\_zero} равен нулю, получаем сообщение
(``Your getting closer!''), и затем исполнение программы
останавливается. Если не нуль, то переходим к последней проверке:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d75.png}
\caption{main bb-0d75}
\end{figure}

Здесь программа сравнивает двойное слово по адресу 0x6020f0 (опять же
используется RIP-адресация) с 9. Если оно больше 9, получаем то же
сообщение ``Your getting closer!'', если же оно меньше или равно 9,
наконец достигаем пункта назначения и получаем флаг:

\begin{figure}
\centering
\includegraphics{img/main/bb-0d80.png}
\caption{main bb-0d80}
\end{figure}

Как обычно, установим флаг для 0x6020f0:

\begin{verbatim}
:> f sym.good_if_le_9 4 0x6020f0
\end{verbatim}

Функция main теперь полностью взломана. Подводя итог, декларируем,
программа считывает байт-код со стандартного ввода и передает его
виртуальной машине. После выполнения ВМ состояние программы должно
удовлетворять этим ограничениям для получения подтверждения о выполнении
всего задания:

\begin{itemize}
\tightlist
\item
  возвращаемое значение \emph{vmloop}-а должно быть ``*``,
\item
  \emph{sym.memory} должна содержать строку ``Such VM! MuCH reV3rse!'',
\item
  все девять элементов массива \emph{sym.instr\_dirty} не должны быть
  равны нулю, вероятно, это означает что все инструкции надо
  использовать хотя бы один раз,
\item
  \emph{sym.good\_if\_ne\_zero} должно стать нулем,
\item
  \emph{sym.good\_if\_le\_9} должно быть меньше или равно 9.
\end{itemize}

На этом завершается анализ функции main, теперь можно перейти к самой
виртуальной машине.

\hypertarget{vmloop}{%
\subsection{.vmloop}\label{vmloop}}

\begin{verbatim}
[offset]> fcn.vmloop
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0a45.png}
\caption{vmloop bb-0a45}
\end{figure}

Кажется наша публикация разочаровывающе коротка, но не беспокойтесь, у
нас есть много чего можно взломать. Все дело в том, что эта функция
использует таблицу переходов по адресу 0x00400a74,

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0a74.png}
\caption{vmloop bb-0a74}
\end{figure}

Программа r2 пока не может распознать таблицы переходов
(\href{https://github.com/radareorg/radare2/issues/3201}{Выпуск 3201}),
так что анализ этой функции неполон. Граф управления не дает полной
информации, поэтому надо либо использовать визуальный режим, либо
вносить исправления в блоки. Двоичный код функция всего 542 байта, можно
ее взломать и без использования графа. Наша цель - продемонстрировать
как можно больше возможностей r2, и имеет смысл показать, как
определяются блоки в графе.

Давайте проанализируем то, что у нас уже есть! Значение \emph{rdi}
помещается в local\_3. Поскольку приложение является 64-битным
исполняемым файлом Linux, известно, что \emph{rdi} - это первый аргумент
функции (как вы, возможно, поняли, автоматический анализ аргументов и
локальных переменных не был полностью корректным и полным). Также
известно, что первым аргументом \emph{vmloop} является байт-код.

Переименуем local\_3:

\begin{verbatim}
:> afvn local_3 bytecode
\end{verbatim}

Затем \emph{sym.memory} помещается в другую локальную переменную по
адресу \emph{rbp-8}, также нераспознанную r2. Давайте определим ее!

\begin{verbatim}
:> afv 8 memory qword
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Команда \emph{afv {[}idx{]} {[}name{]}
{[}type{]}\textless/g3 используется для определения локальной переменной
с {[}указателем фрейма - idx{]}, именем {[}name{]} и типом {[}type{]}.
Можно также удалять локальные переменные с помощью команды }afv-
{[}idx{]}*.
\end{quote}

В следующем блоке программа проверяет один байт байт-кода, и если он
равен 0, функция возвращает 1.

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0c4d.png}
\caption{vmloop bb-0c4d}
\end{figure}

Если этот байт не равен нулю, программа вычитает из него 0x41 и
сравнивает результат с 0x17. Если результат больше 0x17, получаем
страшное сообщение ``Wrong!'', и функция возвращает значение 0. Это
означает, что допустимые байт-коды - это ASCII-символы в диапазоне от
``A'' (0x41) до ``X'' (0x41 + 0x17). Если байт-код действителен,
приходим к фрагменту кода, реализующему таблицу переходов:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0a74.png}
\caption{vmloop bb-0a74}
\end{figure}

Адрес первой ячейки таблицы переходов - 0x400ec0, определим эту область
памяти как набор qword-ов:

\begin{verbatim}
[0x00400a74]> s 0x00400ec0
[0x00400ec0]> Cd 8 @@=`?s $$ $$+8*0x17 8`
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} Кроме \emph{?s} все части этой команды
знакомы, давайте подведем итоги! \emph{Cd} определяет область памяти как
данные, а 8 размер этой области памяти. \emph{@@* --- это итератор,
выполяющий команду слева для каждого элемента, для которого условие }@@*
истинно. В этом примере он содержит список, сгенерированный с помощью
команды \emph{?s}. Выражение \emph{?s} генерирует список адресов,
начиная с текущего смещения (seek)
\emph{\[* до seek + 8*0x17 (*\]+8}0x17*) с шагом 8.
\end{quote}

Вот как выглядит дизассемблирование после добавления метаданных:

\begin{verbatim}
[0x00400ec0]> pd 0x18
            ; DATA XREF from 0x00400a76 (unk)
            0x00400ec0 .qword 0x0000000000400a80
            0x00400ec8 .qword 0x0000000000400c04
            0x00400ed0 .qword 0x0000000000400b6d
            0x00400ed8 .qword 0x0000000000400b17
            0x00400ee0 .qword 0x0000000000400c04
            0x00400ee8 .qword 0x0000000000400c04
            0x00400ef0 .qword 0x0000000000400c04
            0x00400ef8 .qword 0x0000000000400c04
            0x00400f00 .qword 0x0000000000400aec
            0x00400f08 .qword 0x0000000000400bc1
            0x00400f10 .qword 0x0000000000400c04
            0x00400f18 .qword 0x0000000000400c04
            0x00400f20 .qword 0x0000000000400c04
            0x00400f28 .qword 0x0000000000400c04
            0x00400f30 .qword 0x0000000000400c04
            0x00400f38 .qword 0x0000000000400b42
            0x00400f40 .qword 0x0000000000400c04
            0x00400f48 .qword 0x0000000000400be5
            0x00400f50 .qword 0x0000000000400ab6
            0x00400f58 .qword 0x0000000000400c04
            0x00400f60 .qword 0x0000000000400c04
            0x00400f68 .qword 0x0000000000400c04
            0x00400f70 .qword 0x0000000000400c04
            0x00400f78 .qword 0x0000000000400b99
\end{verbatim}

Теперь видно, что адрес 0x400c04 в таблице активно используется, есть
также девять других адресов. Посмотрим сначала 0x400c04!

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0c04.png}
\caption{vmloop bb-0c04}
\end{figure}

Выводится сообщение ``Wrong!'', и функция просто возвращает 0. Это
недопустимые инструкции (они являются допустимым байт-кодами, могут
быть, например, параметрами!). Отметим 0x400c04 соответствующим образом:

\begin{verbatim}
[0x00400ec0]> f not_instr @ 0x0000000000400c04
\end{verbatim}

Что касается других адресов, они, кажется, делают что-то существенное,
предположим, что адреса соответствуют действительным инструкциям.
Пометим их с помощью ASCII-символов:

\begin{verbatim}
[0x00400ec0]> f instr_A @ 0x0000000000400a80
[0x00400ec0]> f instr_C @ 0x0000000000400b6d
[0x00400ec0]> f instr_D @ 0x0000000000400b17
[0x00400ec0]> f instr_I @ 0x0000000000400aec
[0x00400ec0]> f instr_J @ 0x0000000000400bc1
[0x00400ec0]> f instr_P @ 0x0000000000400b42
[0x00400ec0]> f instr_R @ 0x0000000000400be5
[0x00400ec0]> f instr_S @ 0x0000000000400ab6
[0x00400ec0]> f instr_X @ 0x0000000000400b99
\end{verbatim}

Перечисленных адресов нет на графе, определим блоки для них!

\begin{quote}
\textbf{\emph{Совет от r2:}} Блоки графа управления задаются с помощью
команды \emph{afb+}. Надо указать функцию, соответствующую конкретному
блоку, адрес первого байта кода и его размер. Если блок заканчивается
переходом (jmp), надо указать куда осуществляется переход. Если переход
является условным, целевой адрес false-ветви также следует указать.
\end{quote}

Начальный и конечный адрес каждого блока получается в результате анализа
дизассемблированного кода функции \emph{vmloop}.

\begin{figure}
\centering
\includegraphics{img/vmloop/vmloop-full.png}
\caption{все о vmloop}
\end{figure}

Ранее мы видели, что сама функция простая, а ее код короткий, простой в
изучении особенно с нашими аннотациями. Как обещано, создам недостающие
блоки для всех инструкций:

\begin{verbatim}
[0x00400ec0]> afb+ 0x00400a45 0x00400a80 0x00400ab6-0x00400a80 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400ab6 0x00400aec-0x00400ab6 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400aec 0x00400b17-0x00400aec 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400b17 0x00400b42-0x00400b17 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400b42 0x00400b6d-0x00400b42 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400b6d 0x00400b99-0x00400b6d 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400b99 0x00400bc1-0x00400b99 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400bc1 0x00400be5-0x00400bc1 0x400c15
[0x00400ec0]> afb+ 0x00400a45 0x00400be5 0x00400c04-0x00400be5 0x400c15
\end{verbatim}

Из дизассемблированного кода также видно, что кроме блоков инструкций
есть еще три блока. Создадим их тоже!

\begin{verbatim}
[0x00400ec0]> afb+ 0x00400a45 0x00400c15 0x00400c2d-0x00400c15 0x400c3c 0x00400c2d
[0x00400ec0]> afb+ 0x00400a45 0x00400c2d 0x00400c3c-0x00400c2d 0x400c4d 0x00400c3c
[0x00400ec0]> afb+ 0x00400a45 0x00400c3c 0x00400c4d-0x00400c3c 0x400c61
\end{verbatim}

Эти блоки начинаются с адресов 0x00400c15 и 0x00400c2d и заканчиваются
условными переходами, надо задать также адрес назначения для
false-ветви!

И вот граф управления во всей его красе после ручной реструктуризации:

\begin{figure}
\centering
\includegraphics{img/vmloop/vmloop-graph-reconstructed_full.png}
\caption{граф управления vmloop}
\end{figure}

Я думаю, это того стоило? :) На самом деле на реструктуризацию не стоило
тратить время, так как он не сохраняется при сохранении проекта.

\begin{quote}
\textbf{\emph{Совет от r2:}} Можно перемещать выбранный узел в
представлении графика с помощью клавиш HJKL.
\end{quote}

Кстати, вот как выглядит граф этой же функции в IDA:

\begin{figure}
\centering
\includegraphics{img/vmloop_ida.png}
\caption{Граф управления в IDA}
\end{figure}

Просматривая дизассемблированный код \emph{instr\_LETTER} в виде блоков
графа, распознаются несколько сущностей. Первое: все инструкции
начинаются с последовательностей вида

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0a80.png}
\caption{vmloop bb-0a80}
\end{figure}

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0ab6.png}
\caption{vmloop bb-0ab6}
\end{figure}

Теперь ясно, что девять dword-ов в \emph{sym.instr\_dirty} - это не
просто индикаторы того, что инструкция была выполнена, они также
используются для подсчета количества вызовов инструкций. Также я должен
был понять раньше, что \emph{sym.good\_if\_le\_9} (0x6020f0) является
частью этого массива из девяти dword-ов \ldots{} ну да\ldots{} Теперь
как-то надо жить с этим\ldots{} Каков смысл условия
``\emph{sym.good\_if\_le\_9} должно быть меньше или равно 9'' на самом
деле? - \emph{instr\_P} не может быть выполнен более девяти раз:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0b42.png}
\caption{vmloop bb-0b42}
\end{figure}

Еще одно некоторое сходство между инструкциями заключается в том, что
семь из них вызывает функцию либо с одним, либо с двумя параметрами,
причем параметры - это байт-коды, следующий или два последующих. Пример
с одним параметром:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0aec.png}
\caption{vmloop bb-0aec}
\end{figure}

И пример с двумя параметрами:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0a80_full.png}
\caption{vmloop bb-0a80\_full}
\end{figure}

Известно также, что эти блоки помещают в локальную переменную по адресу
0xc количество байтов, которые они ``отъедают'' от байт-кода (1 байт
инструкции + 1 или 2 байта аргументов = 2 или 3), r2 не распознал эту
переменную, давайте обозначим ее вручную!

\begin{verbatim}
:> afv 0xc instr_ptr_step dword
\end{verbatim}

Посмотрим на \emph{instr\_J} и увидим, что это исключение из
приведенного выше правила, так как она помещает возвращаемое значение
вызываемой функции в \emph{instr\_ptr\_step} вместо константы 2 или 3:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0bc1.png}
\caption{vmloop bb-0bc1}
\end{figure}

И, продолжая изучать исключения, вот две инструкции, которые не вызывают
функции:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0be5.png}
\caption{vmloop bb-0be5}
\end{figure}

Эта инструкция просто помещает следующий байт-код (первый аргумент) в
\emph{eax}, и переходит в конец \emph{vmloop}. Итак, добравшись до
инструкции \emph{ret} виртуальной машины, теперь мы знаем, что
\emph{vmloop} должна возвращать ``*'', поэтому ``R*'' должен быть
последними двумя байтами нашего байт-кода.

Следующая инструкция не вызывает функцию:

\begin{figure}
\centering
\includegraphics{img/vmloop/bb-0b6d.png}
\caption{vmloop bb-0b6d}
\end{figure}

Это инструкция с одним аргументом, и она записывает свой аргумент по
адресу 0x6020c0. Установим флаг на этот адрес!

\begin{verbatim}
:> f sym.written_by_instr_C 4 @ 0x6020c0
\end{verbatim}

О, у меня предчувствие, что инструкции \emph{instr\_C} также в исходном
коде crackme соответствовал вызов функции, но он был соптимизирован
компилятором (inlined). Во всяком случае, у нас есть вот эти две
инструкции:

\begin{itemize}
\tightlist
\item
  \emph{instr\_R(a1):} выходит с \emph{a1},
\item
  \emph{instr\_C(a1):} сохраняет \emph{a1} в
  \emph{sym.written\_by\_instr\_C}.
\end{itemize}

Также известно, что эти инструкции принимают один аргумент

\begin{itemize}
\tightlist
\item
  instr\_I,
\item
  instr\_D,
\item
  instr\_P,
\item
  instr\_X,
\item
  instr\_J,
\end{itemize}

я эти принимают два аргумента

\begin{itemize}
\tightlist
\item
  instr\_A,
\item
  instr\_S.
\end{itemize}

Остается взломать семь функций, которые вызываются инструкциями, потом
построить действительную последовательность байт-кода, дающей нам
желанный флаг.

\hypertarget{instr_a}{%
\subsubsection{instr\_A}\label{instr_a}}

Функция, которую вызывает эта инструкция, находится по адресу 0x40080d,
поэтому давайте изучать ее!

\begin{verbatim}
[offset]> 0x40080d
\end{verbatim}

\begin{quote}
\textbf{\emph{Совет от r2:}} В визуальном режиме вы можете просто нажать
\textless Enter\textgreater{} на строке перехода (jmp и др.) или вызова
call, и r2 установит смещение (seek) на адрес назначения.
\end{quote}

Если попробуем перейти на этот адрес в режиме графа управления, получим
сообщение: ``Not in a function''. Введите `df' и задайте его прямо
здесь. Функция вызывается из блока r2, который не был распознан, поэтому
r2 не удалось найти и эту функцию. Повинуемся и набираем старательно
\emph{df}! Функция определена, но нам нужно осмысленное название для
нее. Наберем \emph{dr}, находясь все еще в визуальном режиме, назовем
эту функцию \emph{instr\_A}!

\begin{figure}
\centering
\includegraphics{img/instr_A/instr_A_minimap.png}
\caption{миникарта инструкции instr\_A}
\end{figure}

\begin{quote}
\textbf{\emph{Совет от r2:}} Все эти команды являются частью меню в
визуальном режиме, впервые использованного для определения
\emph{sym.memory} как блока данных: \emph{Cd}.
\end{quote}

Теперь у нас есть наша новая \emph{fcn.instr\_A}, взломаем и ее! Из
формы миникарты видно, что есть какой-то каскад if-then-elif или
оператор switch-case в теле этой функции. Это одна из причин, почему
миникарта так полезна: можно визуально распознать шаблоны в коде,
помогающие при анализе (вспомните легко узнаваемый шаблон цикла
нескольких абзацев тому назад). Итак, признаем, что миникарта классная и
полезная. Покажем все возможности режима графа управления - сделаем все,
что нужно в этом режиме. Первые блоки:

\begin{figure}
\centering
\includegraphics{img/instr_A/bb-080d.png}
\caption{instr\_A bb-080d}
\end{figure}

Два аргумента функции (\emph{RDI} и \emph{RSI}) сохраняются в локальных
переменных, затем первый сравнивается с 0. Если это так, функция
завершается (можно видеть это на миникарте), в противном случае эта же
проверка выполняется по второму аргументу. Функция завершается, если и
второй аргумент равен нулю. Код функции крошечный, но будем
придерживаться используемой методологии и переименуем локальные
переменные:

\begin{verbatim}
:> afvn local_1 arg1
:> afvn local_2 arg2
\end{verbatim}

Мы пришли к ранее распознанному оператору switch-case, теперь видно, что
значение \emph{arg1} сверяется с ``M'', ``P'' и ``C''.

\begin{figure}
\centering
\includegraphics{img/instr_A/switch-values.png}
\caption{значения оператора switch для instr\_A}
\end{figure}

Ветвь ``М'':

\begin{figure}
\centering
\includegraphics{img/instr_A/switch-M.png}
\caption{instr\_A switch-M}
\end{figure}

Загружается адрес из ячейки 0x602088 и суммируется \emph{arg2} с байтом
по этому адресу. Программа r2 показывает нам в комментарии, что 0x602088
изначально содержит адрес \emph{sym.memory}, область памяти нужно
сконструировать строку ``Such VM! MuCH reV3rse!''. Можно предположить,
что надо как-то менять значение, хранящееся по адресу 0x602088,
получается, что ветвь «M» может менять байты, отличные от первого.
Исходя из этого предположения, пометим 0x602088 как
\emph{sym.current\_memory\_ptr}:

\begin{verbatim}
:> f sym.current_memory_ptr 8 @ 0x602088
\end{verbatim}

Переходим к ветке ``P'':

\begin{figure}
\centering
\includegraphics{img/instr_A/switch-P.png}
\caption{instr\_A switch-P}
\end{figure}

Фрагмент кода, позволяющий модифицировать
\emph{sym.current\_memory\_ptr}: он прибавляет к нему \emph{arg2}.

Наконец, ветвь ``C'':

\begin{figure}
\centering
\includegraphics{img/instr_A/switch-C.png}
\caption{instr\_A switch-C}
\end{figure}

Оказывается \emph{instr\_C} - это не единственная инструкция, изменяющая
\emph{sym.written\_by\_instr\_C}: этот фрагмент кода прибавляет к нему
\emph{arg2}.

Мы взломали \emph{instr\_A}, подведем итоги! В зависимости от первого
аргумента, инструкция исполняет следующее:

\begin{itemize}
\tightlist
\item
  \emph{arg1} == ``M'': прибавляет \emph{arg2} к байту по адресу
  \emph{sym.current\_memory\_ptr},
\item
  \emph{arg1} == ``P'': смещает \emph{sym.current\_memory\_ptr} на
  \emph{arg2} байтов,
\item
  \emph{arg1} == ``C'': прибавляет \emph{arg2} к значению по адресу
  \emph{sym.written\_by\_instr\_C}.
\end{itemize}

\hypertarget{instr_s}{%
\subsubsection{instr\_S}\label{instr_s}}

Эта функция также не распозналась автоматически, зададим вручную ее
аналогично \emph{instr\_A}. После этого посмотрим на миникарту,
поперемещаем диаграмму, теперь очевидно, что эти две функции очень
похожи. Можно также использовать \emph{radiff2} для построения диаграммы
различий (diff).

\begin{quote}
\textbf{\emph{Совет от r2:}} Программа radiff2 используется для
сравнения двоичных файлов. Есть возможность управлять способом анализа
двоичных файлов и требуемым форматом результата. Интересной функцией
является порождение графов вида
\href{http://www.darungrim.org/}{DarumGrim} с использованием флага
\emph{-g}.
\end{quote}

Нам надо сравнить две функции из одного и того же двоичного файла,
поэтому указываем смещения при помощи флага \emph{-g}, далее применяем
reverse4 для обоих двоичных файлов. Создадим графы сравнения
\emph{instr\_A} с \emph{instr\_S} и сравнения \emph{instr\_S} с
\emph{instr\_A}.

\begin{verbatim}
[0x00 ~]$ radiff2 -g 0x40080d,0x40089f  reverse4 reverse4 | xdot -
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/instr_S/graph1.png}
\caption{граф сравнения для instr\_S}
\end{figure}

\begin{verbatim}
[0x00 ~]$ radiff2 -g 0x40089f,0x40080d  reverse4 reverse4 | xdot -
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/instr_S/graph2.png}
\caption{граф сравнения instr\_S}
\end{figure}

Печальная правда раскрывается после беглого взгляда на эти графы:
radiff2 лжет! Теоретически серые блоки должны быть идентичными, желтые
должны отличаться только в некоторых адресах, а красные должны серьезно
различаться. Очевидно, что большие серые блоки явно неодинаковы.
Определенно надо рыть глубже даже после того, как я закончу эту статью.

Отойдя от шока, созданного лживым инструментом, легко понимаем, что
инструкция \emph{instr\_S} по сути является обратной \emph{instr\_A},
при этом последняя прибавляет, а первая вычитает. Подведем итог:

\begin{itemize}
\tightlist
\item
  \emph{arg1} == ``M'': вычитает \emph{arg2} из байта по адресу
  \emph{sym.current\_memory\_ptr},
\item
  \emph{arg1} == ``P'': смещает \emph{sym.current\_memory\_ptr} назад на
  \emph{arg2} байт,
\item
  \emph{arg1} == ``C'': вычитает \emph{arg2} из значения по адресу
  \emph{sym.written\_by\_instr\_C}.
\end{itemize}

\hypertarget{instr_i}{%
\subsubsection{instr\_I}\label{instr_i}}

\begin{figure}
\centering
\includegraphics{img/instr_I/instr_I.png}
\caption{instr\_I}
\end{figure}

Инструкция просто вызывает \emph{instr\_A(arg1, 1)}. Заметим, что запуск
функции выглядит как \texttt{call\ fcn.0040080d} вместо
\texttt{call\ fcn.instr\_A}. В текущей версии при сохранении и открытии
проекта имена функций теряются - еще один момент для исправления в r2!

\hypertarget{instr_d}{%
\subsubsection{instr\_D}\label{instr_d}}

\begin{figure}
\centering
\includegraphics{img/instr_D/instr_D.png}
\caption{instr\_D}
\end{figure}

Опять же, все просто: она вызывает \emph{instr\_S(arg1, 1)}.

\hypertarget{instr_p}{%
\subsubsection{instr\_P}\label{instr_p}}

Время переименовать ее локальные переменные!

\begin{verbatim}
:> afvn local_0_1 const_M
:> afvn local_0_2 const_P
:> afvn local_3 arg1
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/instr_P/instr_P.png}
\caption{instr\_P}
\end{figure}

Функция также проста, но есть одна странность: const\_M совсем не
используется. Это вероятно какое-то отвлечение внимания хакера?\ldots{}
По сути функция просто сохраняет \emph{arg1} в
\emph{sym.current\_memory\_ptr}, а затем вызывает
\emph{instr\_I(``P'')}. Это означает, что \emph{instr\_P} сохраняет один
байт и переводит указатель на следующий байт. Эта инструкция идеальна
для построения большей части строки ``Such VM! MuCH reV3rse!'', но ее
можно использовать только девять раз!

\hypertarget{instr_x}{%
\subsubsection{instr\_X}\label{instr_x}}

Переименовываем локальные переменные \ldots{} ну как всегда!

\begin{verbatim}
:> afvn local_1 arg1
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/instr_X/instr_X.png}
\caption{instr\_X}
\end{figure}

Функция выполняет операцию XOR со значением по адресу
\emph{sym.current\_memory\_ptr} с \emph{arg1}.

\hypertarget{instr_j}{%
\subsubsection{instr\_J}\label{instr_j}}

Функция не так проста, как предыдущие, но при этом и не сложна.
Одержимость переименованием переменных приводит к

\begin{verbatim}
:> afvn local_3 arg1
:> afvn local_0_4 arg1_and_0x3f
\end{verbatim}

\begin{figure}
\centering
\includegraphics{img/instr_J/instr_J.png}
\caption{instr\_J}
\end{figure}

После помещения \emph{arg1 \& 0x3f} в локальную переменную, \emph{arg1
\& 0x40} сравнивается с 0. Если результат не равен нулю, биты
\emph{arg1\_and\_0x3f} инвертируются:

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-09e1.png}
\caption{instr\_J bb-09e1}
\end{figure}

Следующее ветвление: если \emph{arg1} \textgreater= 0, то функция
возвращает \emph{arg1\_and\_0x3f},

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-09e4.png}
\caption{instr\_J bb-09e4}
\end{figure}

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-0a1a.png}
\caption{instr\_J bb-0a1a}
\end{figure}

в противном случае функция разветвляется снова в зависимости от значения
\emph{sym.written\_by\_instr\_C}:

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-09ef.png}
\caption{instr\_J bb-09ef}
\end{figure}

Если оно равно нулю, функция возвращает 2,

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-0a13.png}
\caption{instr\_J bb-0a13}
\end{figure}

иначе проверяется, является ли \emph{arg1\_and\_0x3f} отрицательным
числом,

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-09f9.png}
\caption{instr\_J bb-09f9}
\end{figure}

и если это так, то \emph{sym.good\_if\_ne\_zero} увеличивается на 1:

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-09ff.png}
\caption{instr\_J bb-09ff}
\end{figure}

После всех проверок функция возвращает \emph{arg1\_and\_0x3f}:

\begin{figure}
\centering
\includegraphics{img/instr_J/bb-0a0e.png}
\caption{instr\_J bb-0a0e}
\end{figure}

.instructionset

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Теперь все инструкции виртуальной машины взломаны, получено полное
представление об их работе. Приведем набор инструкций виртуальной
машины:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1707}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1707}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.3902}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Инструкция
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Первый аргумент
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Второй аргумент
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Функция исструкции
\end{minipage} \\
\midrule
\endhead
``A'' & ``M'' & arg2 & *sym.current\_memory\_ptr += arg2 \\
& ``P'' & arg2 & sym.current\_memory\_ptr += arg2 \\
& ``C'' & arg2 & sym.written\_by\_instr\_C += arg2 \\
``S'' & ``M'' & arg2 & *sym.current\_memory\_ptr -= arg2 \\
& ``P'' & arg2 & sym.current\_memory\_ptr -= arg2 \\
& ``C'' & arg2 & sym.written\_by\_instr\_C -= arg2 \\
``I'' & arg1 & отсутствует & instr\_A(arg1, 1) \\
``D'' & arg1 & отсутствует & instr\_S(arg1, 1) \\
``P'' & arg1 & отсутствует & *sym.current\_memory\_ptr = arg1;
instr\_I(``P'') \\
``X'' & arg1 & отсутствует & *sym.current\_memory\_ptr \^{}= arg1 \\
``J'' & arg1 & отсутствует & arg1\_and\_0x3f = arg1 \& 0x3f;if (arg1 \&
0x40 != 0)~~arg1\_and\_0x3f *= -1if (arg1 \textgreater= 0) return
arg1\_and\_0x3f;else if (*sym.written\_by\_instr\_C != 0) \{~~if
(arg1\_and\_0x3f \textless{} 0)~~~~++*sym.good\_if\_ne\_zero;~~return
arg1\_and\_0x3f;\} else return 2; \\
``C'' & arg1 & отсутствует & *sym.written\_by\_instr\_C = arg1 \\
``R'' & arg1 & отсутствует & return(arg1) \\
\bottomrule
\end{longtable}

\hypertarget{bytecode}{%
\subsection{.bytecode}\label{bytecode}}

Итак, реверс-инжениринг мы сделали, теперь нужно спроектировать
программу виртуальной машины с набором инструкций, описанным в
предыдущем абзаце. Функциональная спецификация программы:

\begin{itemize}
\tightlist
\item
  программа должна вернуть ``*``,
\item
  \emph{sym.memory} должна содержать строку ``Such VM! MuCH reV3rse!''
  после исполнения,
\item
  все девять инструкций должны быть использованы хотя бы один раз,
\item
  \emph{sym.good\_if\_ne\_zero} должно стать нулем,
\item
  instr\_P нельзя использовать более девяти раз.
\end{itemize}

Поскольку этот документ посвящен реверс-инженирингу, оставляю эту задачу
на усмотрение читателю :). Однако оставлять вас с пустыми руками не
буду, и дам один совет: за исключением ``J'', все инструкции примитивны,
просты в использовании. Проблем с реализацией «Such VM! MuCH reV3rse!''
на основе этих инструкций быть не должно. Инструкция «J» сложнее в
сравнении с другими. Ее единственная задача состоит в том, чтобы сделать
переменную \emph{sym.good\_if\_ne\_zero} большей нуля, это - требование
доступа к флагу.

Чтобы увеличить на единицу \emph{sym.good\_if\_ne\_zero} должны
выполняться три условия:

\begin{itemize}
\tightlist
\item
  \emph{arg1} должен быть отрицательным числом, иначе мы выйдем раньше,
\item
  \emph{sym.written\_by\_instr\_C} не должен быть 0 в момент вызова «J»,
  это означает, что инструкции «C», «AC» и «SC» следует использовать
  перед вызовом «J»,
\item
  \emph{arg1\_and\_0x3f} должен быть отрицательным в момент проверки.
\end{itemize}

Так как бит знака 0x3f равен нулю, несмотря ни на значение \emph{arg1},
результат выражения \emph{arg1} \& 0x3f всегда будет неотрицательный.
Помните, что «J» инвертирует биты \emph{arg1\_and\_0x3f} если
\emph{arg1} \& 0x40 не равен нулю. Это означает, что 6-й бит \emph{arg1}
должен быть 1 (0x40 = 01000000b). Также из-за того, что
\emph{arg1\_and\_0x3f} тоже не может быть 0, по крайней мере один из
битов в позициях 0, 1, 2, 3, 4, 5 \emph{arg1} должен быть 1 (0x3f =
00111111b).

Теперь информации достаточно, можно писать программу. Или же можно
просто сделать быстрый и грязный реверс-инжениринг, использованный ранее
в CTF:

\begin{verbatim}
\x90\x00PSAMuAP\x01AMcAP\x01AMhAP\x01AM AP\x01AMVAP\x01AMMAP\x01AM!AP\x01AM AP\x01AMMAP\x01AMuAP\x01AMCAP\x01AMHAP\x01AM AP\x01AMrAP\x01AMeAP\x01AMVAP\x01AM3AP\x01AMrAP\x01AMsAP\x01AMeIPAM!X\x00CAJ\xc1SC\x00DCR*
\end{verbatim}

Имейте в виду, что этот результат получен ``на лету'', параллельно фазе
взлома. Например, есть части, реализованные без перечня всех возможных
инструкций. Это означает, что код уродлив и неэффективен.

\hypertarget{outro}{%
\subsection{.outro}\label{outro}}

Итак, что еще можно сказать? Сложная виртуальная машина, много пришлось
взламывать! :)

То, что начиналось как обзор простого crackme, превратилось в довольно
детальное руководство по r2, так что спасибо, если вы его до самого
конца прочли. Надеюсь вы остались довольны результатом (я знаю, что это
так) и даже чему-то научились. Я также многое узнал о r2 в процессе
обзора, и даже сделал несколько патчей, у меня появилось несколько идей
о возможных улучшениях.

\hypertarget{ux441ux43fux440ux430ux432ux43eux447ux43dux430ux44f-ux43aux430ux440ux442ux430-radare2}{%
\section{Справочная карта
Radare2}\label{ux441ux43fux440ux430ux432ux43eux447ux43dux430ux44f-ux43aux430ux440ux442ux430-radare2}}

Этот раздел книги основан на справочной карте, разработанной
Thanat0s-ом, лицензия - GNU GPL. Первоначальная лицензия была следующая:

\begin{verbatim}
Эту карточку можно свободно распространять в соответствии с общей публичной лицензией GNU, Copyright Thanat0s - v0.1 -
\end{verbatim}

\hypertarget{ux440ux443ux43aux43eux432ux43eux434ux441ux442ux432ux43e-ux43fux43e-ux432ux44bux436ux438ux432ux430ux43dux438ux44e}{%
\subsection{Руководство по
выживанию}\label{ux440ux443ux43aux43eux432ux43eux434ux441ux442ux432ux43e-ux43fux43e-ux432ux44bux436ux438ux432ux430ux43dux438ux44e}}

Здесь приведены базовые команды, которые необходимо выучить для
перемещения по двоичному файлу, получения о нем информации.

\begin{longtable}[]{@{}ll@{}}
\toprule
Команда & Описание \\
\midrule
\endhead
s (tab) & Установить смещение куда-либо \\
x {[}nbytes{]} & Шестнадцатеричный дамп n байтов, \$b по умолчанию \\
aa & Анализировать автоматически \\
pdf@ {[}funcname{]}(Tab) & Дизассемблировать функцию (main, fcn, и
т.д.) \\
f fcn(Tab) & Перечислить функции \\
f str(Tab) & Перечислить строки \\
fr {[}flagname{]} {[}newname{]} & Переименовать флаг \\
psz {[}offset{]}\textasciitilde grep & Вывод строки и grep-пинг
нужной \\
axF {[}flag{]} & Найти перекрестные ссылки на флаг \\
\bottomrule
\end{longtable}

\hypertarget{ux444ux43bux430ux433ux438-1}{%
\subsection{Флаги}\label{ux444ux43bux430ux433ux438-1}}

Флаг --- это закладка в коде бинарного файла, но с дополнительной
информацией, в частности, размер, теги и ассоциированное с ним
пространство флагов. Команда \texttt{f} используется для перечисления,
задания флагов, а также получения информации о них.

\begin{longtable}[]{@{}ll@{}}
\toprule
Команда & Описание \\
\midrule
\endhead
f & Перечислить флаги \\
fd \$\$ & Показать информацию о смещении \\
fj & Показать флаги в формате JSON \\
fl & Показать длину флага \\
fx {[}flagname{]} & Показать шестнадцатеричный дамп флага \\
fC {[}name{]} {[}comment{]} & Показать комментарий о флаге \\
\bottomrule
\end{longtable}

\hypertarget{ux43fux440ux43eux441ux442ux440ux430ux43dux441ux442ux432ux43e-ux444ux43bux430ux433ux43eux432}{%
\subsection{Пространство
флагов}\label{ux43fux440ux43eux441ux442ux440ux430ux43dux441ux442ux432ux43e-ux444ux43bux430ux433ux43eux432}}

Флаги создаются в пространствах имен, по умолчанию пространство не
выбрано, и команда перечисления флагов будет показывать их все. Если
требуются флаги из конкретного подмножества, используется команда
\texttt{fs}, позволяющая задавать ограничения.

\begin{longtable}[]{@{}ll@{}}
\toprule
Команда & Описание \\
\midrule
\endhead
fs & Показать пространства флагов \\
fs * & Выбрать все пространства флагов \\
fs {[}space{]} & Выбрать пространство флагов \\
\bottomrule
\end{longtable}

\hypertarget{ux438ux43dux444ux43eux440ux43cux430ux446ux438ux44f}{%
\subsection{Информация}\label{ux438ux43dux444ux43eux440ux43cux430ux446ux438ux44f}}

Двоичные файлы включают в себя важную информацию, хранящуюся в
заголовках. Команда \texttt{i} использует API RBin и позволяет получать
информацию в rabin2. Вот наиболее часто используемые команды.

\begin{longtable}[]{@{}ll@{}}
\toprule
Команда & Описание \\
\midrule
\endhead
ii & Информация об импортах \\
iI & Информация о двоичном коде \\
ie & Показать точку входа \\
iS & Показать секции \\
ir & Показать переопределения \\
iz & Перечислить строки (izz, izzz) \\
\bottomrule
\end{longtable}

\hypertarget{ux43fux435ux447ux430ux442ux44c-ux441ux442ux440ux43eux43a}{%
\subsection{Печать
строк}\label{ux43fux435ux447ux430ux442ux44c-ux441ux442ux440ux43eux43a}}

Существуют различные способы представления строк в памяти. Команда
\texttt{ps} позволяет печатать их в кодировке utf-16, в форматах pascal,
С (заканчивающихся нулем), и др.

\begin{longtable}[]{@{}ll@{}}
\toprule
Команда & Описание \\
\midrule
\endhead
psz {[}offset{]} & Печать строки С (с нулем на конце) \\
psb {[}offset{]} & Печать строки в текущем блоке \\
psx {[}offset{]} & Показать строку с использованием
escape-последовательностей \\
psp {[}offset{]} & Печать строки pascal \\
psw {[}offset{]} & Печать wide-строки \\
\bottomrule
\end{longtable}

\hypertarget{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c-2}{%
\subsection{Визуальный
режим}\label{ux432ux438ux437ux443ux430ux43bux44cux43dux44bux439-ux440ux435ux436ux438ux43c-2}}

Визуальный режим поддерживает интерактивный режим взаимодействия с
radare2. Вход в этот режим --- команда \texttt{v} или \texttt{V}, после
чего большинство операций выполняется клавишами клавиатуры.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2388}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7612}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Команда
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Описание
\end{minipage} \\
\midrule
\endhead
V & Вход в визуальный режим \\
p/P & Смена режимов отображения (hex, disasm, debug, words, buf) \\
c & Включить/выключить курсор (c) \\
q & Вернуться в командную строку radare2 \\
hjkl & Перемещение области на экране (или HJKL)
(влево-вниз-вверх-вправо) \\
Enter & Перейти по адресу jump-а или call \\
sS & Step/step over (отладка) \\
o & Переключиться между asm.pseudo и asm.esil \\
. & Установить смещение на адрес в программном счетчике \\
/ & В режиме курсора провести поиск в текущем блоке \\
:cmd & Запустить команду radare \\
;{[}-{]}cmt & Добавить или удалить комментарий \\
/*+-{[}{]} & Изменить размер блока, {[}{]} = resize hex.cols \\
\textless,\textgreater{} & Поиск с учетом выравнивания размер блока \\
i/a/A & вставить (i) hex, (a)ссемблировать код, визуальный
(A)ссемблер \\
b & Включить/выключить точку останова \\
B & Просмотр evals, symbols, flags, classes, \ldots{} \\
d{[}f?{]} & Задать функцию, описать данные, код, \ldots{} \\
D & Вход в режим визуального сравнения (установить diff.from/to) \\
e & Редактировать конфигурационные переменные \\
f/F & Задать/удалить флаг \\
gG & Установить смещение на начало или конец файла (0-\$s) \\
mK/'K & Пометить/перейти на Ключ (любой ключ) \\
M & Обойти подмонтированные файловые системы \\
n/N & Установить смещение на следующую/предыдущую функцию/флаг/вхождение
поиска (scr.nkey) \\
C & Переключить отображение в цвете или ч/б \\
R & Сгенерировать случайную палитру цветов (ecr) \\
tT & Управление панелями на экране. Читайте раздел
\href{visual_panels.md}{Панели} \\
v & Меню анализа кода в визуальном режиме \\
V & Просмотр графа (agv?) \\
wW & Переместить курсов на следующее/предыдущее слово \\
uU & Отменить/повторить установку смещения \\
x & Показать перекрестные ссылки (xrefs) для текущей функции из/в
данные/код \\
yY & Копирование и вставка выделения \\
z & скрыть/раскрыть комментарии в дизассемблировании \\
\bottomrule
\end{longtable}

\hypertarget{ux43fux43eux438ux441ux43a-1}{%
\subsection{Поиск}\label{ux43fux43eux438ux441ux43a-1}}

Возникает много разных задач, где требуется найти значение внутри
двоичного файла или в конкретных областях. Синтаксическая структура
\texttt{e\ search.in=?} позволяет указывать, где команда \texttt{/}
будет осуществлять поиск заданного значения.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2540}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7460}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Команда
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Описание
\end{minipage} \\
\midrule
\endhead
/ foo\textbackslash00 & Поиск строки 'foo\textbackslash0' \\
/b & Поиск в обратном направлении \\
// & повторить предыдущий поиск \\
/w foo & Поиск wide-строки
'f\textbackslash0o\textbackslash0o\textbackslash0' \\
/wi foo & Поиск wide-строки, игнорируя размер букв \\
/! ff & Поиск первых несоответствующих вхождений \\
/i foo & Поиск строки 'foo', игнорируя размер букв \\
/e /E.F/i & Сопоставить с регулярным выражением \\
/x a1b2c3 & Поиск байтов; пробелы и {[}0-9a-fA-F{]} допустимы,
аналогично /x A1 B2 C3 \\
/x a1..c3 & Поиск байтов, игнорируя некоторые hex-числа (автоматически
сгенерированная маска, в этом примере: ff00ff) \\
/x a1b2:fff3 & Поиск байтов по маске (указываются индивидуальные
биты) \\
/d 101112 & Поиск дельтифицированной последовательности байтов \\
/!x 00 & Инверсный поиск hex (найти первый байт != 0x00) \\
/c jmp {[}esp{]} & Поиск ассемблерного кода (смотрите search.asmstr) \\
/a jmp eax & Ассемблировать оп-код и искать его байты \\
/A & Поиск открытых AES-ключей \\
/r sym.printf & Анализировать, куда ссылается оп-код \\
/R & Поиск гаджетов ROP \\
/P & Показать смещение предыдущей инструкции \\
/m magicfile & Поиск следующего magic-файла \\
/p patternsize & Поиск шаблона заданного размера \\
/z min max & Поиск строки заданного размера \\
/v{[}?248{]} num & Поиск 32-битового значения, учитывая asm.bigendian \\
\bottomrule
\end{longtable}

\hypertarget{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux44f-ux441ux43bux43eux43cux430ux43dux43e}{%
\subsection{Сохранения
(сломано)}\label{ux441ux43eux445ux440ux430ux43dux435ux43dux438ux44f-ux441ux43bux43eux43cux430ux43dux43e}}

Эти функции не работают так, как указано в спецификации на момент
написания книги (16 ноября 2020). Дополнительная информация -
\href{https://github.com/radareorg/radare2/issues/6945}{\#Ошибка 6945:
META - Project files} и
\href{https://github.com/radareorg/radare2/issues/17034}{\#Ошибка
17034}.

Чтобы записать результаты анализа (пока проблемы не решены) напишите
себе скрипт, который будет сохранять имя функции, имена переменных, и
т.д., например:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{vim}\NormalTok{ sample\_A.r2}

\ExtensionTok{e}\NormalTok{ scr.utf8 = false}
\ExtensionTok{s}\NormalTok{ 0x000403ce0}
\ExtensionTok{aaa}
\ExtensionTok{s}\NormalTok{ fcn.00403130}
\ExtensionTok{afn}\NormalTok{ return\_delta\_to\_heapaddr}
\ExtensionTok{afvn}\NormalTok{ iter var\_04h}
\ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux445-ux432-ux432ux44bux440ux430ux436ux435ux43dux438ux44fux445}{%
\subsection{Использование переменных в
выражениях}\label{ux438ux441ux43fux43eux43bux44cux437ux43eux432ux430ux43dux438ux435-ux43fux435ux440ux435ux43cux435ux43dux43dux44bux445-ux432-ux432ux44bux440ux430ux436ux435ux43dux438ux44fux445}}

Команда \texttt{?\$?} показывает переменные, которые можно использовать
в математических операциях в командной строки r2. Например, команда
\texttt{?\ \$\$} вычисляет число, а \texttt{?v} - печатает значение в
одном из форматов. Все команды r2 принимают эти переменные в качестве
параметров.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7692}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
Команда
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Описание
\end{minipage} \\
\midrule
\endhead
\(            | here (текущее смещение в виртуальном адресном пространстве)|
| \)\$ & текущее невременное виртуальное смещение \\
\$? & последний результат сравнения \\
\$alias=value & задать синоним (простейшие макросы) \\
\$b & размер блока \\
\$B & базовый адрес (выровненный наименьший адрес отображения) \\
\$f & адрес перехода jump, если условие ложно (jz 0x10 =\textgreater{}
следующая инструкция) \\
\$fl & длина флага (размер), ассоциированного с данным адресом (fla; pD
\$l @ entry0) \\
\$F & размер текущей функции \\
\$FB & начало функции \\
\$Fb & адрес текущего базового блока \\
\$Fs & размер текущего базового блока \\
\$FE & конец функция \\
\$FS & размер функции \\
\$Fj & целевой адрес перехода из функции \\
\$Ff & целевой false-адрес функции \\
\$FI & инструкции функции \\
\(c,\)r & получить ширину и высоту терминала \\
\$Cn & получить n-тый вызов функции \\
\$Dn & получить n-ю ссылку на данные в функции \\
\$D & текущий адрес базы отображения в режиме отладки ?v \$D @ rsp \\
\$DD & текущий размер отображения в режиме отладки \\
\$e & 1 если в конце блока, иначе 0 \\
\$j & адрес jump-а (например, jmp 0x10, jz 0x10 =\textgreater{} 0x10) \\
\$Ja & получить n-тый jump функции \\
\$Xn & получить n-ый xref функции \\
\$l & длина оп-кода \\
\$m & ссылка оп-кода на память (например, mov eax,{[}0x10{]}
=\textgreater{} 0x10) \\
\$M & адрес отображения (наименьший адрес отображения) \\
\$o & here (текущее смещение на диске, io) \\
\$p & getpid() \\
\$P & pid дочернего процесса (только в отладчике) \\
\$s & размер файла \\
\$S & смещение секции \\
\$SS & размер секции \\
\$v & immediate-значение оп-кода (например, lui a0,0x8010
=\textgreater{} 0x8010) \\
\$w & получить размер слова, 4 если asm.bits=32, 8 если 64, \ldots{} \\
\$\{ev\} & значение конфигурационной переменной \\
\$r\{reg\} & значение поименованного регистра \\
\$k\{kv\} & получить ответ на запрос к sdb \\
\$s\{flag\} & размер флага \\
RNum & переменные формата \$variables, полезные в математических
выражениях \\
\bottomrule
\end{longtable}

\hypertarget{ux430ux432ux442ux43eux440ux44b-ux438-ux430ux43aux442ux438ux432ux43dux44bux435-ux443ux447ux430ux441ux442ux43dux438ux43aux438}{%
\subsection{Авторы и активные
участники}\label{ux430ux432ux442ux43eux440ux44b-ux438-ux430ux43aux442ux438ux432ux43dux44bux435-ux443ux447ux430ux441ux442ux43dux438ux43aux438}}

Этой книги не было бы без помощи большого числа участников,
рецензировавших, дописывающих ее и славших сообщения об ошибках и других
проблемах в проекте radare2.

\hypertarget{ux43aux43dux438ux433ux430-radare2-1}{%
\subsubsection{Книга
radare2}\label{ux43aux43dux438ux433ux430-radare2-1}}

Книга была начата maijin как новая версия оригинальной книги о radare,
написанной pancake.

\begin{itemize}
\tightlist
\item
  Книга о radare1 находится здесь
  \url{http://www.radare.org/get/radare.pdf} (ссылка не открывается)
\end{itemize}

Большое спасибо всем, кто участвовал в создании книги на gitbook:

Adrian Studer, Ahmed Mohamed Abd El-MAwgood, Akshay Krishnan R, Andrew
Hoog, Anton Kochkov, Antonio Sánchez, Austin Hartzheim, Aswin C
(officialcjunior), Bob131, DZ\_ruyk, David Tomaschik, Eric, Fangrui
Song, Francesco Tamagni, FreeArtMan, Gerardo García Peña, Giuseppe,
Grigory Rechistov, Hui Peng, ITAYC0HEN, Itay Cohen, Jeffrey Crowell,
John, Judge Dredd (key 6E23685A), Jupiter, Kevin Grandemange, Kevin
Laeufer, Luca Di Bartolomeo, Lukas Dresel, Maijin, Michael Scherer,
Mike, Nikita Abdullin, Paul, Paweł Łukasik, Peter C, RandomLive, Ren
Kimura, Reto Schneider, SchumBlubBlub, SkUaTeR, Solomon, Srimanta Barua,
Sushant Dinesh, TDKPS, Thanat0s, Vanellope, Vex Woo, Vorlent, XYlearn,
Yuri Slobodyanyuk, ali, aoighost, condret, hdznrrd, izhuer, jvoisin,
kij, madblobfish, muzlightbeer, pancake, polym (Tim), puddl3glum,
radare, sghctoma, shakreiner, sivaramaaa, taiyu, vane11ope, xarkes.

\end{document}
