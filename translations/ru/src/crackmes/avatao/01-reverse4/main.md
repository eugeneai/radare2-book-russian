.main
-----

Как было уже не раз сказано, надо сперва смотреть точку входа, так что с этого и начнем:

```
[0x00400720]> s main
[0x00400c63]>
```

> ***Совет от r2:*** Переход к любому смещению, флагу, выражению и т.д. в исполняемом файле выполняется командой *s* (seek). Можно использовать ссылки, например, *$$* (текущее смещение), отменить предыдущее перемещение (*s-* ) или заново его повторить (*s+* ). Команда позволяет искать строки (*s/ [строка]* ) или шестнадцатеричные значения (*s/х 4142*), а также делать много других полезных вещей.
> Имеет смысл почитать инструкции? - *s?*!

Итак, мы находимся в начале функции main, можно, конечно, использовать команду *p* и ее дизассемблирующие разновидности *pd* и *pdf*, но в r2 можно зажигать по полной: у него есть визуальный режим, отображающий графы управления, похожие на графы IDA, но намного круче, так как они изображены в ASCII :)!

> ***Совет от r2:*** Команды группы *p* используется для отображения объектов. Например, команда *pd* дизассемблирует код с текущей позиции, дизассемблирование текущей функции - *pdf*, *ps* печатает строки, *px* - шестнадцатеричные дампы, *p6e* и *p6d* кодируют и декодируют данные согласно base64. Можно выдавать на экран и байты как есть (raw) - *pr*, можно дампы из одних файлов записывать в другие. Есть еще много других функций, см. инструкцию - *?*!

R2 также поддерживает вид миникарты, невероятно полезной для получения общего представления о функции:

![миникарта функции main](img/main/main_minimap.png)

> ***Совет от r2:*** Команда *V* переводит в так называемый визуальный режим, имеющий несколько видов отображения информации. Переключать между ними можно, используя *p* и *P*. Граф отображается, если еще раз нажать *V* в визуальном режиме, либо используя *VV* будучи еще в командной строке.
>
> Нажатие *p* в режиме графа управления переведет систему в режим отображения миникарты. Она отображает базовые функциональные блоки и связи между ними, дизассемблированый код выбранного блока, помеченного @@@@@ на миникарте, отображается тут же рядом. Можно выбирать следующий или предыдущий блок с помощью клавиш
>  \*\<TAB\> \* и \*\<SHIFT\> \<TAB\> \*, соответственно. Переход по ветвям графа между истинными и ложными альтернативамиб очевидно, - *t* и *f*.
>
> В визуальном режиме можно открыть командную строку с помощью лавиши *:*, клавиша *o* - установка смещения.

Походим по графу - узел за узлом! Первый блок выглядит так:

![main bb-0c63](img/main/bb-0c63.png)

Видно, что программа считывает слово (два байта) в локальную переменную с именем *local_10_6*, и затем сравнивает ее с 0xbb8. Это 3000 в десятичном виде:

```
[0x00400c63]> ? 0xbb8
3000 0xbb8 05670 2.9K 0000:0bb8 3000 10111000 3000.0 0.000000f 0.000000
```

> ***Совет от r2:*** Команда *?* вычисляет выражения и печатает результат в различных форматах.

Если значение больше 3000, то оно будет заменено на 3000 принудительно:

![main bb-0ca6](img/main/bb-0ca6.png)

В следующем блоке есть несколько интересных моментов:

![main bb-0cac](img/main/bb-0cac.png)

Печатается сообщение "Size of data: ", которое выдается при запуске программы. Итак, теперь мы знаем, что локальная переменная *local_10_6* - это размер данных, подаваемых на вход. Назовем переменную подходящим именем. Для этого открываем командную стоку r2, находясь в визуальном режиме, с помощью клавиши *:* и вводим туда команду:

```
:> afvn local_10_6 input_size
```

> ***Совет от r2:*** Комбинация *af* - семейство команд, используемых в процессе анализа функций. Включает также модификацию аргументов и локальных переменных функции. Эти возможности находятся в разделе *afv*. Можете перечислить аргументы функции (*afa*), локальные переменные (*afv*), даже переименовать их (*afan*, *afvn*). Существует множество других функций - как обычно: ИСПОЛЬЗУЙ "?", ЛЮК!

После этого в оперативной памяти выделяется кусок длиной  *input_size* байтов и заполняется данными со стандартного ввода. Адрес этого фрагмента памяти хранится в *local_10*, снова используем *afvn*:

```
:> afvn local_10 input_data
```

Почти закончили с этим блоком, осталось всего две вещи.
Блок памяти размером 512 (0x200) байт обнуляется по смещению 0x00602120. Беглый взгляд на XREFS на этот адрес показывает, что эта память действительно используется где-то в приложении:

```
:> axt 0x00602120
d 0x400cfe mov edi, 0x602120
d 0x400d22 mov edi, 0x602120
d 0x400dde mov edi, 0x602120
d 0x400a51 mov qword [rbp - 8], 0x602120
```

Позже это будет важно, поэтому обозначим этот блок памяти:

```
:> f sym.memory 0x200 0x602120
```

> ***Совет от r2:*** Флагами (идентификаторами сущностей) можно управлять с помощью команд, начинающихся с *f*. Мы добавили флаг sym.memory, обозначающий памяти длиной 0x200 байт по адресу 0x602120. Можно также и удалять флаги (*f-name*), переименовывать их (*fr [текущее имя] [новое имя]*), добавлять комантарии(*fC [имя] [cmt]*), и даже раскрашивать цветом (*fc [имя] [цвет]*).

Пока мы не перешли еще куда-то, нужно объявить этот фрагмент памяти  блоком данных, тогда он будет отображаться как шестнадцатеричный дамп при дизассемблировании:

```
:> Cd 0x200 @ sym.memory
```

> ***Совет от r2:*** Команды группы *C* используются для управления метаданными. Можно задавать комментарии (*CC*) или редактировать их (*CC*), обозначать адреса в памяти  блоками данных (*Cd*) или строками (*Cs*) и т.п. Эти команды также выполняются при помощи меню в визуальном режиме, меню вызывается нажатием *d*.

Единственное, что осталось в этом блоке - вызов функции по адресу 0x400a45 с входными данными в качестве ее аргумента. Возвращаемое значение функции сравнивается с "*", осуществляется условный переход в зависимости от результата.

Теперь подтверждается предположения, сделанное в самом начале: этот crackme основан на виртуальной машине. Учитывая эту информацию,  предположим, что эта функция - основной цикл виртуальной машины, а входные данные — это инструкции, которые будет выполнять виртуальная машина. Оформим догадку, назовем функцию *vmloop*, а ее входные данные переименуем с *input_data* в *bytecode*, а *input_size* в *bytecode_length*. В этом нет крайней необходимости в таком небольшом проекте, но рекомендуется называть сущности в соответствии с их назначением, аналогично тому, как пишется программа.

```
:> af vmloop 0x400a45
:> afvn input_size bytecode_length
:> afvn input_data bytecode
```

> ***Совет от r2:*** Команда *af* используется для анализа функции, заданной именем, по указанному адресу. Две другие команды уже использовались ранее.

После переименования локальных переменных, пометки области памяти и переименования функции виртуальной машины дизассемблированный код выглядит так:

![main bb-0cac_meta](img/main/bb-0cac_meta.png)

Вернемся к условному переходу. Если *vmloop* возвращает что-то, кроме "*", программа просто завершает работу, не давая нам наш флаг. Очевидно, нам этого не надо, поэтому идем по ветке false.

![main bb-0d1d](img/main/bb-0d1d.png)

Теперь видно, что строка в этой 512-байтовой области памяти *sym.memory* сравнивается с "Such VM! MuCH reV3rse!". Если они не равны, программа выводит байт-код и выходит:

![main bb-0dde](img/main/bb-0dde.png)

Итак, теперь точно знаем, что нужно предоставить на вход байт-код, который будет генерировать эту строку при исполнении. Как видно на миникарте, осталось проанализировать еще несколько ветвей, для достижения результата нужно выполнить больше условий. Исследуем их прежде чем углубляться в *vmloop*!

Посмотрев миникарту всей функции, видно, что на ней распознается какой-то цикл, начинающийся в блоке *[_0d34_]*, и он  включает следующие узлы:

- [_0d34_]
- [_0d65_]
- [_0d3d_]
- [_0d61_]

Вот дизассемблирование этих блоков. Первый помещает 0 в локальную переменную *local_10_4*:

![main bb-0d34](img/main/bb-0d34.png)

В блоке сравнивается *local_10_4* с числом 8, далее выполняется условный переход на основе полученного результата:

![main bb-0d65](img/main/bb-0d65.png)

Совершенно очевидно, что *local_10_4* - это переменная цикла, поэтому назовем ее соответственно:

```
:> afvn local_10_4 i
```

Следующий блок — это собственно тело цикла:

![main bb-0d3d](img/main/bb-0d3d.png)

Область памяти по адресу 0x6020e0 обрабатывается как массив двойных слов (значения по четыре байта), и проверяется, равно ли i-е его значение нулю. Если это не так, цикл просто продолжает выполняться:

![main bb-0d61](img/main/bb-0d61.png)

Если значение равно нулю, цикл прерывается, перед выходом выполняется этот блок:

![main bb-0d4d](img/main/bb-0d4d.png)

Выводится сообщение: "Use everything!". Как установлено ранее, мы имеем дело с виртуальной машиной. В этом контексте сообщение, вероятно, означает, что нужно использовать все существующие инструкции. Выполнена ли инструкция или нет, она сохраняется по адресу 0x6020e0, поэтому давайте отметим эту область памяти флагом:

```
:> f sym.instr_dirty 4*9 0x6020e0
```

Предполагая, что не выполнен выход из цикла по break, анализируем другие ветвления и переходы:

![main bb-0d6b](img/main/bb-0d6b.png)

Этот фрагмент кода кажется немного странным, если не знаком со спецификой архитектуры процессоров x86_64. В этом фрагменте речь идет об относительной RIP-адресации, где адреса задаются как смещения от адреса текущей инструкции, что упрощает реализацию режима PIE. В любом случае r2 достаточно умен и отображает фактический адрес (0x602104). Получил адрес, пометь его флагом!

```
:> f sym.good_if_ne_zero 4 0x602104
```

Однако, при использовании относительной адресации RIP, флаги не будут отображаться прямо в результате дизассемблирования, а r2 отобразит их в виде комментариев:

![main bb-0d6b_meta](img/main/bb-0d6b_meta.png)

Если *sym.good_if_ne_zero* равен нулю, получаем сообщение ("Your getting closer!"), и затем исполнение программы останавливается. Если не нуль, то переходим к последней проверке:

![main bb-0d75](img/main/bb-0d75.png)

Здесь программа сравнивает двойное слово по адресу 0x6020f0 (опять же используется RIP-адресация) с 9. Если оно больше 9, получаем то же сообщение "Your getting closer!",  если же оно меньше или равно 9, наконец достигаем пункта назначения и получаем флаг:

![main bb-0d80](img/main/bb-0d80.png)

Как обычно, установим флаг для 0x6020f0:

```
:> f sym.good_if_le_9 4 0x6020f0
```

Функция main теперь полностью взломана. Подводя итог, декларируем, программа считывает байт-код со стандартного ввода и передает его виртуальной машине. После выполнения ВМ состояние программы должно удовлетворять этим ограничениям для получения подтверждения о выполнении всего задания:

- возвращаемое значение *vmloop*-а должно быть "*",
- *sym.memory* должна содержать строку "Such VM! MuCH reV3rse!",
- все девять элементов массива *sym.instr_dirty* не должны быть равны нулю, вероятно, это означает что все инструкции надо использовать хотя бы один раз,
- *sym.good_if_ne_zero* должно стать нулем,
- *sym.good_if_le_9* должно быть меньше или равно 9.

На этом завершается анализ функции main, теперь можно перейти к самой виртуальной машине.
