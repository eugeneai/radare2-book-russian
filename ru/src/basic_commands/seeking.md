## Установка базового смещения

Чтобы перемещаться по проверяемому файлу, т.е. *менять адрес смещения*, требуется изменять смещение при помощи команды `s`. Аргумент представляет собой математическое выражение, которое может содержать имена флагов, скобки, сложение, вычитание, умножение непосредственных значений содержимого памяти с помощью скобок.

Несколько примеров использования команд:

```
[0x00000000]> s 0x10
[0x00000010]> s+4
[0x00000014]> s-
[0x00000010]> s+
[0x00000014]>
```

Посмотрите, как изменяется смещение (seek) в левой части командной строке. Первая строка устанавливает текущее смещение по адресу 0x10. Вторая смещает адрес на четыре байта вперед (переместиться относительно предыдущего смещения). И, наконец, последние две команды отменяют (undo) и заново выполняют (redo) последние операции установки адреса (seek). Вместо использования исключительно числовых значений, можно использовать сложные выражения и обычные арифметические операции для вычисления адреса. Ознакомьтесь с инструкцией, предоставляемой командой ?$?, там описаны переменные, которые можно использовать в адресных выражениях. Например, следующие выражение делает то же самое что и `s+4`.

```
[0x00000000]> s $$+4
```

В отладчике (или в режиме эмуляции ESIL) можно использовать имена регистров в качестве адресов. Имена регистров — это флаги, их перечень доступен при помощи `.dr*`.

```
[0x00000000]> s rsp+0x40
```

Приведем справку по командам группы `s`. Более детально они будут рассмотрены на примерах далее.

```
[0x00000000]> s?
Usage: s    # Инструкция по командам смены смещения. Смотрите ?$? - перечень всех переменных
| s                 Показать текущее смещение (адрес)
| s.hexoff          Задать смещение, используя систему счисления из core->offset
| s:pad             Показать текущее смещение в поле N символов (по умолчанию 8), заполняя пустое место нулями
| s addr            Усановить смещение по заданному адресу
| s-                Отменить предыдущую операцию установки смещение
| s-*               Вернуть ранее отмененную операцию смещения
| s- n              Переместиться на n в обратном направлении
| s--[n]            Переместиться на blocksize байт в обратном направлении (/=n)
| s+                Вернуть ранее отмененную операцию смещения
| s+ n              Переместиться на n дальше
| s++[n]            Переместиться на blocksize байт вперед (/=n)
| s[j*=!]           Показать историю отмен операций смещения (JSON, =list, *r2, !=names, s==)
| s/ DATA           Поиск следующего вхождения 'DATA'
| s/x 9091          Поиск следующего вхождения \x90\x91
| sa [[+-]a] [asz]  Установить смещение asz (или bsize), выровненный на адрес
| sb                Установить смещение выровненным на начало базового блока
| sC[?] string      Установить смещение на комментарий, соответствующий заданной строке
| sf                Установить смещение на следующую функцию (f->addr+f->size)
| sf function       Установить смещение на адрес заданной функции
| sf.               Установить адрес смещения на начало текущей функции
| sg/sG             Установить смещение на начало (sg) или конец (sG) секции или файла
| sl[?] [+-]line    Установить смещение на строку
| sn/sp ([nkey])    Установить смещение следующее/предыдущее место, в соответствии с scr.nkey
| so [N]            Установить смещение на N-ый следующий по-код
| sr pc             Установить смещение на адрес в регистре
| ss                Установить смещение без добавления записи в историю адресов смещений

> 3s++        ; выполнить три раза операцию установки смещения к следующему блоку
> s 10+0x80   ; установить смещение на 0x80+10
```

Результат математического выражения можно посмотреть при помощи команды `?`. Выражение передается в качестве аргумента. Результат отображается в шестнадцатеричном, десятичном, восьмеричном и двоичном форматах.

```
> ? 0x100+200
0x1C8 ; 456d ; 710o ; 1100 1000
```

Существуют также подкоманды `?`, отображающие результаты в одном конкретном формате (по базе 10, 16, ...). Смотрите `?v` и `?vi`.

В визуальном режиме можно нажать `u` (undo) или `U` (redo) внутри истории адресов смещений — перемещение в обоих направлениях по адресам смещений.

## Открыть файл

Рассмотрим работу команд на простом примере `hello_world.c`, скомпилированном в Linux ELF. После сборки компилятором, откроем его radare2-ом:

```
$ r2 hello_world
```

Теперь у нас есть командная строка:

```
[0x00400410]>
```

## Перемещение смещения на любые адреса

Все команды перемещения (seek), принимающие адрес в качестве параметра, могут использовать любую систему счисления, например, шестнадцатеричную, восьмеричную, двоичную или десятичную.

Установка адреса 0x0. Альтернативный вариант — просто `0x0`:

```
[0x00400410]> s 0x0
[0x00000000]>
```

Показать текущий адрес:
```
[0x00000000]> s
0x0
[0x00000000]>
```

Существует альтернативный способ печати текущей позиции - `?v $$`.

Перемещение на N позиций вперед, пробел необязателен:

```
[0x00000000]> s+ 128
[0x00000080]>
```

Отмена последних двух смещений, возврат к исходному адресу:

```
[0x00000080]> s-
[0x00000000]> s-
[0x00400410]>
```

Мы вернулись к _0x00400410_.

Теперь можно показать историю адресов смещений:

```
[0x00400410]> s*
f undo_3 @ 0x400410
f undo_2 @ 0x40041a
f undo_1 @ 0x400410
f undo_0 @ 0x400411
# Current undo/redo position. # Текущеее положение 
f redo_0 @ 0x4005b4
```
