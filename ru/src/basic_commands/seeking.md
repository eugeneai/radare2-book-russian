## Установка базового всмещения

Чтобы перемещаться по проверяемому файлу, требуется изменять смещение при помощи команды `s` .

Аргумент представляет собой математическое выражение, которое может содержать имена флагов, скобки, сложение, вычитание, умножение непосредственных значений содержимого памяти с помощью скобок.

Несколько примеров использования команд:

```
[0x00000000]> s 0x10
[0x00000010]> s+4
[0x00000014]> s-
[0x00000010]> s+
[0x00000014]>
```

Посмотрите, как изменяется смещение в левой части командной строке. Первая строка устанавливает текущее смещение по адресу 0x10.

Вторая смещает адрес на 4 байт вперед (относительное смещение).

И, наконец, последние две команды отменяют и заново выполняют (redoing) последние операции установки адреса (seek).

Вместо использования исключительно числовых значений, можем использовать сложные выражения или основные арифметические операции для представления адреса.

Для этого ознакомьтесь с выводом команды ?$? - справочное сообщение, описывающее внутренние переменные, потенциально используемые в выражениях. Например, следующие выражение делает то же самое что и s+4 .

```
[0x00000000]> s $$+4
```

В отладчике (или в режиме эмуляции) можно использовать имена регистров в качестве адресов. Они представляются в виде флагов с помощью команды `.dr*`.

```
[0x00000000]> s rsp+0x40
```

Вот полная справка по команде `s`. We will explain in more detail below.

```
[0x00000000]> s?
Usage: s    # Help for the seek commands. Смотрите инструкции ?$? с перечнем всех переменных
| s                 Print current address
| s.hexoff          Seek honoring a base from core->offset
| s:pad             Print current address with N padded zeros (defaults to 8)
| s addr            Seek to address
| s-                Undo seek
| s-*               Reset undo seek history
| s- n              Seek n bytes backward
| s--[n]            Seek blocksize bytes backward (/=n)
| s+                Redo seek
| s+ n              Seek n bytes forward
| s++[n]            Seek blocksize bytes forward (/=n)
| s[j*=!]           List undo seek history (JSON, =list, *r2, !=names, s==)
| s/ DATA           Search for next occurrence of 'DATA'
| s/x 9091          Search for next occurrence of \x90\x91
| sa [[+-]a] [asz]  Seek asz (or bsize) aligned to addr
| sb                Seek aligned to bb start
| sC[?] string      Seek to comment matching given string
| sf                Seek to next function (f->addr+f->size)
| sf function       Seek to address of specified function
| sf.               Установить адрес смещения на начало текущей функции
| sg/sG             Seek begin (sg) or end (sG) of section or file
| sl[?] [+-]line    Seek to line
| sn/sp ([nkey])    Seek to next/prev location, as specified by scr.nkey
| so [N]            Seek to N next opcode(s)
| sr pc             Seek to register
| ss                Seek silently (without adding an entry to the seek history)

> 3s++        ; 3 times block-seeking
> s 10+0x80   ; seek at 0x80+10
```

Если надо проверить результат математического выражения, можно вычислить его с помощью команды `?`. Просто передайте выражение в качестве аргумента. Результат может отображаться в шестнадцатеричном, десятичном, восьмеричном или двоичном форматах.

```
> ? 0x100+200
0x1C8 ; 456d ; 710o ; 1100 1000
```

Существуют также подкоманды `?`, отображающие результаты в одном конкретном формате (по базе 10, 16 ,...). Смотрите `?v` и `?vi`.

В визуальном режиме можно нажать `u` (undo) или `U` (redo) внутри истории адресов смещений - перемещение в обоих направлениях по местоположения.

## Открыть файл

В качестве тестового файла воспользуемся простым `hello_world.c`, скомпилированным в формате Linux ELF.
После сборки компилятором, откроем его с помощью radare2:

```
$ r2 hello_world
```

Теперь у нас есть командная строка:

```
[0x00400410]>
```

Идем углубже.

## Перемещение смещения на любые адреса

Все команды перемещения, принимающие адрес в качестве параметра, могут использовать любую ситсему счисления, например, шестнадцатеричную, восьмеричную, двоичную или десятичную.

Установка к адреса 0x0. Альтернативный вариант - просто `0x0`

```
[0x00400410]> s 0x0
[0x00000000]>
```

Показать текущий адрес:
```
[0x00000000]> s
0x0
[0x00000000]>
```

Существует альтернативный способ печати текущей позиции: `?v $$`.

Перемещение на N позиций вперед, пробел необязателен:

```
[0x00000000]> s+ 128
[0x00000080]>
```

Отмена последних двух смещений, возврат к исходному адресу:

```
[0x00000080]> s-
[0x00000000]> s-
[0x00400410]>
```

Мы вернулись к _0x00400410_.

Есть также команда - показать историю смещений:

```
[0x00400410]> s*
f undo_3 @ 0x400410
f undo_2 @ 0x40041a
f undo_1 @ 0x400410
f undo_0 @ 0x400411
# Current undo/redo position.
f redo_0 @ 0x4005b4
```

