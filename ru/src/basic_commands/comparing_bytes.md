## Сравнение байтов

В реверс-инжениринге часто решаются задачи поиска различий между двумя двоичными файлами, выявления измененных байтов, сравнения графов, представляющих результаты анализа кода, а также выполнение других операций сравнения. Сравнение реализуется при помощи программы radiff2:

```
$ radiff2 -h
```

Внутри r2 функциональные возможности, предоставляемые radiff2, доступны при помощи набора команд `c`.

Команда `c` (сокращение от «compare») позволяет сравнивать массивы байтов из разных источников. Команда принимает ввод в нескольких форматах, а затем сравнивает его со значениями, найденными в текущем смещении.

```
[0x00404888]> c?
Usage: c[?dfx] [argument]   # Сравнение
| c [string]               Сравнение обычной строки со строкой с escape-последовательностями
| c* [string]              То же, что выше, но печатая результат в виде команд r2
| c1 [addr]                Сравнить 8 бит в текущем смещении
| c2 [value]               Сравнить со словом, полученным в результате вычисления выражения
| c4 [value]               Сравнить с двойным словом, полученным в результате вычисления выражения
| c8 [value]               Сравнить с quadword, полученным в результате вычисления выражения
| cat [file]               Показать содержимое файла (смотрите pwd, ls)
| cc [at]                  Сравнить две колонки шестнадцатеричных дампов, ограниченных размером блока
| ccc [at]                 То же, что выше, но показывая измененные строки
| ccd [at]                 Сравнить два столбца дизассемблирования, ограниченных размером блока
| ccdd [at]                Сравнить вывод декомпилятора (e cmd.pdc=pdg|pdd)
| cf [file]                Сравнить с содержимым файлов по текущему смещению
| cg[?] [o] [file]         Сравнение графов текущего файла и файла [file]
| cu[?] [addr] @at         Сравнить дампы памяти по адресу $$ и dst, используя формат unified diff
| cud [addr] @at           Unified diff disasm from $$ and given address
| cv[1248] [hexpairs] @at  Сравнить 1,2,4,8-байтовые последовательности (silent return in $?)
| cV[1248] [addr] @at      Сравнить 1,2,4,8-байтовые последовательности, задаваемые адресом (silent, return in $?)
| cw[?] [us?] [...]        Сравнить watcher-ов памяти
| cx [hexpair]             Сравнить строки шестнадцатеричных кодов (ипользуйте '.' для обозначения позиции в шпблоне)
| cx* [hexpair]            Сравнить строки шестнадцатеричных кодов (вывод в виде команд r2)
| cX [addr]                Аналогично 'cc', но используя hexdiff
| cd [dir]                 Перейти в директорий
| cl|cls|clear             Стереть все с экрана, (clear0 - перейти на 0, и только 0)
```

Чтобы сравнить содержимое памяти в текущей позиции поиска с заданной строкой значений, используйте`cx`:

```
[0x08048000]> p8 4
7f 45 4c 46

[0x08048000]> cx 7f 45 90 46
Compare 3/4 equal bytes
0x00000002 (byte=03)   90 ' '  ->  4c 'L'
[0x08048000]>
```

Еще одна команда группы `с` - `cc` (compare code).
Сравнение последовательности байтов с последовательностью в памяти:

```
[0x4A13B8C0]> cc 0x39e8e089 @ 0x4A13B8C0
```

Сравнение содержимого двух функций, указанных по именам:

```
[0x08049A80]> cc sym.main2 @ sym.main
```

Команда `с8` сравнивает quadword по текущему смещению (в приведенном ниже примере 0x00000000) с математическим выражением:

```
[0x00000000]> c8 4

Compare 1/8 equal bytes (0%)
0x00000000 (byte=01)   7f ' '  ->  04 ' '
0x00000001 (byte=02)   45 'E'  ->  00 ' '
0x00000002 (byte=03)   4c 'L'  ->  00 ' '
```

Параметр может быть математическим выражением, в котором используются имена флагов и все, что разрешено в выражении:

```
[0x00000000]> cx 7f469046

Compare 2/4 equal bytes
0x00000001 (byte=02)   45 'E'  ->  46 'F'
0x00000002 (byte=03)   4c 'L'  ->  90 ' '
```

Можно использовать команду сравнения, чтобы найти различия между текущим блоком и файлом, ранее сброшенным на диск:

```
r2 /bin/true
[0x08049A80]> s 0
[0x08048000]> cf /bin/true
Compare 512/512 equal bytes
```
