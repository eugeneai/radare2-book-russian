# Типы данных

Radare2 поддерживает описание типов данных при помощи синтаксиса языка C.
Описания синтаксически анализируются, сохраняются во внутренний SDB и доступны для интроспекции при помощи команды `k`. Синтаксис описаний совместим с C11. Большинство связанных с этой функцией команд находятся в пространстве имен `t`:

```
[0x00000000]> t?
| Usage: t   # команды задания типов (подсистемы cparse)
| t                          Перечислить все загруженные типы
| tj                         Перечислить все загруженные типы в формате json
| t <type>                   Показать тип в синтаксисе 'pf'
| t*                         Показать информацию о типах в виде команд r2
| t- <name>                  Удалить типы по их именам
| t-*                        Удалить все типы
| tail [filename]            Вывести последнюю часть файла
| tc [type.name]             Перечислить все/заданные типы в формате C
| te[?]                      Перечислить все загруженные enum-ы
| td[?] <string>             Загрузить типы из строк
| tf                         Перечислить все загруженные функции
| tk <sdb-query>             Выполнить запрос sdb
| tl[?]                      Показать/привязать тип по/к адресу
| tn[?] [-][addr]            Управление атрибутами и метками noreturn-функции
| to -                       Открыть cfg.editor для загрузки типов
| to <path>                  Загрузить типы из заголовочных файлов C
| toe [type.name]            Открыть cfg.editor для редактирования типов
| tos <path>                 Загрузить типы из базы данных sdb, представленной в текстовом виде
| tp  <type> [addr|varname]  Преобразовать данные по <addr-есу> в <type> и распечатать результат (XXX: тип может содержать пробелы)
| tpv <type> @ [value]       Показать смещение, представленное в формате, соответствующем заданному типу
| tpx <type> <hexpairs>      Показать значение для типа для заданной последовательности байтов (XXX: тип может содержать пробелы)
| ts[?]                      Показать загруженные типы-структуры
| tu[?]                      Показать загруженные типы-юнионы
| tx[f?]                     Распечатать xrefs
| tt[?]                      Перечислить все загруженные typedef-ы
```

Обратите внимание, что базовые (атомарные) типы не соответствуют стандарту C — нет `char`, `_Bool` и `short`. Эти типы могут быть разными на разных платформах, radare2 использует *строго определенные* типы, такие как `int8_t` или `uint64_t`, и конвертирует `int` в `int32_t` или в `int64_t` в зависимости от бинарной или отлаживаемой платформы/компилятора. Базовые типы перечисляются с помощью команды `t`. Для типов структур нужно использовать `ts`, для юнионов — `tu`, а для перечислений — `te`.

```
[0x00000000]> t
char
char *
double
float
gid_t
int
int16_t
int32_t
int64_t
int8_t
long
long long
pid_t
short
size_t
uid_t
uint16_t
uint32_t
uint64_t
uint8_t
unsigned char
unsigned int
unsigned short
void *
```

### Загрузка типов

Есть три способа определить новый тип:

* Непосредственно из командной строки с помощью команды `td`,
* Из файла с помощью `to <имя файла>`,
* Открыть `$EDITOR` для ввода определений с помощью `to -`.

```
[0x00000000]> "td struct foo {char* a; int b;}"
[0x00000000]> cat ~/radare2-regressions/bins/headers/s3.h
struct S1 {
    int x[3];
    int y[4];
    int z;
};
[0x00000000]> to ~/radare2-regressions/bins/headers/s3.h
[0x00000000]> ts
foo
S1
```

Radare2 позволяет организовать папку для хранения описаний типов и включений.

```
[0x00000000]> e? dir.types
dir.types: Месторасположение по умолчанию, где надо искать файлы формата cparse
[0x00000000]> e dir.types
/usr/include
```

### Распечатка структур

Команда `ts` преобразует описание типа C (или, если быть точным, представление SDB) в последовательность команд `pf`. Смотрите подробнее о [печати структур](../basic_commands/print_modes.md). Команда `tp` использует строку `pf` для печати всех полей типа по текущему смещению/данному адресу:

```
[0x00000000]> "td struct foo {char* a; int b;}"
[0x00000000]> wx 68656c6c6f000c000000
[0x00000000]> wz world @ 0x00000010 ; wx 17 @ 0x00000016
[0x00000000]> px
[0x00000000]> ts foo
pf zd a b
[0x00000000]> tp foo
 a : 0x00000000 = "hello"
 b : 0x00000006 = 12
[0x00000000]> tp foo @ 0x00000010
 a : 0x00000010 = "world"
 b : 0x00000016 = 23
```

Можно также заполнить структуру своими данными и распечатать ее, используя команду `tpx`.

```
[0x00000000]> tpx foo 414243440010000000
 a : 0x00000000 = "ABCD"
 b : 0x00000005 = 16
```

### Типы ссылок

Команда `tp` просто выполняет приведение типов. Но если надо связать какой-то адрес или переменную с выбранным типом нужно использовать команду `tl` для сохранения этого отношения в SDB.

```
[0x000051c0]> tl S1 = 0x51cf
[0x000051c0]> tll
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
```

Причем ссылка будет показана в дизассемблированном выводе или в визуальном режиме:

```
[0x000051c0 15% 300 /bin/ls]> pd $r @ entry0
 ;-- entry0:
 0x000051c0      xor ebp, ebp
 0x000051c2      mov r9, rdx
 0x000051c5      pop rsi
 0x000051c6      mov rdx, rsp
 0x000051c9      and rsp, 0xfffffffffffffff0
 0x000051cd      push rax
 0x000051ce      push rsp
(S1)
 x : 0x000051cf = [ 2315619660, 1207959810, 34803085 ]
 y : 0x000051db = [ 2370306049, 4293315645, 3860201471, 4093649307 ]
 z : 0x000051eb = 4464399
 0x000051f0      lea rdi, loc._edata         ; 0x21f248
 0x000051f7      push rbp
 0x000051f8      lea rax, loc._edata         ; 0x21f248
 0x000051ff      cmp rax, rdi
 0x00005202      mov rbp, rsp
```

После того как структура связана, radare2 пытается распространить смещение структуры внутри функции, которой принадлежит текущее смещение. Чтобы запустить этот анализ во всей программе или в любых целевых функциях после того, как все структуры будут связаны, — команда `aat`:

```
[0x00000000]> aa?
| aat [fcn]           Анализировать все/заданную функцию, преобразовать immediate-ы в смещения связнных структур (смотрите tl?)
```

Иногда эмуляция может быть неточной, например, как показано ниже:

````
|0x000006da  push rbp
|0x000006db  mov rbp, rsp
|0x000006de  sub rsp, 0x10
|0x000006e2  mov edi, 0x20               ; "@"
|0x000006e7  call sym.imp.malloc         ;  void *malloc(size_t size)
|0x000006ec  mov qword [local_8h], rax
|0x000006f0  mov rax, qword [local_8h]

````

Возвращаемое значение `malloc` может отличаться в разных запусках эмуляции, нужно установить подсказку (hint) для возвращаемого значения вручную, используя команду `ahr`, потом снова запустить `tl` или `aat`.

```
[0x000006da]> ah?
| ahr val            установить подсказку для возвращаемого значения функции
```

### Structure Immediates

Есть еще один важный аспект использования типов в Radare2 — использование `aht`, что позволяет изменять immediate-значение в коде операции на смещение структуры. Рассмотрим простой пример относительной (RSI) адресации:

```
[0x000052f0]> pd 1
0x000052f0      mov rax, qword [rsi + 8]    ; [0x8:8]=0
```
Здесь `8` - некоторое смещение в памяти, где `rsi`, вероятно, содержит указатель структуры. Представьте, что у нас есть следующие структуры
```

[0x000052f0]> "td struct ms { char b[8]; int member1; int member2; };"
[0x000052f0]> "td struct ms1 { uint64_t a; int member1; };"
[0x000052f0]> "td struct ms2 { uint16_t a; int64_t b; int member1; };"
```
Теперь нам нужно установить правильное смещение поля структуры вместо `8`-ки, упомянутой в инструкции. Сначала нужно перечислить доступные типы, соответствующие этому смещению:

```
[0x000052f0]> ahts 8
ms.member1
ms1.member1
```

Обратите внимание, что `ms2` не указан, так как в нем нет элементов со смещением `8`. После перечисления доступных вариантов связываем их с выбранным смещением:

```
[0x000052f0]> aht ms1.member1
[0x000052f0]> pd 1
0x000052f0      488b4608       mov rax, qword [rsi + ms1.member1]    ; [0x8:8]=0
```

### Управление перечислениями

* Печать всех полей в перечислении — команда `te`:

```
[0x00000000]> "td enum Foo {COW=1,BAR=2};"
[0x00000000]> te Foo
COW = 0x1
BAR = 0x2
```

* Поиск соответствующего члена перечисления для заданного битового поля и наоборот:

```
[0x00000000]> te Foo 0x1
COW
[0x00000000]> teb Foo COW
0x1
```

## Внутреннее представление

Чтобы увидеть внутреннее представление типов, используйте команду `tk`:

```
[0x000051c0]> tk~S1
S1=struct
struct.S1=x,y,z
struct.S1.x=int32_t,0,3
struct.S1.x.meta=4
struct.S1.y=int32_t,12,4
struct.S1.y.meta=4
struct.S1.z=int32_t,28,0
struct.S1.z.meta=0
[0x000051c0]>
```

Определение примитивных типов требует понимания основных форматов `pf`, вот список спецификаторов формата `pf??`:

```
-----------------------------------------------------------------------
| format | explanation                                                |
|---------------------------------------------------------------------|
|  b     |  byte (unsigned)                                           |
|  c     |  char (signed byte)                                        |
|  d     |  0x%%08x шестнадцатеричное значение (4 байта)              |
|  f     |  значение float (4 байта)                                  |
|  i     |  %%i значение integer (4 байта)                            |
|  o     |  0x%%08o восьмеричное значение (4 байта)                   |
|  p     |  указатель (2, 4 или 8 байт)                               |
|  q     |  quadword (8 байт)                                         |
|  s     |  32bit-указатель на строку (4 байта)                       |
|  S     |  64bit-указатель на строку (8 байт)                        |
|  t     |  UNIX timestamp (4 байта)                                  |
|  T     |  показать первых десять (Ten) байт буфера                  |
|  u     |  uleb128 (variable length)                                 |
|  w     |  word (2 байта, unsigned short в шестнадцатеричном виде)   |
|  x     |  0x%%08x шестнадцатеричное значение и флаг (fd @ addr)     |
|  X     |  показать последовательность шестнадцатеричных кодов       |
|  z     |  строка, заканчивающаяся \0                                |
|  Z     |  wide-строка, заканчивающаяся \0                           |
-----------------------------------------------------------------------

```
Есть только три обязательных ключа для определения базовых типов:
```
X=type
type.X=format_specifier
type.X.size=size_in_bits
```

Например, определим `UNIT` согласно спецификации в [документации Microsoft](https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx#UINT). Тип `UINT` - это лишь эквивалент стандартному типу C `unsigned int` (или `uint32_t` в терминах системы TCC). Тип определяется так:

```
UINT=type
type.UINT=d
type.UINT.size=32
```

Определение некоторого типа можно дополнить необязательной строкой:

`X.type.pointto=Y`

Она используется только в случае задания указателя, когда `type.Х=р`. Хорошим примером выступает определение типа `LPFILETIME`, указателя на структуру `_FILETIME`. Предполагая, что мы работаем только с 32-разрядной машиной Windows, структура будет определена следующим образом:

```
LPFILETIME=type
type.LPFILETIME=p
type.LPFILETIME.size=32
type.LPFILETIME.pointto=_FILETIME
```

Последнее поле не является обязательным, поскольку иногда в структурах данных внутренности бывают скрытыми от глаз разработчиков согласно коммерческим лицензиям (proprietrary), а у нас может не быть информации для них четкого определения.

Есть еще одно необязательное определение:

```
type.UINT.meta=4
```

Эта форма предназначена для интеграции с синтаксическим анализатором C и содержит информацию о классе типов: *целочисленный размер*, *знаковый/беззнаковый* и т.д.

### Структуры

Вот основные ключи для структур (всего два элемента):

```
X=struct
struct.X=a,b
struct.X.a=a_type,a_offset,a_number_of_elements
struct.X.b=b_type,b_offset,b_number_of_elements
```

Первая строка используется для определения структуры, называемой `X`, вторая строка определяет элементы `X` как значения, разделенные запятыми. После этого просто определяем информацию о каждом элементе.

Приведем примеры. Предположим в исходном коде есть такая структура:

```
struct _FILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
}
```

Полагая, что `DWORD` определено, структура будет выглядеть так:

```
_FILETIME=struct
struct._FILETIME=dwLowDateTime,dwHighDateTime
struct._FILETIME.dwLowDateTime=DWORD,0,0
struct._FILETIME.dwHighDateTime=DWORD,4,0
```

Обратите внимание, что поле количества элементов используется только в случае массивов, по умолчанию оно равно нулю.

### Юнионы

Юнионы определяются точно так же, как структуры, с той лишь разницей, что вы заменяете слово `struct` на `union`.

### Прототипы функций

Представление прототипов функций является наиболее подробным и наиболее важным среди всех определений. На самом деле, это то, что используется непосредственно для сопоставления типов.

```
X=func
func.X.args=NumberOfArgs
func.x.arg0=Arg_type,arg_name
.
.
.
func.X.ret=Return_type
func.X.cc=calling_convention
```

Все и так понятно. Определим прототип для strncasecmp в качестве примера для архитектуры x86 и машин Linux. Согласно справке в man функция strncasecmp определяется следующим образом:

```
int strcasecmp(const char *s1, const char *s2, size_t n);
```

При преобразовании в представление sdb ее прототип будет выглядеть следующим образом:

```
strcasecmp=func
func.strcasecmp.args=3
func.strcasecmp.arg0=char *,s1
func.strcasecmp.arg1=char *,s2
func.strcasecmp.arg2=size_t,n
func.strcasecmp.ret=int
func.strcasecmp.cc=cdecl
```

Обратите внимание, что часть `.cc` является необязательной, и если она не используется, то использоваться соглашение о вызовах по умолчанию для вашей целевой архитектуры. Есть еще один дополнительный необязательный ключ

```
func.x.noreturn=true/false
```

Этот ключ используется для обозначения функций, из которых невозможно вернуться в вызывающую подпрограмму, например `exit` и `_exit`.
