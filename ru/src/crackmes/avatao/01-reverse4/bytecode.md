.bytecode
---------

Итак, реверс-инжиниринг мы сделали, теперь нужно спроектировать программу для
 ВМ с набором инструкций, описанным в предыдущем абзаце. Функциональная спецификация программы:

- программа должна вернуть "*",
- *sym.memory* должна содержать строку "Such VM! MuCH reV3rse!" после
   исполнения,
- все 9 инструкций должны быть использованы хотя бы один раз,
- *sym.good_if_ne_zero* должно стать нулем,
- instr_P нельзя использовать более 9 раз,

Поскольку этот документ посвящен реверс-инженирингу, оставляю эту задачу на усмотрение
 читателю :). Однако оставлять вас с пустыми руками не буду, и дам один
 Совет: За исключением "J", все инструкции примитивны, просты в использовании. Проблем с реализацией «Such VM! MuCH reV3rse!" на основе этих инструкций быть не должно.
Инструкция «J» сложнее по сравнению с другими. Ее единственная задача состоит в том, чтобы сделать *sym.good_if_ne_zero* большей нуля, это - требование доступа к флагу. Чтобы увеличить на единицу *sym.good_if_ne_zero*
 должны выполняться три условия:

- *arg1* должен быть отрицательным числом, иначе мы выйдем раньше
- *sym.written_by_instr_C* не должен быть 0 в момент вызова «J». Это означает, что инструкции «C», «AC» и «SC» следует использовать перед вызовом «J».
- *arg1_and_0x3f* должен быть отрицательным в момент проверки. Так как бит знака 0x3f равен нолю, несмотря ни на значение *arg1*, результат выражения *arg1* & 0x3f всегда будет неотрицательный. Помните, что «J» инвертирует биты *arg1_and_0x3f* если *arg1* & 0x40 не равен нулю. Это означает, что 6-й бит *arg1* должен быть 1 (0x40 = 01000000b). Также из-за того, что *arg1_and_0x3f* тоже не может быть 0, по крайней мере один из битов в позициях 0, 1, 2, 3, 4, 5 *arg1* должны быть be 1 (0x3f = 00111111b).

Теперь информации достаточно, можно писать программу. Или же иожно просто сделать быстрый и грязный реверс-инжениринг, использованный ранее в CTF:

```
\x90\x00PSAMuAP\x01AMcAP\x01AMhAP\x01AM AP\x01AMVAP\x01AMMAP\x01AM!AP\x01AM AP\x01AMMAP\x01AMuAP\x01AMCAP\x01AMHAP\x01AM AP\x01AMrAP\x01AMeAP\x01AMVAP\x01AM3AP\x01AMrAP\x01AMsAP\x01AMeIPAM!X\x00CAJ\xc1SC\x00DCR*
```

Имейте в виду, что этот результат получен "на лету", параллельно фазе взлома. Например, есть части, реализованные без перечня всех возможных инструкций. Это означает, что код уродлив и неэффективен.
