.first_steps
------------

Хорошо, хватит хвалить r2, давайте начнем взламывать (ревер-инжениринг) программы. Во-первых, вы должны знать своего врага:

```
[0x00 avatao]$ rabin2 -I reverse4
pic      false
canary   true
nx       true
crypto   false
va       true
intrp    /lib64/ld-linux-x86-64.so.2
bintype  elf
class    ELF64
lang     c
arch     x86
bits     64
machine  AMD x86-64 architecture
os       linux
subsys   linux
endian   little
stripped true
static   false
linenum  false
lsyms    false
relocs   false
rpath    NONE
binsz    8620
```

> ***Совет от r2:*** rabin2 — это удобный инструмент, поставляемый вместе с radare2. Он используется для извлечения информации (импорты, символы, библиотеки и т. д.) из бинарных исполняемых файлов. Как всегда, пользуйтесь справкой (rabin2 -h)!

Итак, имеем динамически связанный, 64-битный исполняемый файл Linux с вырезанной информацией о символах (stripped) - ничего особенного. Попробуем запустить его:

```
[0x00 avatao]$ ./reverse4
?
Size of data: 2623
pamparam
Wrong!

[0x00 avatao]$ "\x01\x00\x00\x00" | ./reverse4
Size of data: 1
```

Хорошо, программа сначала считывает число в качестве размера со стандартного ввода, затем читает далее, вероятно, "размер" байтов/символов, обрабатывает этот ввод и выводит либо "Неправильно!", либо ничего, либо еще что-то, предположительно наш флаг. Не стоит тратить больше времени на дебильный подбор данных для ввода исполняемого файла, запустим r2, потому что in asm we trust!

```
[0x00 avatao]$ r2 -A reverse4
 -- Heisenbug: A bug that disappears or alters its behavior when one attempts to probe or isolate it.
(-- Heisenbug - ошибка, которая исчезает или меняет свое поведение при попытке исследовать или изолировать ее (синдром телемастера).)
[0x00400720]>
```

> ***Совет от r2:*** Флаг командной строки -A запускает команду *ааа* при запуске r2, он анализирует весь код на наличие перекресных ссылок. Вследствие этого мы получим имена функций, строк, информацию о перекрестных сслках (XREFS) и т.д. уже при первом входе в командную строку r2. Как всегда, нужна помощь - используйте *?*.

Хорошей практикой является создание проекта для сохранения и восстановления состояния при повтрном входе в r2:

```
[0x00400720]> Ps avatao_reverse4
avatao_reverse4
[0x00400720]>
```

> ***Совет от r2:*** Сохранение проекта - команда Ps [файл] файл, загрузка - Po [файл].
> При помощи флага -p можно загрузить проект при запуске r2.

Посмотрим все найденные строки r2:

```
[0x00400720]> fs strings
[0x00400720]> f
0x00400e98 7 str.Wrong_
0x00400e9f 27 str.We_are_in_the_outer_space_
0x00400f80 18 str.Size_of_data:__u_n
0x00400f92 23 str.Such_VM__MuCH_reV3rse_
0x00400fa9 16 str.Use_everything_
0x00400fbb 9 str.flag.txt
0x00400fc7 26 str.You_won__The_flag_is:__s_n
0x00400fe1 21 str.Your_getting_closer_
[0x00400720]>
```

> ***Совет от r2:*** r2 ставит флаги на важные/интересные адреса смещений, и организует их в пространства флагов (строки, функции, символы и т.д.). Можно посмотреть список всех пространств, используя *fs*, подключиться - *fs [пространство]* (по умолчанию - \*, что означает все пространства флагов). Команда *f* покажет все флаги из выбранного пространства.

Итак, строки выглядят интересно, особенно 0x00400f92. Намекает, что этот crackme основан на виртуальной машине. Будем иметь ввиду!

Строки служат хорошей отправной точкой, если иметь дело с реальным приложением со множеством разных функций. Но у нас crackme, они обычно маленькие и простые, сосредоточены на решении простых задач. Поэтому просто смотрим на точку или точки входа, можно ли понять что-то оттуда. Сайчас все-таки посмотрим, где эти строки используются:

```
[0x00400720]> axt @@=`f~[0]`
d 0x400cb5 mov edi, str.Size_of_data:__u_n
d 0x400d1d mov esi, str.Such_VM__MuCH_reV3rse_
d 0x400d4d mov edi, str.Use_everything_
d 0x400d85 mov edi, str.flag.txt
d 0x400db4 mov edi, str.You_won__The_flag_is:__s_n
d 0x400dd2 mov edi, str.Your_getting_closer_
```

> ***Совет от r2:*** можно посмотреть список перекрестных ссылок на адреса, используя команду *axt [адрес]*. Также можно использовать *axf* перечислить ссылки с заданного адреса).
> Последовательность символов *@@* задает итератор, он запускает команду, подставляя в качестве параметра каждый элемент списка.
>
> Список аргументов в данном примере берется из команды *f~[0]* . Она порождает список строк из исполняемого файла *f*, при этом фильтрует встроенным grep-ом *~* только первые столбцы (*[0]*), содержащие адреса строк.
