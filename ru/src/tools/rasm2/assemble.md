## Ассемблирование

Ассемблирование преобразует инструкцию микропроцессора в человекочитаемой форме в виде мнемоники в набор байтов, выполняемые машиной. В radare2 ассемблирование и дизассемблирование реализованы в API r_asm_*. Функции API запускаются командами `pa` и `pad` из командной строки radare2, а также с помощью инструмента `rasm2`.

Rasm2 используется для создания и вставки в блоки байтов шестнадцатеричных кодов, представляющих машинную инструкцию. Следующая строка собирает инструкцию mov для x86/32.

```
$ rasm2 -a x86 -b 32 'mov eax, 33'
b821000000
```

Помимо указания входных данных в качестве аргумента rasm2, мнемоники можно задавать в rasm2:

```
$ echo 'push eax;nop;nop' | rasm2 -f -
5090
```

Как видно, rasm2 может собирать одну или несколько инструкций. В командной строке мнемоники разделяются точкой с запятой `;`. Мнемоники также можно загружать это из файла, основывающийся на синтаксисе и директивах nasm/gas/... Можно ознакомиться со справочной страницей rasm2 для получения более подробной информации.

Команды `pa` и `pad` являются подкомандами печати, они отображают результаты ассемблирования и дизассемблирования. Надо сформировать и записать в блок данных инструкцию? - используйте команды `wa` и `wx` с добавлением строки с мнемониками или байтов.

Ассемблер понимает различные диалекты ассемблера: `x86` (варианты Intel и AT&T), `olly` (синтаксис OllyDBG), `powerpc` (PowerPC), `arm` и `java`. Для синтаксиса Intel rasm2 имитирует NASM и GAS.

В репозитории исходного кода rasm2 содержат несколько примеров реализации функций ассемблирования. Ознакомьтесь с ними, посмотрите, как  реализуется ассемблирование в  двоичный блок данных и в файл.

Создадим двоичный файл с именем `selfstop.rasm` из мнемоник ассемблера:

```asm
;
; Шелл-код запуска системного выхова, останавливающего программу. 
; Код представлен в диалекте rasm для x86.
;
; -- Автор - pancake
;

.arch x86
.equ base 0x8048000
.org 0x8048000  ; смещение, куда мы вставим 5 байт jmp-а

selfstop:
  push 0x8048000
  pusha
  mov eax, 20
  int 0x80

  mov ebx, eax
  mov ecx, 19
  mov eax, 37
  int 0x80
  popa
  ret
;
; Вставка системного вызова
;

  ret
```

Теперь можно собрать его "на месте" (in place):

```
[0x00000000]> e asm.bits = 32
[0x00000000]> wx `!rasm2 -f a.rasm`
[0x00000000]> pd 20
	   0x00000000    6800800408   push 0x8048000 ;  0x08048000
	   0x00000005    60           pushad
	   0x00000006    b814000000   mov eax, 0x14 ;  0x00000014
	   0x0000000b    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000000d    89c3         mov ebx, eax
	   0x0000000f    b913000000   mov ecx, 0x13 ;  0x00000013
	   0x00000014    b825000000   mov eax, 0x25 ;  0x00000025
	   0x00000019    cd80         int 0x80
		  syscall[0x80][0]=?
	   0x0000001b    61           popad
	   0x0000001c    c3           ret
	   0x0000001d    c3           ret
```

### Визуальный режим

Ассемблирование также доступно в визуальном режиме radare2 по нажатию клавиши `A` -  вставка генерированного кода по адресу смещения. Функция ассемблирования в визуальном режиме не вносит изменения в память, пока не будет нажат enter - это замечательное ее свойство! Таким образом, можно проверить размер кода и то, какие инструкции перекрываются, прежде чем фиксировать изменения.
