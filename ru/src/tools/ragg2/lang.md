# Синтаксис языка

Код r\_egg компилируется однопроходным компилятором. Необходимо, в частности, определить правильный размер фрейма стека функции во избежание ошибок компиляции.

Компилятор генерирует ассемблерный код для x86-{32,64} и ARM. Также преследуется цель поддержать большее количество платформ. Этот код компилируется с помощью r\_asm и формирует маленький двоичный файл с r\_bin.

Можно использовать r\_egg для создания автономных двоичных файлов, не зависящих от смещения, оп-кодов для инъекций в запущенные процессы и в двоичные файлы на диске.

Сгенерированный код не оптимизирован, но безопасен для выполнения.

## Препроцессор

### Псевдонимы

Иногда во время компиляции нужно заменить одну сущность в нескольких местах. Псевдонимы переводятся в операторы 'equ' в сборке языка, т.е. эти переопределения делаются при помощи ключевых слов на уровне ассемблера.

` AF_INET@alias(2);`

` printf@alias(0x8053940);`

### Включения в текст

Используйте `cat(1)` или препроцессор для объединения нескольких скомпилированных файлов.

` INCDIR@alias("/usr/include/ragg2");`

` sys-osx.r@include(INCDIR);`



### Хашбанг

Можно использовать хэшбанг, чтобы сделать сгенерированные файлы (eggs) исполняемыми.

`$ head -n1 hello.r`

` #!/usr/bin/ragg2 -X`

` $ ./hello.r`

` Hello World!`

### Main

Кода выполняется последовательно: первая определенная функция будет  исполняться первой. Если надо запустить main\(\) просто пишите исходный код в следующей форме:

` #!/usr/bin/ragg2 -X`

` main();`

` ...`

` main@global(128,64) {`

` ...`




### Определение функции

Если надо разделить свой код на несколько блоков. Блоки кода привязаны к метке, за которой следуют скобки '{ ... }'.

### Сигнатуры функций

`name@type(stackframesize,staticframesize) { body }`,

`name` : имя определяемой функции,

`type`  : см. типы функций ниже,

`stackframesize` : получение пространства из стека для хранения локальных переменных,

`staticframesize` : получение пространства из стека для хранения статических переменных \(strings\),

`body` : код функции.


### Типы функций

`alias`   Используется для создания псевдонимов,

`data` ; тело блока определяется в .data,

`inline` ; тело функции встраивается в вызывающий код (inlined) при вызове,

`global` ; сделать символ глобальным,

`fastcall` ; функция, вызываемая с помощью соглашения о быстром вызове,

`syscall`  ; определение соглашения о вызове для системного вызова.

### Системные вызовы

Программа r\_egg предлагает синтаксический сахар для определения системных вызовов. Синтаксис выглядит следующим образом:

` exit@syscall(1);`

` @syscall() {`

`` : mov eax, `.arg```

` : int 0x80`

` }`

` main@global() {`

` exit (0);`

` }`

### Библиотеки

На данный момент отсутствует поддержка связывания r\_egg программ с системными библиотеками. Но если вы вставляете код в программу \(диск/память\), нужно определить адрес каждой функции, используя синтаксис @alias.

### Основная библиотека

Ведется разработка библиотеки, похожую на библиотеку libc, полностью реализованную на r\_egg.

### Переменные

`.arg`

`.arg0`

`.arg1`

`.arg2`

`.var0`

`.var2`

`.fix`

`.ret ; eax for x86, r0 for arm`

`.bp`

`.pc`

`.sp`

__Внимание:__ Все числа после `.var` и `.arg` означают смещение относительно верхней части стека, они не являются частями имен переменных.

### Массивы

Поддерживается в виде raw-указателей. TODO: улучшить эту функцию.

### Отслеживание

Иногда r\_egg-программы ломаются или просто не работают так, как ожидалось. Используйте архитектуру 'trace', чтобы получить трассировку вызова arch-backend:

` $ ragg2 -a trace -s yourprogram.r`

### Указатели

TODO: Теоретически '\*' используется для получения содержимого указателя памяти.

### Виртуальные регистры

TODO: a0, a1, a2, a3, sp, fp, bp, pc

### Математические операции

Ragg2 поддерживает присвоение локальным переменным результатов математических операций, в том числе следующие операторы:

`+` `-` `*` `/` `&` `|` `^`

### Возвращаемые значения

Возвращаемое значение хранится в регистре a0, этот регистр устанавливается в результате вызова функции, или при использованиии  переменной без присвоения.

```
$ cat test.r
add@global(4) {
	.var0 = .arg0 + .arg1;
	.var0;
}

main@global() {
	add (3,4);
}

$ ragg2 -F -o test test.r
$ ./test
$ echo $?
7
```

### Ловушки (traps)

Каждая архитектура имеет отдельную инструкцию для прерывания выполнения программы. Язык REgg использует функцию 'break\(\)' для запуска emit\_trap - обратный вызов для выбранной архитектуры. Функция ` break()`; --&gt; компилируется в 'int3' на x86, ` break;` --&gt; компилируется в 'int3' на x86.


### Встроенный ассемблер

Строки с префиксом ':' просто встроены в выходной файл.

` : jmp 0x8048400`

` : .byte 33,44`

### Метки

Метки определяются, используя ключевое слово `:`, следующим образом:

` :label_name:`,

` /* бесконечный цикл */`,

` goto(label_name`\).

### Управление исполнением

` goto (addr)` -- ветвление,

` while (cond)`,

` if (cond)`,

` if (cond) { body } else { body }`,

` break ()` -- выполняет инструкцию trap.

### Комментарии

Поддерживаемый синтаксис для комментариев:

` /* многострочный комментарий */'`,

` // однострочный комментарий`,

` # однострочный комментарий`.
