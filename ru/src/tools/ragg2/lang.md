# Синтаксис языка

Код r\_egg компилируется как будто бы он в потоке. Это однопроходный компилятор;

это означает, что необходимо определить правильный размер фрейма стека на уровне

начала функции, нужно определить функции в

во избежание ошибок компиляции.

Компилятор генерирует ассемблерный код для x86-{32,64} и ARM. Но он преследует целью

поддержать большее количество платформ. Этот код компилируется с помощью r\_asm и

добавляется в крошечный двоичный файл с r\_bin.

Можно использовать r\_egg для создания автономных двоичных файлов, не зависящих от

смещения, сырого кода для инъекций в запущенные процессы или вносить правки

в двоичные файлы на диске.

Сгенерированный неоптимизирован, но безопасен для выполнения

в любом месте кода.

## Препроцессор

### Псевдонимы

Иногда нужно заменить во время компиляции одну сущность на

в нескольких местах. Псевдонимы переводятся в операторы 'equ' в сборке

языка Это просто переопределение ключевого слова на уровне ассемблера.

` AF_INET@alias(2);`

` printf@alias(0x8053940);`

### Включения в текст

Используйте `cat(1)` или препроцессор для объединения нескольких скомпилируемых файлов.

` INCDIR@alias("/usr/include/ragg2");`

` sys-osx.r@include(INCDIR);`



### Хашбанг

яйца могут использовать хэшбанг, чтобы сделать их исполняемыми.

`$ head -n1 hello.r`

` #!/usr/bin/ragg2 -X`

` $ ./hello.r`

` Hello World!`

### Main

Выполнение кода выполняется как в потоке. Первая функция, которая должна

определяться, будет первой выполненной. Если надо запустить main\(\)

просто сделайте так:

` #!/usr/bin/ragg2 -X`

` main();`

` ...`

` main@global(128,64) {`

` ...`




### Определение функции

Если надо разделить свой код на несколько блоков кода. Блоки кода

привязаны к метке, за которой следуют корневые скобки '{ ... }'

### Сигнатуры функций

`name@type(stackframesize,staticframesize) { body }`

`name` : имя определяемой функции

`type`  : см. типы функций ниже

`stackframesize` : получение пространства из стека для хранения локальных переменных

`staticframesize` : получение пространства из стека для хранения статических переменных \(strings\)

`body` : код функции


### Типы функций

`alias`   Используется для создания псевдонимов

`data` ; тело блока определяется в .data

`inline` ; тело функции встраивается в вызывающий код (inlined) при вызове

`global` ; сделать символ глобальным

`fastcall` ; функция, вызываемая с помощью соглашения о быстром вызове

`syscall`  ; определение соглашения о вызове для системного вызова

### Системные вызовы

r\_egg предлагает синтаксический сахар для определения системных вызовов. Синтаксис выглядит следующим образом:

` exit@syscall(1);`

` @syscall() {`

`` : mov eax, `.arg```

` : int 0x80`

` }`

` main@global() {`

` exit (0);`

` }`

### Библиотеки

На данный момент отсутствует поддержка связывания r\_egg программ с системными

библиотеками. Но если вы вставляете код в программу \(диск/память\),

нужно определить адрес каждой функции, используя синтаксис @alias.



### Основная библиотека

Ведется разработка библиотеки, похожую на библиотеку libc, полностью реализованную на r\_egg

### Переменные

`.arg`

`.arg0`

`.arg1`

`.arg2`

`.var0`

`.var2`

`.fix`

`.ret ; eax for x86, r0 for arm`

`.bp`

`.pc`

`.sp`

__Внимание:__ Все числа после `.var` и `.arg` означают смещение с

верхней части стека, а не символы переменных.

### Массивы

Поддерживается в виде raw-указателей. TODO: улучшить эту функцию

### Отслеживание

Иногда r\_egg-программы ломаются или просто не работают так, как ожидалось. Используйте

архитектуру 'trace', чтобы получить трассировку вызова arch-backend:

` $ ragg2 -a trace -s yourprogram.r`

### Указатели

TODO: Теоретически '\*' используется для получения содержимого указателя памяти.

### Виртуальные регистры

TODO: a0, a1, a2, a3, sp, fp, bp, pc

### Математические операции

Ragg2 поддерживает назначение локальных переменных математическими операциями, в том числе

следующие операторы:

`+` `-` `*` `/` `&` `|` `^`

### Возвращаемые значения

Возвращаемое значение хранится в регистре a0, этот регистр устанавливается, когда

вызов функции или при вводе имени переменной без присвоения.

```
$ cat test.r
add@global(4) {
	.var0 = .arg0 + .arg1;
	.var0;
}

main@global() {
	add (3,4);
}

$ ragg2 -F -o test test.r
$ ./test
$ echo $?
7
```

### Ловушки (traps)

Каждая архитектура имеет отдельную инструкцию для прерывания выполнения

программы. Язык REgg записывает вызовы 'break\(\)' для запуска emit\_trap

обратный вызов для выбранной архитектуры. Функция


` break()`; --&gt; компилируется в 'int3' на x86

` break;` --&gt; компилируется в 'int3' на x86


### Встроенный ассемблер

Строки с префиксом ':' char просто встроены в выходную сборку.

` : jmp 0x8048400`

` : .byte 33,44`

### Метки

Вы можете определить метки, используя ключевое слово `:` следующим образом:

` :label_name:`

` /* бесконечный цикл */`

` goto(label_name`\)

### Управление исполненим

` goto (addr)` -- ветвление

` while (cond)`

` if (cond)`

` if (cond) { body } else { body }`

` break ()` -- выполняет инструкцию trap

### Комментарии

Поддерживаемый синтаксис для комментариев:

` /* многострочный комментарий */'`

` // однострочный комментарий`

` # однострочный комментарий`


