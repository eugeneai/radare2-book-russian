# ESIL

ESIL расшифровывается как "Evaluable Strings Intermediate Language". Технология использует описание на языке, подобном [Forth](https://en.wikipedia.org/wiki/Forth_%28programming_language%29), семантики оп-кодов операций целевого процессора. Представления ESIL интерпретируются, имитируя отдельные инструкции. Команды выражения ESIL разделяются запятыми. Его виртуальная машина описывается так:
```
   while ((word=haveCommand())) {
     if (word.isOperator()) {
       esilOperators[word](esil);
     } else {
       esil.push (word);
     }
     nextCommand();
   }
```
Как мы видим, ESIL использует интерпретатор на основе стека, аналогичный тому, который обычно используется для калькуляторов. Есть две категории входных данных: значения и операторы. Значение просто помещается в стек, затем оператор извлекает значения (если хотите, его аргументы) из стека, выполняет операцию и помещает результаты (если они есть) обратно в стек. ESIL использует постфиксную нотацию операций, которые мы хотим выполнить.

Посмотрим пример:
```
4,esp,-=,ebp,esp,=[4]
```
Догадываетесь, что это такое? Если возьмем запись и преобразуем ее обратно в инфиксную, получим
```
esp -= 4
4bytes(dword) [esp] = ebp
```
Теперь видно, что это выражение соответствует инструкции x86. `push ebp`! Круто, да?
Цель проекта состоит в том, чтобы выразить большинство операций, выполняемых процессорами: двоичные арифметические операции, загрузка и сохранение ячеек памяти, обработка системных вызовов. Преобразовав инструкции в ESIL, будет видно, что делает программа во время исполнения. Технология позволяет моделировать самые загадочные архитектуры, или, если у вас нет устройства для отладки.

## Использование ESIL

Визуальный режим r2 отлично подходит для использования ESIL.

Есть три переменные среды r2, управляющие формой представления процесса исполнения программы:
```
[0x00000000]> e emu.str = true
```

Переменная `asm.emu` настраивает r2, таким образом, чтобы отображалась информация ESIL. Если установлено значение true, справа от вашего дизассемблированного кода добавятся комментарии, показывающие изменения содержимого регистров и адресов памяти в результате исполнения соответствующей инструкции. Например, для инструкции, вычитающей значение из регистра, ESIL сообщит, каким было значение до и каким оно становится после исполнения инструкции. Теперь не нужно отслеживать, какое значение куда идет. Правда при этом приходится воспринимать сразу много информации, что иногда просто не нужно. В r2 есть хороший компромисс. Для этого есть `emu.str` (`asm.emustr` для версии r2 <= 2.2). Вместо сверхподробного вывода с каждым значением регистра, настройка добавляет к коду только действительно полезную информацию, например, строки, найденные по адресам, или вероятность того, что переход будет выполнен или нет.

Третья важная переменная - `asm.esil`. Она переключает дизассемблирование таким образом, что оно больше не показывает фактически дизассемблированные инструкции, а вместо этого печатает соответствующие выражения ESIL, описывающие, что делает инструкция.
Если хотите посмотреть, как инструкции выражаются в ESIL, просто установите значение переменной «asm.esil» в true.

```
[0x00000000]> e asm.esil = true
```

В визуальном режиме также можно переключить эти варианты представления кода, просто нажав `О` .

## ESIL-команды

* "ae" : Вычислить выражение ESIL.

```
[0x00000000]> "ae 1,1,+"
0x2
[0x00000000]>
```

* "aes" : Шаг ESIL.

```
[0x00000000]> aes
[0x00000000]>10aes
```
* "aeso" : ESIL Step Over.

```
[0x00000000]> aeso
[0x00000000]>10aeso
```

* "aesu" : ESIL Step Until.

```
[0x00001000]> aesu 0x1035
ADDR BREAK
[0x00001019]>
```

* "ar" : Показать/задать регистр ESIL.

```
[0x00001ec7]> ar r_00 = 0x1035
[0x00001ec7]> ar r_00
0x00001035
[0x00001019]>
```

### Набор инструкций ESIL

Вот полный набор инструкций, используемый виртуальной машиной ESIL:

| Код операции ESIL | Операнды | Название | Операция | Пример |
--- | --- | --- | --- | ----------------------------------------------
| TRAP | src | Trap | Trap-сигнал |
| **$** | src | Прерывание | interrupt | 0x80,$ |
| **()** | src | Системный вызов | syscall | rax,() |
| **$$** | src | Адрес инструкции | Получить адрес текущей инструкции <br>стек=адрес инструкции |
| **==** | src,dst | Сравнение | stack = (dst == src) ; <br> update_eflags(dst - src) |
| **<** | src,dst | Меньше (сравнение с учетом знака) | stack = (dst < src) ; <br> update_eflags(dst - src) | [0x0000000]> "ae 1,5,<" <br>0x0<br>&gt; "ae 5,5"<br>0x0" |
| **<=** | src,dst | Меньше или равно (сравнение с учетом знака) | stack = (dst <= src) ; <br> update_eflags(dst - src) | [0x0000000]> "ae 1,5,<" <br>0x0<br>&gt; "ae 5,5"<br>0x1" |
| **>** | src,dst | Больше (сравнение с учетом знака) | stack = (dst > src) ; <br> update_eflags(dst - src) | &gt; "ae 1,5,>"<br>0x1<br>&gt; "ae 5,5,>"<br>0x0 |
| **>=** | src,dst | Больше или равно (сравнение с учетом знака) | stack = (dst >= src) ; <br> update_eflags(dst - src) | &gt; "ae 1,5,>="<br>0x1<br>&gt; "ae 5,5,>="<br>0x1 |
| **<<** | src,dst | Сдвиг влево | stack = dst << src | &gt; "ae 1,1,<<"<br>0x2<br>&gt; "ae 2,1,<<"<br>0x4 |
| **>>** | src,dst | Сдвиг вправо | stack = dst >> src | &gt; "ae 1,4,>>"<br>0x2<br>&gt; "ae 2,4,>>"<br>0x1 |
| **<<<** | src,dst | Циклический сдвиг влево | stack=dst ROL src | &gt; "ae 31,1,<<<"<br>0x80000000<br>&gt; "ae 32,1,<<<"<br>0x1 |
| **>>>** | src,dst | Циклический сдвиг вправо | stack=dst ROR src | &gt; "ae 1,1,>>>"<br>0x80000000<br>&gt; "ae 32,1,>>>"<br>0x1 |
| **&** | src,dst | AND | stack = dst & src | &gt; "ae 1,1,&"<br>0x1<br>&gt; "ae 1,0,&"<br>0x0<br>&gt;  "ae 0,1,&"<br>0x0<br>&gt; "ae 0,0,&"<br>0x0 |
| **&#x7c;** | src,dst | OR | stack = dst &#x7c; src | &gt; "ae 1,1,&#x7c;"<br>0x1<br>&gt; "ae 1,0,&#x7c;"<br>0x1<br>&gt; "ae 0,1,&#x7c;"<br>0x1<br>&gt; "ae 0,0,&#x7c;"<br>0x0 |
| **^** | src,dst | XOR | stack = dst ^src | &gt; "ae 1,1,^"<br>0x0<br>&gt; "ae 1,0,^"<br>0x1<br>&gt; "ae 0,1,^"<br>0x1<br>&gt; "ae 0,0,^"<br>0x0 |
| **+** | src,dst | ADD | stack = dst + src | &gt; "ae 3,4,+"<br>0x7<br>&gt; "ae 5,5,+"<br>0xa |
| **-** | src,dst | SUB | stack = dst - src | &gt; "ae 3,4,-"<br>0x1<br>&gt; "ae 5,5,-"<br>0x0<br>&gt; "ae 4,3,-"<br>0xffffffffffffffff |
| **\*** | src,dst | MUL | stack = dst * src | &gt; "ae 3,4,\*"<br>0xc<br>&gt; "ae 5,5,\*"<br>0x19 |
| **/** | src,dst | DIV | stack = dst / src | &gt; "ae 2,4,/"<br>0x2<br>&gt; "ae 5,5,/"<br>0x1<br>&gt; "ae 5,9,/"<br>0x1 |
| **%** | src,dst | MOD | stack = dst % src | &gt; "ae 2,4,%"<br>0x0<br>&gt; "ae 5,5,%"<br>0x0<br>&gt; "ae 5,9,%"<br>0x4 |
| **~** | bits,src | SIGNEXT | stack = src sign extended | &gt; "ae 8,0x80,~"<br>0xffffffffffffff80 |
| **~/** | src,dst | SIGNED DIV | stack = dst / src (signed) | &gt; "ae 2,-4,~/"<br>0xfffffffffffffffe |
| **~%** | src,dst | SIGNED MOD | stack = dst % src (signed) | &gt; "ae 2,-5,~%"<br>0xffffffffffffffff |
| **!** | src | NEG | stack = !!!src | &gt; "ae 1,!"<br>0x0<br>&gt; "ae 4,!"<br>0x0<br>&gt; "ae 0,!"<br>0x1<br> |
| **++** | src | INC | stack = src++ | &gt; ar r_00=0;ar r_00<br>0x00000000<br>&gt; "ae r_00,++"<br>0x1<br>&gt; ar r_00<br>0x00000000<br>&gt; "ae 1,++"<br>0x2 |
| **--** | src | DEC | stack = src-- | &gt; ar r_00=5;ar r_00<br>0x00000005<br>&gt; "ae r_00,--"<br>0x4<br>&gt; ar r_00<br>0x00000005<br>&gt; "ae 5,--"<br>0x4 |
| **=** | src,reg | EQU | reg = src | &gt; "ae 3,r_00,="<br>&gt; aer r_00<br>0x00000003<br>&gt; "ae r_00,r_01,="<br>&gt; aer r_01<br>0x00000003 |
| **:=** | src,reg | слвбое EQU | reg = src without side effects | &gt; "ae 3,r_00,:="<br>&gt; aer r_00<br>0x00000003<br>&gt; "ae r_00,r_01,:="<br>&gt; aer r_01<br>0x00000003 |
| **+=** | src,reg | ADD eq | reg = reg + src | &gt; ar r_01=5;ar r_00=0;ar r_00<br>0x00000000<br>&gt; "ae r_01,r_00,+="<br>&gt; ar r_00<br>0x00000005<br>&gt; "ae 5,r_00,+="<br>&gt; ar r_00<br>0x0000000a |
| **-=** | src,reg | SUB eq | reg = reg - src | &gt; "ae r_01,r_00,-="<br>&gt; ar r_00<br>0x00000004<br>&gt; "ae 3,r_00,-="<br>&gt; ar r_00<br>0x00000001 |
| **\*=** | src,reg | MUL eq | reg = reg * src | &gt; ar r_01=3;ar r_00=5;ar r_00<br>0x00000005<br>&gt; "ae r_01,r_00,\*="<br>&gt; ar r_00<br>0x0000000f<br>&gt; "ae 2,r_00,\*="<br>&gt; ar r_00<br>0x0000001e |
| **/=** | src,reg | DIV eq | reg = reg / src | &gt; ar r_01=3;ar r_00=6;ar r_00<br>0x00000006<br>&gt; "ae r_01,r_00,/="<br>&gt; ar r_00<br>0x00000002<br>&gt; "ae 1,r_00,/="<br>&gt; ar r_00<br>0x00000002 |
| **%=** | src,reg | MOD eq | reg = reg % src | &gt;  ar r_01=3;ar r_00=7;ar r_00<br> 0x00000007<br> &gt; "ae r_01,r_00,%="<br> &gt; ar r_00<br> 0x00000001<br> &gt;  ar r_00=9;ar r_00<br> 0x00000009<br> &gt; "ae 5,r_00,%="<br> &gt; ar r_00<br> 0x00000004 |
| **<<=** | src,reg | Shift Left eq | reg = reg << src | &gt; ar r_00=1;ar r_01=1;ar r_01<br>0x00000001<br>&gt; "ae r_00,r_01,<<="<br>&gt; ar r_01<br>0x00000002<br>&gt; "ae 2,r_01,<<="<br>&gt; ar r_01<br>0x00000008 |
| **>>=** | src,reg | Shift Right eq | reg = reg << src | &gt; ar r_00=1;ar r_01=8;ar r_01<br>0x00000008<br>&gt; "ae r_00,r_01,>>="<br>&gt; ar r_01<br>0x00000004<br>&gt; "ae 2,r_01,>>="<br>&gt; ar r_01<br>0x00000001 |
| **&=** | src,reg | AND eq | reg = reg & src | &gt; ar r_00=2;ar r_01=6;ar r_01<br>0x00000006<br>&gt; "ae r_00,r_01,&="<br>&gt; ar r_01<br>0x00000002<br>&gt; "ae 2,r_01,&="<br>&gt; ar r_01<br>0x00000002<br>&gt; "ae 1,r_01,&="<br>&gt; ar r_01<br>0x00000000 |
| **&#x7c;=** | src,reg | OR eq | reg = reg &#x7c; src | &gt; ar r_00=2;ar r_01=1;ar r_01<br>0x00000001<br>&gt; "ae r_00,r_01,&#x7c;="<br>&gt; ar r_01<br>0x00000003<br>&gt; "ae 4,r_01,&#x7c;="<br>&gt; ar r_01<br>0x00000007 |
| **^=** | src,reg | XOR eq | reg = reg ^ src | &gt; ar r_00=2;ar r_01=0xab;ar r_01<br>0x000000ab<br>&gt; "ae r_00,r_01,^="<br>&gt; ar r_01<br>0x000000a9<br>&gt; "ae 2,r_01,^="<br>&gt; ar r_01<br>0x000000ab |
| **++=** | reg | INC eq | reg = reg + 1 | &gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; "ae r_00,++="<br>&gt; ar r_00<br>0x00000005 |
| **--=** | reg | DEC eq | reg = reg - 1 | &gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; "ae r_00,--="<br>&gt; ar r_00<br>0x00000003 |
| **!=** | reg | NOT eq | reg = !reg | &gt; ar r_00=4;ar r_00<br>0x00000004<br>&gt; "ae r_00,!="<br>&gt; ar r_00<br>0x00000000<br>&gt; "ae r_00,!="<br>&gt; ar r_00<br>0x00000001 |
| --- | --- | --- | --- | ---------------------------------------------- |
| =[]<br>=[\*]<br>=[1]<br>=[2]<br>=[4]<br>=[8] | src,dst | poke | \*dst=src | <br>&gt; "ae 0xdeadbeef,0x10000,=[4],"<br><br>&gt; pxw 4@0x10000<br>0x00010000  0xdeadbeef                                ....<br><br>&gt; "ae 0x0,0x10000,=[4],"<br><br>&gt; pxw 4@0x10000<br>0x00010000  0x00000000 |
| []<br>[\*]<br>[1]<br>[2]<br>[4]<br>[8] | src | peek | stack=\*src | <br>&gt; w test@0x10000<br><br>&gt; "ae 0x10000,[4],"<br>0x74736574<br><br>&gt; ar r_00=0x10000<br><br>&gt; "ae r_00,[4],"<br>0x74736574 |
| &#x7c;=[]<br>&#x7c;=[1]<br>&#x7c;=[2]<br>&#x7c;=[4]<br>&#x7c;=[8] | reg | nombre | code | &gt; <br>&gt; |
| SWAP |  | Swap | Поменять местами два верхних элемента | SWAP |
| DUP | | Duplicate | Дублировать верхний элемент в стеке | DUP |
| NUM | | Numeric | Если верхний элемент является ссылкой <br> (регистровое имя, метка и т.д.),<br> разыменовать его и положить на стек его реальное значение | NUM |
| CLEAR | | Clear | Очистить стек | CLEAR |
| BREAK | | Break | Останавливает эмуляцию ESIL | BREAK |
| GOTO | n | Goto | Переход к N-му слову ESIL | GOTO 5 |
| TODO | | To Do | Останавливает выполнение <br> (причина: выражение ESIL не завершено) | TODO |

### Флаги ESIL

Виртуальная машина ESIL по умолчанию предоставляет набор вспомогательных операций для вычисления флагов.
Они выполняют свою задачу, сравнивая старое и новое значение операнда dst последней выполненной операции eq.
На каждой операции eq (например, `==`) ESIL сохраняет старое и новое значение операнда dst.
Обратите внимание, что существуют также слабые операции eq (например, `:=`), которые не влияют на операции с флагами.
Операция `==` влияет на операции с флагами, несмотря на то, что она не является операцией eq.
Операции с флагами задаются префиксным символом `$`.

```
z      - флаг zero (ноль) устанавливается только если результат был 0
b      - флаг borrow (заем), требует указывать из какого бита занимать (пример: 4,$b - проверяет, можно ли занимать из бита 4)
c      - флаг carry (перенос), то же что выше(пример: 7,$c - проверяет наличие переноса из бита 7)
o      - флаг overflow (переполнение)
p      - флаг parity (четность)
r      - флаг regsize (изменение размера) ( asm.bits/8 )
s      - флаг sign (знак)
ds     - delay slot state
jt     - jump target
js     - jump target set
```

## Синтаксис и команды
Целевой оп-код транслируется в список выражений ESIL, разделенных запятыми.
```
xor eax, eax    ->    0,eax,=,1,zf,=
```
Доступ к памяти определяется операциями "скобки":
```
mov eax, [0x80480]   ->   0x80480,[],eax,=
```
Размер данных по умолчанию определяется размером операнда назначения.
```
movb $0, 0x80480     ->   0,0x80480,=[1]
```

Оператор `?` использует значение своего аргумента, решает, следует ли вычислять выражение в фигурных скобках.

1. Значение равно нулю?      -> Пропустить.
2. Значение не равно нулю?  -> Вычислить.

```
cmp eax, 123  ->   123,eax,==,$z,zf,=
jz eax        ->   zf,?{,eax,eip,=,}
```


Запустить несколько выражений под условным выражением можно, поместив их в фигурные скобки:
```
zf,?{,eip,esp,=[],eax,eip,=,$r,esp,-=,}
```

Пробелы, переводы строки и другие символы игнорируются. Итак, первое, что нужно сделать при подготовке ESIL-программы, — удалить пробелы:
```
esil = r_str_replace (esil, " ", "", R_TRUE);
```

Системные вызовы нуждаются в особой обработке. Они обозначаются символом «$» в начале выражения. Можно передать необязательное числовое значение - номер системного вызова. Эмулятор ESIL должен обрабатывать системные вызовы. Смотри (r_esil_syscall).

## Порядок аргументов для неассоциативных операций

Как обсуждалось в IRC, текущая реализация работает следующим образом:

```
a,b,-      b - a
a,b,/=     b /= a
```
Такой вариант более удобочитаем, но менее удобен для стека.

### Специальные указания

NOP представлены в виде пустых строк. Как было сказано выше, прерывания помечаются командой '$'. Например, «0x80,$». Он делегирует эмуляцию с машины ESIL callback-функции, реализующей обработчик прерывания для конкретной ОС/ядра/платформы.

Аппаратные прерывания (traps) реализованы при помощи команды `TRAP`. Они используются для создания исключений для недопустимых инструкций, деления на ноль, ошибки чтения памяти или любых других действий, необходимых для конкретных архитектур.

### Экспресс-анализ

Вот список некоторых экспресс-проверок для извлечения информации из строки ESIL. Соответствующая информация, вероятно, будет найдена в первом выражении списка.
```
indexOf('[')    -> включает ссылки на ячейки памяти
indexOf("=[")   -> пишет в память
indexOf("pc,=") -> изменяет счетчик инструкций (branch, jump, call)
indexOf("sp,=") -> изменяет стек (что если мы нашли sp+= или sp-=?)
indexOf("=")    -> получить src и dst
indexOf(":")    -> впереди неизвестный esil-, raw-оп-код
indexOf("$")    -> получает доступ к флагам виртуальной машиня esil, например: $z
indexOf("$")    -> системный вызов, например: 1,$
indexOf("TRAP") -> может перехватить
indexOf('++')   -> включает итератор
indexOf('--')   -> считает до 0
indexOf("?{")   -> условный оператор
equalsTo("")    -> пустая строка, вроде nop (будет неправдой, если мы добавим pc+=x)
```

Общие операции:
* Проверить dstreg.
* Проверить srcreg.
* Получить целевой адрес.
* Переход?
* Условие?
* Вычислить.
* Системный вызов?

### Флаги ЦП

Флаги ЦП обычно определяются как однобитные регистры в профиле RReg. Иногда их можно найти в типе регистра 'flg'.

### Переменные

Свойства переменных виртуальной машины:

1. У них нет предопределенной разрядности. Таким образом, их при необходимости, легко расширить до 128, 256 и 512 бит, например, для MMX, SSE, AVX, Neon SIMD.

2. Может быть неограниченное количество переменных. Это сделано для совместимости с SSA-формами.

3. Имена регистров не имеют определенного синтаксиса. Это просто строки.

4. Числа могут быть указаны в любой системе счисления, поддерживаемой RNum (десятичная, шестнадцатеричная, восьмеричная, двоичная...).

5. Каждый бэкенд ESIL должен иметь связанный профиль RReg для описания спецификаций регистра ESIL.

### Битовые массивы

Что с ними можно сделать? А как насчет битовой арифметики, если использовать переменные вместо регистров?

### Арифметика

1. ADD ("+"),
2. MUL ("\*"),
3. SUB ("-"),
4. DIV ("/"),
5. MOD ("%").


### Битовая арифметика

1. AND  "&",
2. OR   "|",
3. XOR  "^",
4. SHL  "<<",
5. SHR  ">>",
6. ROL  "<<<",
7. ROR  ">>>",
8. NEG  "!".

### Поддержка устройств с плавающей запятой

На момент написания этой статьи ESIL еще не поддерживает FPU. Можете реализовать поддержку неподдерживаемых инструкций с помощью r2pipe. Рано или поздно мы получим надлежащую поддержку мультимедиа и операций с плавающей запятой.

### Обработка префикса x86 REP в ESIL

ESIL указывает, что команды анализа потока управления должны быть в верхнем регистре. Имейте в виду, что некоторые архитектуры используют имена регистров в верхнем регистре. Соответствующий профиль регистра должен позаботиться о том, чтобы не использовать повторно ни одно из следующего:
```
3,SKIP   - пропустить N инструкций, создает относительные переходы GOTO вперед
3,GOTO   - переход к инструкции 3
LOOP     - псевдоним для 0,GOTO
BREAK    - закончить вычислять выражение
STACK    - вывести содержимое стека на экран
CLEAR    - очистить стек
```

#### Пример использования:

rep cmpsb
```
cx,!,?{,BREAK,},esi,[1],edi,[1],==,?{,BREAK,},esi,++,edi,++,cx,--,0,GOTO
```

### Нереализованные/необработанные инструкции

Они выражаются командой TODO. Они действуют как «BREAK», но отображают предупреждающее сообщение о том, что инструкция не реализована и не будет эмулироваться. Например:

```
fmulp ST(1), ST(0)      =>      TODO,fmulp ST(1),ST(0)
```

### Пример дизассемблирования ESIL:

```
[0x1000010f8]> e asm.esil=true
[0x1000010f8]> pd $r @ entry0
0x1000010f8    55           8,rsp,-=,rbp,rsp,=[8]
0x1000010f9    4889e5       rsp,rbp,=
0x1000010fc    4883c768     104,rdi,+=
0x100001100    4883c668     104,rsi,+=
0x100001104    5d           rsp,[8],rbp,=,8,rsp,+=
0x100001105    e950350000   0x465a,rip,= ;[1]
0x10000110a    55           8,rsp,-=,rbp,rsp,=[8]
0x10000110b    4889e5       rsp,rbp,=
0x10000110e    488d4668     rsi,104,+,rax,=
0x100001112    488d7768     rdi,104,+,rsi,=
0x100001116    4889c7       rax,rdi,=
0x100001119    5d           rsp,[8],rbp,=,8,rsp,+=
0x10000111a    e93b350000   0x465a,rip,= ;[1]
0x10000111f    55           8,rsp,-=,rbp,rsp,=[8]
0x100001120    4889e5       rsp,rbp,=
0x100001123    488b4f60     rdi,96,+,[8],rcx,=
0x100001127    4c8b4130     rcx,48,+,[8],r8,=
0x10000112b    488b5660     rsi,96,+,[8],rdx,=
0x10000112f    b801000000   1,eax,=
0x100001134    4c394230     rdx,48,+,[8],r8,==,cz,?=
0x100001138    7f1a         sf,of,!,^,zf,!,&,?{,0x1154,rip,=,} ;[2]
0x10000113a    7d07         of,!,sf,^,?{,0x1143,rip,} ;[3]
0x10000113c    b8ffffffff   0xffffffff,eax,= ;  0xffffffff
0x100001141    eb11         0x1154,rip,= ;[2]
0x100001143    488b4938     rcx,56,+,[8],rcx,=
0x100001147    48394a38     rdx,56,+,[8],rcx,==,cz,?=
```

### Интроспекция

Чтобы упростить синтаксический анализ ESIL, у нас должен быть способ представления выражений интроспекции для извлечения нужных нам данных. Например, мы можем захотеть получить целевой адрес перехода. Транслятор выражений ESIL должен предлагать API, позволяющий легко извлекать информацию путем анализа выражений.

```
>  ao~esil,opcode
opcode: jmp 0x10000465a
esil: 0x10000465a,rip,=
```
Нам нужен способ получить числовое значение 'rip'. Это очень простой пример, но есть и посложнее, вроде условных. Нам нужны выражения, чтобы иметь возможность получить:

- тип кода операции,
- целевой адрес перехода,
- состояние, от которых что-то зависит,
- список измененных регистров (write),
- список использованных (accessed) регистров (read).

### API HOOKS

Для эмуляции важно иметь возможность устанавливать хуки в синтаксическом анализаторе, так, чтобы можно было расширить его для реализации анализа без необходимости изменять его снова и снова. То есть каждый раз, непосредственно перед выполнением операции, вызывается пользовательский хук. Его можно использовать, например, для определения того, собирается ли `RIP` измениться, обновляет ли стек инструкция. Позже можно разделить этот callback на несколько и выполнить событийный анализ на основе  API, который можно расширить в JavaScript следующим образом:
```
esil.on('regset', function(){..
esil.on('syscall', function(){esil.regset('rip'
```

API содержит функции `hook_flag_read()`, `hook_execute()` и `hook_mem_read()`. Callbak должен возвращать true или 1, если надо переопределить выполняемое им действие. Например, чтобы запретить чтение памяти в регионе или отменить запись в память, фактически сделав ее доступной только для чтения. Верните false или 0, если вы хотите отслеживать синтаксический анализ выражения ESIL.

Для работы других операций требуются привязки к внешним функциям. То есть к `r_ref` и `r_io`. Это должно быть определено при инициализации виртуальной машины ESIL.

* Io Get/Set
   ```
   Out ax, 44
   44,ax,:ou
   ```
* Селекторы (cs, ds, gs...)
   ```
   Mov eax, ds:[ebp+8]
   Ebp,8,+,:ds,eax,=
   ```
